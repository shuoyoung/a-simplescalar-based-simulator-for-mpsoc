# 1 "sim-outorder.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "sim-outorder.c"
# 113 "sim-outorder.c"
# 1 "headers.h" 1




# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 329 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 313 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 314 "/usr/include/sys/cdefs.h" 2 3 4
# 330 "/usr/include/features.h" 2 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 353 "/usr/include/features.h" 2 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 134 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 135 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4









typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 326 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 3 4
typedef int wchar_t;
# 355 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 167 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 177 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 200 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 268 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 316 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 325 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 361 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 413 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern wint_t __wunderflow (_IO_FILE *);
extern wint_t __wuflow (_IO_FILE *);
extern wint_t __woverflow (_IO_FILE *, wint_t);
# 451 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
# 481 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
# 73 "/usr/include/stdio.h" 2 3 4
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));














extern FILE *tmpfile (void);
# 185 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__));
# 203 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 228 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 242 "/usr/include/stdio.h" 3 4






extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
# 269 "/usr/include/stdio.h" 3 4

# 280 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__));
# 300 "/usr/include/stdio.h" 3 4



extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 394 "/usr/include/stdio.h" 3 4





extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));

# 436 "/usr/include/stdio.h" 3 4





extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 460 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 471 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 504 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 585 "/usr/include/stdio.h" 3 4





extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 638 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 674 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 693 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 716 "/usr/include/stdio.h" 3 4

# 725 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];
# 755 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
# 774 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 814 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
# 844 "/usr/include/stdio.h" 3 4

# 6 "headers.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4


# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;



# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 182 "/usr/include/stdlib.h" 3 4


extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 279 "/usr/include/stdlib.h" 3 4
extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 429 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 62 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 100 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
       unsigned int __minor)
     __attribute__ ((__nothrow__));


__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4
# 235 "/usr/include/sys/types.h" 3 4
typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __pad1;
    unsigned long int __pad2;
    unsigned long int __pad3;


    unsigned int __flags;
  } __data;
# 184 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 439 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;







extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






# 613 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));

# 658 "/usr/include/stdlib.h" 3 4


extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));






extern int clearenv (void) __attribute__ ((__nothrow__));
# 698 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 709 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;








extern int system (__const char *__command) ;

# 756 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);









extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;












extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

# 821 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 926 "/usr/include/stdlib.h" 3 4
extern int posix_openpt (int __oflag) ;
# 961 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 977 "/usr/include/stdlib.h" 3 4

# 7 "headers.h" 2
# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 47 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__)); extern double __acos (double __x) __attribute__ ((__nothrow__));

extern double asin (double __x) __attribute__ ((__nothrow__)); extern double __asin (double __x) __attribute__ ((__nothrow__));

extern double atan (double __x) __attribute__ ((__nothrow__)); extern double __atan (double __x) __attribute__ ((__nothrow__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__));


extern double cos (double __x) __attribute__ ((__nothrow__)); extern double __cos (double __x) __attribute__ ((__nothrow__));

extern double sin (double __x) __attribute__ ((__nothrow__)); extern double __sin (double __x) __attribute__ ((__nothrow__));

extern double tan (double __x) __attribute__ ((__nothrow__)); extern double __tan (double __x) __attribute__ ((__nothrow__));




extern double cosh (double __x) __attribute__ ((__nothrow__)); extern double __cosh (double __x) __attribute__ ((__nothrow__));

extern double sinh (double __x) __attribute__ ((__nothrow__)); extern double __sinh (double __x) __attribute__ ((__nothrow__));

extern double tanh (double __x) __attribute__ ((__nothrow__)); extern double __tanh (double __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern double acosh (double __x) __attribute__ ((__nothrow__)); extern double __acosh (double __x) __attribute__ ((__nothrow__));

extern double asinh (double __x) __attribute__ ((__nothrow__)); extern double __asinh (double __x) __attribute__ ((__nothrow__));

extern double atanh (double __x) __attribute__ ((__nothrow__)); extern double __atanh (double __x) __attribute__ ((__nothrow__));







extern double exp (double __x) __attribute__ ((__nothrow__)); extern double __exp (double __x) __attribute__ ((__nothrow__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__));


extern double log (double __x) __attribute__ ((__nothrow__)); extern double __log (double __x) __attribute__ ((__nothrow__));


extern double log10 (double __x) __attribute__ ((__nothrow__)); extern double __log10 (double __x) __attribute__ ((__nothrow__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern double expm1 (double __x) __attribute__ ((__nothrow__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__));


extern double log1p (double __x) __attribute__ ((__nothrow__)); extern double __log1p (double __x) __attribute__ ((__nothrow__));


extern double logb (double __x) __attribute__ ((__nothrow__)); extern double __logb (double __x) __attribute__ ((__nothrow__));

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern double pow (double __x, double __y) __attribute__ ((__nothrow__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__));


extern double sqrt (double __x) __attribute__ ((__nothrow__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__));






extern double cbrt (double __x) __attribute__ ((__nothrow__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__));








extern double ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__));




extern int __isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__));



extern double significand (double __x) __attribute__ ((__nothrow__)); extern double __significand (double __x) __attribute__ ((__nothrow__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__)); extern double __j0 (double) __attribute__ ((__nothrow__));
extern double j1 (double) __attribute__ ((__nothrow__)); extern double __j1 (double) __attribute__ ((__nothrow__));
extern double jn (int, double) __attribute__ ((__nothrow__)); extern double __jn (int, double) __attribute__ ((__nothrow__));
extern double y0 (double) __attribute__ ((__nothrow__)); extern double __y0 (double) __attribute__ ((__nothrow__));
extern double y1 (double) __attribute__ ((__nothrow__)); extern double __y1 (double) __attribute__ ((__nothrow__));
extern double yn (int, double) __attribute__ ((__nothrow__)); extern double __yn (int, double) __attribute__ ((__nothrow__));






extern double erf (double) __attribute__ ((__nothrow__)); extern double __erf (double) __attribute__ ((__nothrow__));
extern double erfc (double) __attribute__ ((__nothrow__)); extern double __erfc (double) __attribute__ ((__nothrow__));
extern double lgamma (double) __attribute__ ((__nothrow__)); extern double __lgamma (double) __attribute__ ((__nothrow__));

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern double gamma (double) __attribute__ ((__nothrow__)); extern double __gamma (double) __attribute__ ((__nothrow__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__));







extern double rint (double __x) __attribute__ ((__nothrow__)); extern double __rint (double __x) __attribute__ ((__nothrow__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern double remainder (double __x, double __y) __attribute__ ((__nothrow__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogb (double __x) __attribute__ ((__nothrow__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__));
# 359 "/usr/include/bits/mathcalls.h" 3 4





extern double scalb (double __x, double __n) __attribute__ ((__nothrow__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__));
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__)); extern float __acosf (float __x) __attribute__ ((__nothrow__));

extern float asinf (float __x) __attribute__ ((__nothrow__)); extern float __asinf (float __x) __attribute__ ((__nothrow__));

extern float atanf (float __x) __attribute__ ((__nothrow__)); extern float __atanf (float __x) __attribute__ ((__nothrow__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__));


extern float cosf (float __x) __attribute__ ((__nothrow__)); extern float __cosf (float __x) __attribute__ ((__nothrow__));

extern float sinf (float __x) __attribute__ ((__nothrow__)); extern float __sinf (float __x) __attribute__ ((__nothrow__));

extern float tanf (float __x) __attribute__ ((__nothrow__)); extern float __tanf (float __x) __attribute__ ((__nothrow__));




extern float coshf (float __x) __attribute__ ((__nothrow__)); extern float __coshf (float __x) __attribute__ ((__nothrow__));

extern float sinhf (float __x) __attribute__ ((__nothrow__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__));

extern float tanhf (float __x) __attribute__ ((__nothrow__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern float acoshf (float __x) __attribute__ ((__nothrow__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__));

extern float asinhf (float __x) __attribute__ ((__nothrow__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__));

extern float atanhf (float __x) __attribute__ ((__nothrow__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__));







extern float expf (float __x) __attribute__ ((__nothrow__)); extern float __expf (float __x) __attribute__ ((__nothrow__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__));


extern float logf (float __x) __attribute__ ((__nothrow__)); extern float __logf (float __x) __attribute__ ((__nothrow__));


extern float log10f (float __x) __attribute__ ((__nothrow__)); extern float __log10f (float __x) __attribute__ ((__nothrow__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern float expm1f (float __x) __attribute__ ((__nothrow__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__));


extern float log1pf (float __x) __attribute__ ((__nothrow__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__));


extern float logbf (float __x) __attribute__ ((__nothrow__)); extern float __logbf (float __x) __attribute__ ((__nothrow__));

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern float powf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__));








extern float ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__));




extern int __isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__));



extern float significandf (float __x) __attribute__ ((__nothrow__)); extern float __significandf (float __x) __attribute__ ((__nothrow__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__)); extern float __j0f (float) __attribute__ ((__nothrow__));
extern float j1f (float) __attribute__ ((__nothrow__)); extern float __j1f (float) __attribute__ ((__nothrow__));
extern float jnf (int, float) __attribute__ ((__nothrow__)); extern float __jnf (int, float) __attribute__ ((__nothrow__));
extern float y0f (float) __attribute__ ((__nothrow__)); extern float __y0f (float) __attribute__ ((__nothrow__));
extern float y1f (float) __attribute__ ((__nothrow__)); extern float __y1f (float) __attribute__ ((__nothrow__));
extern float ynf (int, float) __attribute__ ((__nothrow__)); extern float __ynf (int, float) __attribute__ ((__nothrow__));






extern float erff (float) __attribute__ ((__nothrow__)); extern float __erff (float) __attribute__ ((__nothrow__));
extern float erfcf (float) __attribute__ ((__nothrow__)); extern float __erfcf (float) __attribute__ ((__nothrow__));
extern float lgammaf (float) __attribute__ ((__nothrow__)); extern float __lgammaf (float) __attribute__ ((__nothrow__));

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern float gammaf (float) __attribute__ ((__nothrow__)); extern float __gammaf (float) __attribute__ ((__nothrow__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__));







extern float rintf (float __x) __attribute__ ((__nothrow__)); extern float __rintf (float __x) __attribute__ ((__nothrow__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__));
# 359 "/usr/include/bits/mathcalls.h" 3 4





extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__));
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern long double acoshl (long double __x) __attribute__ ((__nothrow__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__));







extern long double expl (long double __x) __attribute__ ((__nothrow__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__));


extern long double logl (long double __x) __attribute__ ((__nothrow__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern long double expm1l (long double __x) __attribute__ ((__nothrow__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__));

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__)); extern long double __j0l (long double) __attribute__ ((__nothrow__));
extern long double j1l (long double) __attribute__ ((__nothrow__)); extern long double __j1l (long double) __attribute__ ((__nothrow__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__));
extern long double y0l (long double) __attribute__ ((__nothrow__)); extern long double __y0l (long double) __attribute__ ((__nothrow__));
extern long double y1l (long double) __attribute__ ((__nothrow__)); extern long double __y1l (long double) __attribute__ ((__nothrow__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__));






extern long double erfl (long double) __attribute__ ((__nothrow__)); extern long double __erfl (long double) __attribute__ ((__nothrow__));
extern long double erfcl (long double) __attribute__ ((__nothrow__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__));
extern long double lgammal (long double) __attribute__ ((__nothrow__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__));

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern long double gammal (long double) __attribute__ ((__nothrow__)); extern long double __gammal (long double) __attribute__ ((__nothrow__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__));
# 359 "/usr/include/bits/mathcalls.h" 3 4





extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__));
# 142 "/usr/include/math.h" 2 3 4
# 157 "/usr/include/math.h" 3 4
extern int signgam;
# 284 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 309 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 465 "/usr/include/math.h" 3 4

# 8 "headers.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4



extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



# 9 "headers.h" 2
# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 75 "/usr/include/signal.h" 3 4
typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 90 "/usr/include/signal.h" 3 4


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 104 "/usr/include/signal.h" 3 4

# 117 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__));




extern int raise (int __sig) __attribute__ ((__nothrow__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__));




extern void psignal (int __sig, __const char *__s);
# 153 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 181 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));
# 201 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;







# 1 "/usr/include/time.h" 1 3 4
# 210 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 213 "/usr/include/signal.h" 2 3 4



extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 247 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__));






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__));
# 304 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 328 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 26 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/sigcontext.h" 2 3 4

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 109 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  unsigned long r8;
  unsigned long r9;
  unsigned long r10;
  unsigned long r11;
  unsigned long r12;
  unsigned long r13;
  unsigned long r14;
  unsigned long r15;
  unsigned long rdi;
  unsigned long rsi;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long rdx;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rsp;
  unsigned long rip;
  unsigned long eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  unsigned long err;
  unsigned long trapno;
  unsigned long oldmask;
  unsigned long cr2;
  struct _fpstate * fpstate;
  unsigned long __reserved1 [8];
};
# 334 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__));
# 346 "/usr/include/signal.h" 3 4
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 349 "/usr/include/signal.h" 2 3 4
# 357 "/usr/include/signal.h" 3 4
extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__));
# 387 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__));
# 388 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__));




# 10 "headers.h" 2

# 1 "host.h" 1
# 125 "host.h"
typedef int bool_t;
typedef unsigned char byte_t;
typedef signed char sbyte_t;
typedef unsigned short half_t;
typedef signed short shalf_t;
typedef unsigned int word_t;
typedef signed int sword_t;
typedef float sfloat_t;
typedef double dfloat_t;




typedef unsigned long long qword_t;
typedef signed long long sqword_t;
# 170 "host.h"
typedef sqword_t counter_t;

typedef counter_t tick_t;
# 12 "headers.h" 2
# 1 "misc.h" 1
# 119 "misc.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h" 1 3 4
# 105 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 120 "misc.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 82 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

# 130 "/usr/include/string.h" 3 4
extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 181 "/usr/include/string.h" 3 4



extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 240 "/usr/include/string.h" 3 4


extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 254 "/usr/include/string.h" 3 4


extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

# 270 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 288 "/usr/include/string.h" 3 4
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 325 "/usr/include/string.h" 3 4
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 426 "/usr/include/string.h" 3 4

# 121 "misc.h" 2
# 152 "misc.h"
extern int verbose;







void
fatal_hook(void (*hook_fn)(FILE *stream));






void
_fatal(char *file, char *func, int line, char *fmt, ...)
__attribute__ ((noreturn));
# 181 "misc.h"
void
_panic(char *file, char *func, int line, char *fmt, ...)
__attribute__ ((noreturn));
# 194 "misc.h"
void
_warn(char *file, char *func, int line, char *fmt, ...);
# 206 "misc.h"
void
_info(char *file, char *func, int line, char *fmt, ...);
# 242 "misc.h"
void
mysrand(unsigned int seed);


int myrand(void);



char *
mystrdup(char *s);


char *
mystrrchr(char *s, char c);



int
mystricmp(char *s1, char *s2);



void *getcore(int nbytes);


int log_base2(int n);


char *elapsed_time(long sec);






unsigned int
extractl(int word,
         int pos,
         int num);
# 289 "misc.h"
char *myvsprintf(char *obuf, char *format, va_list v);


char *mysprintf(char *obuf, char *format, ...);


void myvfprintf(FILE *stream, char *format, va_list v);


void myfprintf(FILE *stream, char *format, ...);




sqword_t myatosq(char *nptr, char **endp, int base);


qword_t myatoq(char *nptr, char **endp, int base);





FILE *gzopen(char *fname, char *type);


void gzclose(FILE *fd);


word_t crc(word_t crc_accum, word_t data);
# 13 "headers.h" 2
# 1 "machine.h" 1







# 1 "config.h" 1
# 9 "machine.h" 2
# 1 "endian.h" 1
# 100 "endian.h"
# 1 "smt.h" 1
# 101 "endian.h" 2
# 123 "endian.h"
enum endian_t { endian_big=0, endian_little=1, endian_unknown=2};

enum endian_t
endian_host_byte_order(void);


enum endian_t
endian_host_word_order(void);






enum endian_t
endian_target_byte_order(int threadid);



enum endian_t
endian_target_word_order(int thredid);
# 10 "machine.h" 2
# 1 "target-risc/syscall.h" 1
# 359 "target-risc/syscall.h"
extern int barrier_waiting[64];
# 11 "machine.h" 2




# 1 "smt.h" 1
# 16 "machine.h" 2
# 49 "machine.h"
typedef word_t md_addr_t;
# 66 "machine.h"
enum md_fault_type {
  md_fault_none = 0,
  md_fault_access,
  md_fault_alignment,
  md_fault_overflow,
  md_fault_div0,
  md_fault_break,
  md_fault_unimpl,
  md_fault_internal
};
# 96 "machine.h"
typedef sword_t md_gpr_t[32];


typedef union {
  sword_t l[32];
  sfloat_t f[32];
  dfloat_t d[32/2];
} md_fpr_t;


typedef struct {
  sword_t hi, lo;
  int fcc;
} md_ctrl_t;


enum md_reg_names {
  MD_REG_ZERO = 0,
  MD_REG_FUNCRADD = 25,
  MD_REG_GP = 28,
  MD_REG_SP = 29,
  MD_REG_FP = 30,

  MD_REG_V0 = 2,

  MD_REG_A0 = 4,
  MD_REG_A1 = 5,
  MD_REG_A2 = 6,
  MD_REG_A3 = 7,
  MD_REG_A4 = 8,
  MD_REG_A5 = 9,
  MD_REG_RA = 31
};







typedef word_t md_inst_t;


extern md_inst_t MD_NOP_INST;
# 199 "machine.h"
enum md_opcode {
  OP_NA = 0,



# 1 "machine.def" 1
SPECIAL_LINK,

REGIMM_LINK,
# 12 "machine.def"
JUMP,
# 26 "machine.def"
JAL,
# 41 "machine.def"
BEQ,
# 57 "machine.def"
BNE,
# 73 "machine.def"
BLEZ,
# 89 "machine.def"
BGTZ,
# 101 "machine.def"
ADDI,
# 110 "machine.def"
ADDIU,
# 122 "machine.def"
SLTI,
# 134 "machine.def"
SLTIU,
# 143 "machine.def"
ANDI,
# 152 "machine.def"
ORI,
# 161 "machine.def"
XORI,
# 170 "machine.def"
LUI,




COP0_LINK,

COP1_LINK,

COP2_LINK,

SPECIAL2_LINK,
# 193 "machine.def"
LB,
# 208 "machine.def"
LH,
# 249 "machine.def"
LWL,
# 265 "machine.def"
LW,
# 289 "machine.def"
LL,
# 307 "machine.def"
LBU,
# 322 "machine.def"
LHU,
# 362 "machine.def"
LWR,
# 377 "machine.def"
SB,
# 392 "machine.def"
SH,
# 432 "machine.def"
SWL,
# 447 "machine.def"
SW,
# 501 "machine.def"
SC,
# 547 "machine.def"
SWR,
# 568 "machine.def"
LWC1,
# 591 "machine.def"
LDC1,
# 606 "machine.def"
SWC1,
# 639 "machine.def"
SDC1,











SLL,




MOVCI_LINK,
# 681 "machine.def"
SRL,
# 713 "machine.def"
SRA,
# 722 "machine.def"
SLLV,
# 751 "machine.def"
SRLV,
# 784 "machine.def"
SRAV,
# 799 "machine.def"
JR,
# 816 "machine.def"
JALR,
# 826 "machine.def"
MOVZ,
# 836 "machine.def"
MOVN,
# 845 "machine.def"
SYSCALL,
# 857 "machine.def"
BREAK,
# 868 "machine.def"
MFHI,
# 877 "machine.def"
MTHI,
# 886 "machine.def"
MFLO,
# 895 "machine.def"
MTLO,
# 957 "machine.def"
MULT,
# 989 "machine.def"
MULTU,
# 1003 "machine.def"
DIV,
# 1015 "machine.def"
DIVU,
# 1027 "machine.def"
ADD,
# 1036 "machine.def"
ADDU,
# 1048 "machine.def"
SUB,
# 1057 "machine.def"
SUBU,
# 1066 "machine.def"
AND,
# 1075 "machine.def"
OR,
# 1084 "machine.def"
XOR,
# 1093 "machine.def"
NOR,
# 1105 "machine.def"
SLT,
# 1117 "machine.def"
SLTU,
# 1137 "machine.def"
TEQ,








# 1159 "machine.def"
MOVF,
# 1176 "machine.def"
MOVT,






# 1195 "machine.def"
BLTZ,
# 1211 "machine.def"
BGEZ,
# 1228 "machine.def"
BLTZAL,
# 1245 "machine.def"
BGEZAL,











MFC0,
# 1266 "machine.def"
MTC0,











MFC1,
# 1287 "machine.def"
CFC1,
# 1296 "machine.def"
MTC1,
# 1305 "machine.def"
CTC1,




COP1_BC_LINK,

COP1_S_LINK,

COP1_D_LINK,

COP1_W_LINK,


# 1330 "machine.def"
BC1F,
# 1345 "machine.def"
BC1T,





# 1359 "machine.def"
FADD_S,
# 1371 "machine.def"
FSUB_S,
# 1383 "machine.def"
FMUL_S,
# 1395 "machine.def"
FDIV_S,
# 1407 "machine.def"
FSQRT_S,
# 1419 "machine.def"
FABS_S,
# 1431 "machine.def"
FMOV_S,
# 1443 "machine.def"
FNEG_S,
# 1452 "machine.def"
TRUNC_S,




COP1_MOVCF_S_LINK,
# 1468 "machine.def"
FMOVZ_S,
# 1481 "machine.def"
FMOVN_S,
# 1493 "machine.def"
CVT_D_S,
# 1505 "machine.def"
CVT_W_S,
# 1517 "machine.def"
C_EQ_S,
# 1529 "machine.def"
C_LT_S,
# 1541 "machine.def"
C_LE_S,











MOVF_S,
# 1563 "machine.def"
MOVT_S,





# 1577 "machine.def"
FADD_D,
# 1589 "machine.def"
FSUB_D,
# 1601 "machine.def"
FMUL_D,
# 1613 "machine.def"
FDIV_D,
# 1625 "machine.def"
FSQRT_D,
# 1637 "machine.def"
FABS_D,
# 1649 "machine.def"
FMOV_D,
# 1661 "machine.def"
FNEG_D,




COP1_MOVCF_D_LINK,
# 1676 "machine.def"
FMOVZ_D,
# 1689 "machine.def"
FMOVN_D,
# 1698 "machine.def"
TRUNC_D,
# 1712 "machine.def"
CVT_S_D,
# 1724 "machine.def"
CVT_W_D,
# 1736 "machine.def"
C_EQ_D,
# 1748 "machine.def"
C_LT_D,
# 1760 "machine.def"
C_LE_D,











MOVF_D,
# 1782 "machine.def"
MOVT_D,





# 1796 "machine.def"
CVT_S_W,
# 1808 "machine.def"
CVT_D_W,





# 1877 "machine.def"
MADD,
# 1886 "machine.def"
MUL,
# 205 "machine.h" 2
  OP_MAX
};
extern enum md_opcode md_mask2op[];
extern unsigned int md_opoffset[];
extern unsigned int md_opmask[];
extern unsigned int md_opshift[];






extern char *md_op2name[];



extern char *md_op2format[];


enum md_fu_class {
  FUClass_NA = 0,
  IntALU,
  IntMULT,
  IntDIV,
  FloatADD,
  FloatCMP,
  FloatCVT,
  FloatMULT,
  FloatDIV,
  FloatSQRT,
  RdPort,
  WrPort,
  NUM_FU_CLASSES
};



extern enum md_fu_class md_op2fu[];



extern char *md_fu2name[];
# 271 "machine.h"
extern unsigned int md_op2flags[];
# 363 "machine.h"
extern word_t md_lr_masks[];
# 417 "machine.h"
enum md_amode_type {
  md_amode_imm,
  md_amode_gp,
  md_amode_sp,
  md_amode_fp,
  md_amode_disp,
  md_amode_rr,
  md_amode_NUM
};
extern char *md_amode_str[md_amode_NUM];
# 532 "machine.h"
typedef qword_t exo_address_t;


typedef qword_t exo_integer_t;


typedef double exo_float_t;
# 565 "machine.h"
enum md_reg_type {
  rt_gpr,
  rt_lpr,
  rt_fpr,
  rt_dpr,
  rt_ctrl,
  rt_PC,
  rt_NPC,
  rt_NUM
};


struct md_reg_names_t {
  char *str;
  enum md_reg_type file;
  int reg;
};


extern struct md_reg_names_t md_reg_names[];


char *md_reg_name(enum md_reg_type rt, int reg);


struct eval_value_t;
struct regs_t;
char *
md_reg_obj(struct regs_t *regs,
    int is_write,
    enum md_reg_type rt,
    int reg,
    struct eval_value_t *val);


void md_print_ireg(md_gpr_t regs, int reg, FILE *stream);
void md_print_iregs(md_gpr_t regs, FILE *stream);


void md_print_fpreg(md_fpr_t regs, int reg, FILE *stream);
void md_print_fpregs(md_fpr_t regs, FILE *stream);


void md_print_creg(md_ctrl_t regs, int reg, FILE *stream);
void md_print_cregs(md_ctrl_t regs, FILE *stream);


word_t md_crc_regs(struct regs_t *regs);


word_t md_xor_regs(struct regs_t *regs);
# 649 "machine.h"
void md_init_decoder(void);


void
md_print_insn(md_inst_t inst,
       md_addr_t pc,
       FILE *stream);
# 14 "headers.h" 2
# 1 "regs.h" 1
# 102 "regs.h"
# 1 "machine.h" 1
# 103 "regs.h" 2
# 144 "regs.h"
 struct common_regs_t {
  int regs_lock;
  md_addr_t address;
  int subscribe_value;
  int subscribed;
 };

struct common_regs_t common_regs_s[4][64];

struct regs_t {

  int threadid;

  md_gpr_t regs_R;
  md_fpr_t regs_F;
  md_ctrl_t regs_C;
  md_addr_t regs_PC;
  md_addr_t regs_NPC;
};


struct regs_t *regs_create(void);


void
regs_init(struct regs_t *regs);


void
regs_dump(struct regs_t *regs,
   FILE *stream);


void
regs_destroy(struct regs_t *regs);
# 15 "headers.h" 2
# 1 "memory.h" 1
# 110 "memory.h"
# 1 "machine.h" 1
# 111 "memory.h" 2
# 1 "options.h" 1
# 97 "options.h"
enum opt_class_t {
  oc_int = 0,
  oc_uint,
  oc_float,
  oc_double,
  oc_enum,
  oc_flag,
  oc_string,
  oc_NUM
};


struct opt_opt_t {
  struct opt_opt_t *next;
  char *name;
  char *desc;
  int nvars;
  int *nelt;
  char *format;
  int print;
  int accrue;
  enum opt_class_t oc;
  union opt_variant_t {

    struct opt_for_int_t {
      int *var;
    } for_int;

    struct opt_for_uint_t {
      unsigned int *var;
    } for_uint;

    struct opt_for_float_t {
      float *var;
    } for_float;

    struct opt_for_double_t {
      double *var;
    } for_double;

    struct opt_for_enum_t {
      int *var;
      char **emap;
      int *eval;
      int emap_sz;
    } for_enum;

    struct opt_for_string_t {
      char **var;
    } for_string;
  } variant;
};



typedef int
(*orphan_fn_t)(int i,
        int argc,
        char **argv);



struct opt_note_t {
  struct opt_note_t *next;
  char *note;
};


struct opt_odb_t {
  struct opt_opt_t *options;
  orphan_fn_t orphan_fn;
  char *header;
  struct opt_note_t *notes;
};


struct opt_odb_t *
opt_new(orphan_fn_t orphan_fn);


void
opt_delete(struct opt_odb_t *odb);


void
opt_reg_int(struct opt_odb_t *odb,
     char *name,
     char *desc,
     int *var,
     int def_val,
     int print,
     char *format);


void
opt_reg_int_list(struct opt_odb_t *odb,
   char *name,
   char *desc,
   int *vars,
   int nvars,
   int *nelt,
   int *def_val,
   int print,
   char *format,
   int accrue);


void
opt_reg_uint(struct opt_odb_t *odb,
      char *name,
      char *desc,
      unsigned int *var,
      unsigned int def_val,
      int print,
      char *format);


void
opt_reg_uint_list(struct opt_odb_t *odb,
    char *name,
    char *desc,
    unsigned int *vars,
    int nvars,
    int *nelt,
    unsigned int *def_val,
    int print,
    char *format,
    int accrue);


void
opt_reg_float(struct opt_odb_t *odb,
       char *name,
       char *desc,
       float *var,
       float def_val,
       int print,
       char *format);


void
opt_reg_float_list(struct opt_odb_t *odb,
     char *name,
     char *desc,
     float *vars,
     int nvars,
     int *nelt,
     float *def_val,
     int print,
     char *format,
     int accrue);


void
opt_reg_double(struct opt_odb_t *odb,
        char *name,
        char *desc,
        double *var,
        double def_val,
        int print,
        char *format);


void
opt_reg_double_list(struct opt_odb_t *odb,
      char *name,
      char *desc,
      double *vars,
      int nvars,
      int *nelt,
      double *def_val,
      int print,
      char *format,
      int accrue);




void
opt_reg_enum(struct opt_odb_t *odb,
      char *name,
      char *desc,
      int *var,
      char *def_val,
      char **emap,
      int *eval,
      int emap_sz,
      int print,
      char *format);




void
opt_reg_enum_list(struct opt_odb_t *odb,
    char *name,
    char *desc,
    int *vars,
    int nvars,
    int *nelt,
    char *def_val,
    char **emap,
    int *eval,
    int emap_sz,
    int print,
    char *format,
    int accrue);


void
opt_reg_flag(struct opt_odb_t *odb,
      char *name,
      char *desc,
      int *var,
      int def_val,
      int print,
      char *format);


void
opt_reg_flag_list(struct opt_odb_t *odb,
    char *name,
    char *desc,
    int *vars,
    int nvars,
    int *nelt,
    int *def_val,
    int print,
    char *format,
    int accrue);


void
opt_reg_string(struct opt_odb_t *odb,
        char *name,
        char *desc,
        char **var,
        char *def_val,
        int print,
        char *format);


void
opt_reg_string_list(struct opt_odb_t *odb,
      char *name,
      char *desc,
      char **vars,
      int nvars,
      int *nelt,
      char **def_val,
      int print,
      char *format,
      int accrue);


void
opt_process_options(struct opt_odb_t *odb,
      int argc,
      char **argv);


void
opt_print_option(struct opt_opt_t *opt,
   FILE *fd);


void
opt_print_options(struct opt_odb_t *odb,
    FILE *fd,
    int terse,
    int notes);


void
opt_print_help(struct opt_odb_t *odb,
        FILE *fd);


struct opt_opt_t *
opt_find_option(struct opt_odb_t *odb,
  char *opt_name);


void
opt_reg_header(struct opt_odb_t *odb,
        char *header);


void
opt_reg_note(struct opt_odb_t *odb,
      char *note);
# 112 "memory.h" 2
# 1 "stats.h" 1
# 98 "stats.h"
# 1 "machine.h" 1
# 99 "stats.h" 2
# 1 "eval.h" 1
# 100 "eval.h"
# 1 "machine.h" 1
# 101 "eval.h" 2


struct eval_state_t;
struct eval_value_t;




typedef struct eval_value_t
(*eval_ident_t)(struct eval_state_t *es);


enum eval_token_t {
  tok_ident,
  tok_const,
  tok_plus,
  tok_minus,
  tok_mult,
  tok_div,
  tok_oparen,
  tok_cparen,
  tok_eof,
  tok_whitespace,
  tok_invalid
};


struct eval_state_t {
  char *p;
  char *lastp;
  eval_ident_t f_eval_ident;
  void *user_ptr;
  char tok_buf[512];
  enum eval_token_t peek_tok;
};


enum eval_err_t {
  ERR_NOERR,
  ERR_UPAREN,
  ERR_NOTERM,
  ERR_DIV0,
  ERR_BADCONST,
  ERR_BADEXPR,
  ERR_UNDEFVAR,
  ERR_EXTRA,
  ERR_NUM
};



extern char * eval_err_extra_info;


extern enum eval_err_t eval_error ;


extern char *eval_err_str[ERR_NUM];


enum eval_type_t {
  et_int,
  et_uint,
  et_addr,

  et_qword,
  et_sqword,

  et_float,
  et_double,
  et_symbol,
  et_NUM
};
# 186 "eval.h"
extern char *eval_type_str[et_NUM];


struct eval_value_t {
  enum eval_type_t type;
  union {
    int as_int;
    unsigned int as_uint;
    md_addr_t as_addr;

    qword_t as_qword;
    sqword_t as_sqword;

    float as_float;
    double as_double;
    char *as_symbol;
  } value;
};






double eval_as_double(struct eval_value_t val);


float eval_as_float(struct eval_value_t val);



qword_t eval_as_qword(struct eval_value_t val);


sqword_t eval_as_sqword(struct eval_value_t val);



md_addr_t eval_as_addr(struct eval_value_t val);


unsigned int eval_as_uint(struct eval_value_t val);


int eval_as_int(struct eval_value_t val);


struct eval_state_t *
eval_new(eval_ident_t f_eval_ident,
  void *user_ptr);


void
eval_delete(struct eval_state_t *es);



struct eval_value_t
eval_expr(struct eval_state_t *es,
   char *p,
   char **endp);


void
eval_print(FILE *stream,
    struct eval_value_t val);
# 100 "stats.h" 2
# 113 "stats.h"
enum stat_class_t {
  sc_int = 0,
  sc_uint,

  sc_qword,
  sc_sqword,

  sc_float,
  sc_double,
  sc_dist,
  sc_sdist,
  sc_formula,
  sc_NUM
};






struct bucket_t {
  struct bucket_t *next;
  md_addr_t index;
  unsigned int count;
};


struct stat_stat_t;
# 151 "stats.h"
typedef void
(*print_fn_t)(struct stat_stat_t *stat,
       md_addr_t index,
       int count,
       double sum,
       double total);


struct stat_stat_t {
  struct stat_stat_t *next;
  char *name;
  char *desc;
  char *format;
  enum stat_class_t sc;
  union stat_variant_t {

    struct stat_for_int_t {
      int *var;
      int init_val;
    } for_int;

    struct stat_for_uint_t {
      unsigned int *var;
      unsigned int init_val;
    } for_uint;


    struct stat_for_qword_t {
      qword_t *var;
      qword_t init_val;
    } for_qword;

    struct stat_for_sqword_t {
      sqword_t *var;
      sqword_t init_val;
    } for_sqword;


    struct stat_for_float_t {
      float *var;
      float init_val;
    } for_float;

    struct stat_for_double_t {
      double *var;
      double init_val;
    } for_double;

    struct stat_for_dist_t {
      unsigned int init_val;
      unsigned int *arr;
      unsigned int arr_sz;
      unsigned int bucket_sz;
      int pf;
      char **imap;
      print_fn_t print_fn;
      unsigned int overflows;
    } for_dist;

    struct stat_for_sdist_t {
      unsigned int init_val;
      struct bucket_t **sarr;
      int pf;
      print_fn_t print_fn;
    } for_sdist;

    struct stat_for_formula_t {
      char *formula;
    } for_formula;
  } variant;
};


struct stat_sdb_t {
  struct stat_stat_t *stats;
  struct eval_state_t *evaluator;
};


struct eval_value_t
stat_eval_ident(struct eval_state_t *es);


struct stat_sdb_t *stat_new(void);


void
stat_delete(struct stat_sdb_t *sdb);


struct stat_stat_t *
stat_reg_int(struct stat_sdb_t *sdb,
      char *name,
      char *desc,
      int *var,
      int init_val,
      char *format);


struct stat_stat_t *
stat_reg_uint(struct stat_sdb_t *sdb,
       char *name,
       char *desc,
       unsigned int *var,
       unsigned int init_val,
       char *format);



struct stat_stat_t *
stat_reg_qword(struct stat_sdb_t *sdb,
        char *name,
        char *desc,
        qword_t *var,
        qword_t init_val,
        char *format);


struct stat_stat_t *
stat_reg_sqword(struct stat_sdb_t *sdb,
  char *name,
  char *desc,
  sqword_t *var,
  sqword_t init_val,
  char *format);



struct stat_stat_t *
stat_reg_float(struct stat_sdb_t *sdb,
        char *name,
        char *desc,
        float *var,
        float init_val,
        char *format);


struct stat_stat_t *
stat_reg_double(struct stat_sdb_t *sdb,
  char *name,
  char *desc,
  double *var,
  double init_val,
  char *format);







struct stat_stat_t *
stat_reg_dist(struct stat_sdb_t *sdb,
       char *name,
       char *desc,
       unsigned int init_val,
       unsigned int arr_sz,
       unsigned int bucket_sz,
       int pf,
       char *format,
       char **imap,
       print_fn_t print_fn);
# 321 "stats.h"
struct stat_stat_t *
stat_reg_sdist(struct stat_sdb_t *sdb,
        char *name,
        char *desc,
        unsigned int init_val,
        int pf,
        char *format,
        print_fn_t print_fn);


void
stat_add_samples(struct stat_stat_t *stat,
   md_addr_t index,
   int nsamples);


void
stat_add_sample(struct stat_stat_t *stat,
  md_addr_t index);
# 348 "stats.h"
struct stat_stat_t *
stat_reg_formula(struct stat_sdb_t *sdb,
   char *name,
   char *desc,
   char *formula,
   char *format);


void
stat_print_stat(struct stat_sdb_t *sdb,
  struct stat_stat_t *stat,
  FILE *fd);


void
stat_print_stats(struct stat_sdb_t *sdb,
   FILE *fd);



struct stat_stat_t *
stat_find_stat(struct stat_sdb_t *sdb,
        char *stat_name);
# 113 "memory.h" 2



# 1 "smt.h" 1
# 117 "memory.h" 2
# 1 "MTA.h" 1
# 12 "MTA.h"
extern void StartSkeletonRead (int type);
extern int GetExecStatus (md_addr_t pc, md_addr_t *bPt);
# 50 "MTA.h"
struct quiesceStruct {
    md_addr_t address;
    int threadid;
};
# 118 "memory.h" 2
# 127 "memory.h"
struct mem_pte_t {
  struct mem_pte_t *next;
  md_addr_t tag;
  byte_t *page;
};


struct mem_t {


  int threadid;

  char *name;
  struct mem_pte_t *ptab[(32*1024)];


  counter_t page_count;
  counter_t ptab_misses;
  counter_t ptab_accesses;
};


enum mem_cmd {
  Read,
  Write

};



typedef enum md_fault_type
(*mem_access_fn)(struct mem_t *mem,
   enum mem_cmd cmd,
   md_addr_t addr,
   void *p,
   int nbytes, int threadID);
# 393 "memory.h"
struct mem_t *
mem_create(char *name);


byte_t *
mem_translate(struct mem_t *mem,
       md_addr_t addr);


void
mem_newpage(struct mem_t *mem,
     md_addr_t addr);




enum md_fault_type
mem_access(struct mem_t *mem,
    enum mem_cmd cmd,
    md_addr_t addr,
    void *vp,
    int nbytes, int threadID);


void
mem_reg_stats(struct mem_t *mem,
       struct stat_sdb_t *sdb);


void
mem_init(struct mem_t *mem);


enum md_fault_type
mem_dump(struct mem_t *mem,
  md_addr_t addr,
  int len,
  FILE *stream);
# 443 "memory.h"
enum md_fault_type
mem_strcpy(mem_access_fn mem_fn,
    struct mem_t *mem,
    enum mem_cmd cmd,
    md_addr_t addr,
    char *s, int threadID);


enum md_fault_type
mem_bcopy(mem_access_fn mem_fn,
   struct mem_t *mem,
   enum mem_cmd cmd,
   md_addr_t addr,
   void *vp,
   int nbytes, int threadID);




enum md_fault_type
mem_bcopy4(mem_access_fn mem_fn,
    struct mem_t *mem,
    enum mem_cmd cmd,
    md_addr_t addr,
    void *vp,
    int nbytes, int threadID);


enum md_fault_type
mem_bzero(mem_access_fn mem_fn,
   struct mem_t *mem,
   md_addr_t addr,
   int nbytes, int threadID);
# 16 "headers.h" 2
# 1 "cache.h" 1
# 131 "cache.h"
# 1 "machine.h" 1
# 132 "cache.h" 2



# 1 "smt.h" 1
# 136 "cache.h" 2
# 1 "interconnect.h" 1
# 114 "interconnect.h"
enum comm_use_type_enum {sendregister, l2comm, flood, bare_token, data_token, other};
extern char * comm_use_type_enum_names[];
# 186 "interconnect.h"
extern int master_link_width[8];
extern int master_hop_time[8];
extern char *IC_index2string[8];
enum link_physics_enum {none, electrical, optical};
typedef struct link_info_t_st
{
    char * type;
    char * longname;
    enum link_physics_enum physics;
} link_info_t;
extern link_info_t link_info[8];


extern int fe_link_time;
extern int total_noncongested_comm_delay[64][64];
# 235 "interconnect.h"
extern int master_qram_access_cl[8][64];
extern int master_link_rx_access_cl[8][64];
extern int master_link_tx_access_cl[8][64];

extern int master_link_tx_use_type_access[8][6];


extern counter_t *master_link_width_dist[8];
# 262 "interconnect.h"
extern counter_t total_master_qram_access[8]; counter_t max_master_qram_access[8]; double master_qram_power[8]; double master_qram_power_cc1[8][64 +1]; double master_qram_power_cc2[8][64 +1]; double master_qram_power_cc3[8][64 +1];
extern counter_t total_master_link_rx_access[8]; counter_t max_master_link_rx_access[8]; double master_link_rx_power[8]; double master_link_rx_power_cc1[8][64 +1]; double master_link_rx_power_cc2[8][64 +1]; double master_link_rx_power_cc3[8][64 +1];
extern counter_t total_master_link_tx_access[8]; counter_t max_master_link_tx_access[8]; double master_link_tx_power[8]; double master_link_tx_power_cc1[8][64 +1]; double master_link_tx_power_cc2[8][64 +1]; double master_link_tx_power_cc3[8][64 +1];
# 275 "interconnect.h"
void init_routing_table(void);
void interconnect_init(void);
void interconnect_free(void);
void clear_interconnect_access_stats(void);
void total_interconnect_power_stats(void);
void total_interconnect_access_stats(void);
void arbitrary_routing_table_init(void);
void init_link_descr_tables(void);
int cl_comm_lat(int from, int to, int offset, unsigned int bytesize, enum comm_use_type_enum use_type);

int ring_lat_typed(int from, int to, int myreg, int offset, enum comm_use_type_enum use_type);

int ring_lat(int from, int to, int myreg, int offset);

void flood_lat(counter_t * results, int from, counter_t sendtime);
# 137 "cache.h" 2
# 1 "sim-outorder.h" 1
# 20 "sim-outorder.h"
typedef struct m_L1WBufEntry
{
    md_addr_t PC;
    md_inst_t IR;
    int lsqId;
    int robId;
    int robExId;
    md_addr_t addr;
    enum md_opcode op;
    counter_t lat;
    counter_t sim_num_insn;
    int commitDone, writeStarted;
 int isMiss;
    counter_t finishTime, entryTime;
    quad_t writeValue;
 int STL_C_fail;
 int already_check;







}m_L1WBufEntry;

m_L1WBufEntry m_L1WBuf[64][8];



 int m_L1WBuf_head[64];
 int m_L1WBuf_tail[64];

 int MarkWriteCommit(int threadid, struct RUU_station *rs);

 int m_L1WBufCnt[64];
# 138 "cache.h" 2
# 197 "cache.h"
void OrderBufRemove(int s1, int s2, int d1, int d2, md_addr_t addr, counter_t msgno);
void OrderBufInsert(int s1, int s2, int d1, int d2, md_addr_t addr, int vc, counter_t msgno);
# 218 "cache.h"
counter_t pending_invalidation[64];
counter_t pending_invalid_start_cycles[64];
counter_t pending_invalid_cycles;


int data_packet_size;
int meta_packet_size;
# 243 "cache.h"
struct mshr_entry_t
{
 int id;
 int isValid;
 md_addr_t addr;
 counter_t startCycle;
 counter_t endCycle;
 int blocknum;
 int isOC;
 struct RUU_station *rs;
 struct DIRECTORY_EVENT *event;
};

struct mshr_t
{
 int threadid;
 struct mshr_entry_t mshrEntry[48];
 int freeEntries;
 int freeOCEntries;
 int mshrSIZE;
};

md_addr_t wb_buffer[64][32];
void initMSHR(struct mshr_t *mshr, int flag);
void freeMSHR(struct mshr_t *mshr);
int isMSHRFull(struct mshr_t *mshr, int isOC, int threadid);
void MSHRLookup(struct mshr_t *mshr, md_addr_t addr, int lat, int isOC, struct RUU_station *rs);
# 303 "cache.h"
struct miss_history_table_t
{
 md_addr_t history[16];
 int mht_tail;
 int mht_num;
};

struct stream_table_entry_t
{
 int valid;
 md_addr_t addr;
 int stride;
 int remaining_prefetches;
 counter_t last_use;
};

struct miss_history_table_t miss_history_table;
struct stream_table_entry_t stream_table[8];

void init_sp();
void insert_sp(md_addr_t addr, int threadid);
void launch_sp(int id, int threadid);


struct miss_history_table_t l1miss_history_table[64];
struct stream_table_entry_t l1stream_table[64][8];

void l1init_sp();
void l1insert_sp(md_addr_t addr, int threadid);
void l1launch_sp(md_addr_t addr, int threadid);
# 344 "cache.h"
struct bs_nd
{
 long long int startTime, endTime;
 int accessType, threadid;
 struct bs_nd *next;
};
# 396 "cache.h"
enum cache_policy {
 LRU,
 Random,
 FIFO
};
# 500 "cache.h"
struct tag_id_t
{
 int threadid;
 md_addr_t tag;
};
# 523 "cache.h"
struct cache_blk_t
{
 struct cache_blk_t *way_next;

 struct cache_blk_t *way_prev;
 struct cache_blk_t *hash_next;




 struct tag_id_t tagid;



 unsigned int status;
 tick_t ready;


 unsigned int state;
 int isStale;
 md_addr_t addr;

 int lastThrd;
 unsigned int value;
 int lineVolatile;
 int wordVolatile, wordInvalid;
 int epochModified;
 int isL1prefetch;
 counter_t prefetch_time;






 unsigned int dir_state[8];
 unsigned long long int dir_sharer[8][8];
 counter_t exclusive_time[8];
 int dir_dirty[8];
 int dir_blk_state[8];
 int ever_wb;



 int spTag;

 int ever_dirty;
 int ever_touch;
 int Iswb_to_mem;
 int ReadCount;
 int WriteCount;
 int WordCount;
 int Type;
 int WordUseFlag[8];
 struct DIRECTORY_EVENT *ptr_cur_event[8];
# 586 "cache.h"
 int blkAlocReason;
 int blkImdtOp;
 int blkNextOps;

 byte_t *user_data;




 byte_t data[1];


 long long int lastModified, lastAccessed;
 int modifiedThisEpoch;
 int modifiedByMe;
 int invCause;
};


struct cache_set_t
{
 struct cache_blk_t **hash;

 struct cache_blk_t *way_head;
 struct cache_blk_t *way_tail;
 struct cache_blk_t *blks;


};


struct cache_t
{

 char *name;
 int nsets;
 int bsize;
 int balloc;
 int usize;
 int assoc;
 enum cache_policy policy;
 unsigned int hit_latency;
# 638 "cache.h"
 unsigned int
  (*blk_access_fn)(enum mem_cmd cmd,
       md_addr_t baddr,
       int bsize,
       struct cache_blk_t *blk,

       tick_t now,
       int threadid



      );





 int hsize;
 md_addr_t blk_mask;
 int set_shift;
 md_addr_t set_mask;
 int tag_shift;
 md_addr_t tag_mask;
 md_addr_t tagset_mask;


 tick_t bus_free;
# 674 "cache.h"
 counter_t hits;
 counter_t dhits;
 counter_t misses;
 counter_t dmisses;
 counter_t coherence_misses;
 counter_t capacitance_misses;
 counter_t replacements;
 counter_t replInv;
 counter_t writebacks;
 counter_t wb_coherence_w;
 counter_t wb_coherence_r;
 counter_t invalidations;
 counter_t coherencyMisses;
 counter_t coherencyMissesOC;


 counter_t in_mshr;
 counter_t din_mshr;
 counter_t dir_notification;
 counter_t Invalid_Read_received;
 counter_t Invalid_write_received;
 counter_t Invalid_Read_received_hits;
 counter_t Invalid_write_received_hits;
 counter_t e_to_i;
 counter_t e_to_m;
 counter_t s_to_i;

 counter_t ack_received;
 counter_t L2_access;
 counter_t dir_access;
 counter_t data_access;
 counter_t localdirectory;
 counter_t remotedirectory;
 counter_t sendInvalid, invalidDone, wasInvalidated;

 counter_t flushCount, lineFlushCount;


 int rdb;
 int wrb;
 int pipedelay;
 int wrbufsize;
 long lastuse;







 struct tag_id_t last_tagsetid;



 struct cache_blk_t *last_blk;


 struct mshr_t *mshr;



 byte_t *data;

 counter_t numDiffThrds;



 int lastInvalidate;
 long Invld;


 long long int intraThrdConflict;
 long long int interThrdConflict;
 long long int ConsecutiveAccess;


 long long int ccLocalLoadS;
 long long int ccLocalLoadX;
 long long int ccLocalLoadM;
 long long int ccLocalStoreS;
 long long int ccLocalStoreX;
 long long int ccLocalStoreM;
 long long int ccRemoteLoadS;
 long long int ccRemoteLoadX;
 long long int ccRemoteLoadM;
 long long int ccRemoteStoreS;
 long long int ccRemoteStoreX;
 long long int ccRemoteStoreM;


 long long int SRLocalLoadS;
 long long int SRLocalLoadX;
 long long int SRLocalLoadM;
 long long int SRLocalStoreS;
 long long int SRLocalStoreX;
 long long int SRLocalStoreM;
 long long int SRRemoteLoadS;
 long long int SRRemoteLoadX;
 long long int SRRemoteLoadM;
 long long int SRRemoteStoreS;
 long long int SRRemoteStoreX;
 long long int SRRemoteStoreM;

 long long int glLocalHit;
 long long int glRemoteHit;

 long long int NumAccesses;

 int threadid;



 struct cache_set_t sets[1];
};


struct cache_t *
cache_create(char *name,
  int nsets,
  int bsize,
  int balloc,
  int usize,
  int assoc,
  enum cache_policy policy,

  unsigned int (*blk_access_fn)(enum mem_cmd cmd,
   md_addr_t baddr, int bsize,
   struct cache_blk_t *blk,

   tick_t now,

   int threadid



   ),



 unsigned int hit_latency,
 int threadid);


enum cache_policy
cache_char2policy(char c);


void
cache_config(struct cache_t *cp,
  FILE *stream);


void cache_reg_stats(struct cache_t *cp, struct stat_sdb_t *sdb, int id);




void
cache_stats(struct cache_t *cp,
  FILE *stream);
# 872 "cache.h"
void cache_warmup (struct cache_t *cp,
  enum mem_cmd cmd,
  md_addr_t addr,
  int nbytes,
  int threadid);
int isLineInvalidated(md_addr_t addr, int threadid);
# 911 "cache.h"
void markCacheNewEpoch(struct cache_t *cp, int);

void busFree();
void busInit();
void markCacheLine(struct cache_t *, md_addr_t, int);
unsigned int
cache_mark_volatile(struct cache_t *cp,
  md_addr_t addr,
  tick_t now,
  int threadid, int);

unsigned int
cache_flush_volatile(struct cache_t *cp,
  tick_t now,
  int threadid, int );


int check_for_l1_miss(struct cache_t *cp, md_addr_t addr, int threadid);

void updateBlockLat(struct cache_t *cp, md_addr_t addr, int threadid, int lat);

int checkReplacementStatus(int id, md_addr_t addr);




int
cache_probe(struct cache_t *cp,
  md_addr_t addr);


unsigned int
cache_flush(struct cache_t *cp,
  tick_t now);




unsigned int
cache_flush_addr(struct cache_t *cp,
  md_addr_t addr,
  tick_t now,
  int threadid);
# 965 "cache.h"
void cacheBcopy(enum mem_cmd cmd, struct cache_blk_t *blk, int position, byte_t *data, int nbytes);
int L2inclusionFunc(struct cache_t *cp, md_addr_t addr);
int isCacheHit (struct cache_t *cp, md_addr_t addr, int threadid);






struct DIRECTORY_EVENT
{
 enum md_opcode op;
 int isPrefetch;
 int l2Status;
 counter_t l2MissStart;
 struct DIRECTORY_EVENT *next;
 tick_t when;
 tick_t started;
 tick_t mshr_time;
 tick_t transfer_time;
 tick_t req_time;
 int store_cond;
 int flip_flag;







 int input_buffer_full;
 int pending_flag;
 int L2miss_flag;
 int L2miss_stated;
 int L2miss_complete;
 int dirty_flag;
 counter_t arrival_time;
 int delay;
 int data_reply;
 int conf_bit;
 counter_t missNo;
 counter_t totaleventcount;
 int resend;
 unsigned int operation;
 int tempID;
 md_addr_t addr;
 struct cache_blk_t *blk1, *blk_dir;

 struct RS_link *ptr_event;
 struct cache_t *cp;
 void *vp;
 int nbytes;
 byte_t **udata;
 enum mem_cmd cmd;
 enum MC_cmd mc_cmd;
 struct RUU_station *rs;

 struct m_L1WBufEntry *l1_wb_entry;

 long src1, src2, des1, des2, startCycle;
 int new_src1, new_src2, new_des1, new_des2;
 struct DIRECTORY_EVENT *parent;
 int parent_operation;
 int childCount, processingDone, spec_mode, originalChildCount;
 counter_t popnetMsgNo;
 int eventType;
 int rec_busy;
 int sharer_num;
 int individual_childCount[8];
 int prefetch_next;
 int pendingInvAck;
 int isExclusiveOrDirty;
 int l1LineUseStatus;
 int isReqL2Hit;
 int isReqL2SecMiss;
 int isReqL2Inv;
 int isReqL2Trans;
 counter_t reqNetTime;
 counter_t reqAtDirTime;
 counter_t reqAckTime;
 int isSyncAccess;
};



struct DIRECTORY_EVENT *free_event_list;

void allocate_free_event_list();
# 1075 "cache.h"
int dir_fifo_full[2500];

struct DIRECTORY_EVENT *dir_fifo[2500][4096];
int dir_fifo_head[2500];
int dir_fifo_tail[2500];
int dir_fifo_num[2500];
int dir_fifo_portuse[2500];


struct DIRECTORY_EVENT *tshr_fifo[2500][1024];
int tshr_fifo_head[2500];
int tshr_fifo_tail[2500];
int tshr_fifo_num[2500];
int tshr_fifo_portuse[2500];


struct DIRECTORY_EVENT *l1_fifo[2500][4096];
int l1_fifo_head[2500];
int l1_fifo_tail[2500];
int l1_fifo_num[2500];
int l1_fifo_portuse[2500];

void reset_ports();
int dir_fifo_enqueue(struct DIRECTORY_EVENT *event, int type);
void dir_fifo_dequeue();
void sendLSQInv(md_addr_t addr, int threadid);
# 17 "headers.h" 2
# 1 "loader.h" 1
# 100 "loader.h"
# 1 "machine.h" 1
# 101 "loader.h" 2


# 1 "sim.h" 1
# 101 "sim.h"
# 1 "/usr/include/setjmp.h" 1 3 4
# 28 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 31 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/bits/sigset.h" 1 3 4
# 32 "/usr/include/setjmp.h" 2 3 4




typedef struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  } jmp_buf[1];




extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));







extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));




extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 76 "/usr/include/setjmp.h" 3 4




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 108 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



# 102 "sim.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 31 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h" 1 3 4
# 40 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 44 "/usr/include/time.h" 2 3 4
# 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 132 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 181 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));

# 229 "/usr/include/time.h" 3 4



extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
# 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
# 416 "/usr/include/time.h" 3 4

# 103 "sim.h" 2






# 1 "smt.h" 1
# 110 "sim.h" 2


extern int sim_dump_stats;


extern int sim_exit_now;


extern jmp_buf sim_exit_buf;


extern int sim_swap_bytes;
extern int sim_swap_words;


extern counter_t sim_num_insn;
extern FILE *sim_eio_fd;


extern time_t sim_start_time;
extern time_t sim_end_time;
extern int sim_elapsed_time;


extern struct opt_odb_t *sim_odb;


extern struct stat_sdb_t *sim_sdb;
# 147 "sim.h"
extern FILE *sim_progfd;







void sim_reg_options(struct opt_odb_t *odb);




void sim_check_options(struct opt_odb_t *odb, int argc, char **argv);


void sim_reg_stats(struct stat_sdb_t *sdb);


void sim_init(void);



void sim_load_threads(int argc, char **argv, char **envp);



void sim_load_prog(char *fname, int argc, char **argv, char **envp);




void sim_aux_config(FILE *stream);


void sim_main(void);




void sim_aux_stats(FILE *stream);


void sim_uninit(void);


void
sim_print_stats(FILE *fd);
# 104 "loader.h" 2
# 196 "loader.h"
void
ld_reg_stats(struct stat_sdb_t *sdb, int threadid);



void
ld_load_prog(char *fname,
      int argc, char **argv,
      char **envp,
      struct regs_t *regs,
      struct mem_t *mem,
      int zero_bss_segs,
             int threadid);
# 18 "headers.h" 2
# 1 "syscall.h" 1
# 19 "headers.h" 2
# 1 "bpred.h" 1
# 162 "bpred.h"
# 1 "machine.h" 1
# 163 "bpred.h" 2


# 1 "smt.h" 1
# 166 "bpred.h" 2
# 210 "bpred.h"
enum bpred_class {
  BPredComb,
  BPred2Level,
  BPred2bit,



  BPredTaken,
  BPredNotTaken,


  BPredARVI,
  BPredComb2,
  BPred2bcgskew,

  BPred_NUM
};


struct addr_id_t
{
  int threadid;
  md_addr_t addr;
};



struct bpred_btb_ent_t {

  struct addr_id_t addr_id;



  enum md_opcode op;
  md_addr_t target;
  struct bpred_btb_ent_t *prev, *next;
};


struct bpred_dir_t {
  enum bpred_class class;
  union {
    struct {
      unsigned int size;
      unsigned char *table;
    } bimod;
    struct {
      int l1size;
      int l2size;
      int shift_width;
      int xor;

      int *shiftregs[64];



      unsigned char *l2table;
    } two;

 struct {
  unsigned int size;
  unsigned int log_size;

  int shiftreg[64];



  unsigned char *table;
  int shift_width;
 } bank;
  } config;
};


struct bpred_t {
  enum bpred_class class;
  struct {
    struct bpred_dir_t *bimod;
    struct bpred_dir_t *twolev;
    struct bpred_dir_t *meta;


    struct bpred_dir_t *bimod2;
    struct bpred_dir_t *twolev2;
    struct bpred_dir_t *meta2;
 struct bvit_t *b_info_t;


 struct bpred_dir_t *twolev1;
 struct bpred_dir_t *twolev12;


 struct bpred_dir_t *bim1;
 struct bpred_dir_t *g01;
 struct bpred_dir_t *g11;

 struct bpred_dir_t *bim2;
 struct bpred_dir_t *g02;
 struct bpred_dir_t *g12;

  } dirpred;

  struct {
    int sets;
    int assoc;
    struct bpred_btb_ent_t *btb_data;
  } btb;

  struct {
    int size;
    int tos;
    struct bpred_btb_ent_t *stack;

  } retstack[64];





  counter_t addr_hits;
  counter_t dir_hits;
  counter_t used_ras;
  counter_t used_bimod;
  counter_t used_2lev;
  counter_t jr_hits;
  counter_t jr_seen;
  counter_t jr_non_ras_hits;
  counter_t jr_non_ras_seen;
  counter_t misses;

  counter_t lookups;
  counter_t retstack_pops;
  counter_t retstack_pushes;
  counter_t ras_hits;
};


struct bpred_update_t {
  char *pdir1;
  char *pdir2;
  char *pmeta;


  char *pdir12;
  char *pdir22;
  char *pmeta2;


  char *pdir3;
  char *pdir32;

unsigned int pred_taken : 1;
unsigned int pred_taken2 : 1;
unsigned int twolev2_used : 1;

unsigned int hist_shift_out : 1;
unsigned int hist_shift_out2 : 1;
unsigned short hist_tab_indx;

int bucket_index;


unsigned int history;
unsigned int history2;


int branch_tail2;

md_addr_t *stack;

  struct {
    unsigned int ras : 1;
    unsigned int bimod : 1;
    unsigned int twolev : 1;
    unsigned int twolev2 : 1;
    unsigned int twolev1 : 1;
    unsigned int twolev12 : 1;
    unsigned int meta : 1;
    unsigned int meta2 : 1;

    unsigned int bim1 : 1;
    unsigned int g01 : 1;
    unsigned int g11 : 1;
    unsigned int bim2 : 1;
    unsigned int g02 : 1;
    unsigned int g12 : 1;

  } dir;
};


struct bpred_t *
bpred_create(enum bpred_class class,
      unsigned int bimod_size,
      unsigned int l1size,
      unsigned int l2size,
      unsigned int meta_size,
      unsigned int shift_width,
      unsigned int xor,
      unsigned int btb_sets,
      unsigned int btb_assoc,
      unsigned int retstack_size);


struct bpred_t *
bpred_2bcgskew_create( unsigned int bimod_size,
                         unsigned int size,
                                unsigned int shift_width_bimod,
                             unsigned int shift_width_g0,
                             unsigned int shift_width_g1,
                               unsigned int shift_width_meta,
                unsigned int btb_sets,
                 unsigned int btb_assoc,
                           unsigned int ras_size);
# 434 "bpred.h"
void bpred_update_history(struct bpred_t *pred, struct bpred_update_t *dir_update_ptr

  , int threadid

  );



void bpred_update_history1(struct bpred_t *pred, int taken, md_addr_t baddr, struct bpred_update_t *dir_update_ptr

  , int threadid

  );



void bpred_2bcgskew_lookup(struct bpred_t *pred, struct bpred_update_t *dir_update_ptr, md_addr_t baddr, int threadid);
# 460 "bpred.h"
void bpred_2bcgskew_update(struct bpred_t *pred,
         md_addr_t baddr,
   int taken,
   int pred_taken,
   int correct,
   struct bpred_update_t *dir_update_ptr

  , int threadid

     );



void bpred_2bcgskew_update2(struct bpred_t *pred,
         md_addr_t baddr,
   int taken,
   int pred_taken,
   int correct,
   struct bpred_update_t *dir_update_ptr);


struct bpred_dir_t *
bpred_dir_create (
  enum bpred_class class,
  unsigned int l1size,
  unsigned int l2size,
  unsigned int shift_width,
  unsigned int xor);


void
bpred_config(struct bpred_t *pred,
      FILE *stream);


void
bpred_stats(struct bpred_t *pred,
     FILE *stream);


void
bpred_reg_stats(struct bpred_t *pred,
  struct stat_sdb_t *sdb, int threadid);


void bpred_after_priming(struct bpred_t *bpred);
# 514 "bpred.h"
md_addr_t
bpred_lookup(struct bpred_t *pred,
      md_addr_t baddr,
      md_addr_t btarget,
      enum md_opcode op,
      int is_call,
      int is_return,
      struct bpred_update_t *dir_update_ptr,

      int *stack_recover_idx,

             int threadid,
      int btb_threadid
            );
# 537 "bpred.h"
void
bpred_recover(struct bpred_t *pred,
       md_addr_t baddr,

       int stack_recover_idx,

              int threadid);
# 557 "bpred.h"
void
bpred_update(struct bpred_t *pred,
      md_addr_t baddr,
      md_addr_t btarget,
      int taken,
      int pred_taken,
      int correct,
      enum md_opcode op,

      struct bpred_update_t *dir_update_ptr,
             int threadid,
      int btb_threadid
            );
# 20 "headers.h" 2
# 1 "resource.h" 1
# 110 "resource.h"
struct res_desc {
  char *name;
  int quantity;
  int busy;
  int usr_id;
  int duplicate;
  struct res_template {
    int class;


    int oplat;

    int issuelat;


    struct res_desc *master;
  } x[32];
};


struct res_pool {
  char *name;
  int num_resources;
  struct res_desc *resources;

  int nents[32];
  struct res_template *table[32][1024];
};


struct res_pool *res_create_pool(char *name, struct res_desc *pool, int ndesc);







struct res_template *res_get(struct res_pool *pool, int class, int interleaf);


void res_dump(struct res_pool *pool, FILE *stream);
# 21 "headers.h" 2
# 1 "bitmap.h" 1
# 101 "bitmap.h"
typedef unsigned int BITMAP_ENT_TYPE;
typedef unsigned int *BITMAP_PTR_TYPE;
# 22 "headers.h" 2



# 1 "ptrace.h" 1
# 88 "ptrace.h"
# 1 "machine.h" 1
# 89 "ptrace.h" 2
# 1 "range.h" 1
# 90 "range.h"
# 1 "machine.h" 1
# 91 "range.h" 2

enum range_ptype_t {
  pt_addr = 0,
  pt_inst,
  pt_cycle,
  pt_NUM
};
# 107 "range.h"
struct range_pos_t {
  enum range_ptype_t ptype;
  counter_t pos;
};


struct range_range_t {
  struct range_pos_t start;
  struct range_pos_t end;
};


char *
range_parse_pos(char *pstr,
  struct range_pos_t *pos);


void
range_print_pos(struct range_pos_t *pos,
  FILE *stream);


char *
range_parse_range(char *rstr,
    struct range_range_t *range);


void
range_print_range(struct range_range_t *range,
    FILE *stream);


int
range_cmp_pos(struct range_pos_t *pos,
       counter_t val);


int
range_cmp_range(struct range_range_t *range,
  counter_t val);



int
range_cmp_range1(struct range_range_t *range,
   md_addr_t addr,
   counter_t icount,
   counter_t cycle);
# 90 "ptrace.h" 2
# 123 "ptrace.h"
extern FILE *ptrace_outfd;


extern int ptrace_active;


extern struct range_range_t ptrace_range;


extern int ptrace_oneshot;


void
ptrace_open(char *range,
     char *fname);


void
ptrace_close(void);
# 167 "ptrace.h"
void
__ptrace_newinst(unsigned int iseq,
   md_inst_t inst,
   md_addr_t pc,
   md_addr_t addr);


void
__ptrace_newuop(unsigned int iseq,
  char *uop_desc,
  md_addr_t pc,
  md_addr_t addr);


void
__ptrace_endinst(unsigned int iseq);


void
__ptrace_newcycle(tick_t cycle);


void
__ptrace_newstage(unsigned int iseq,
    char *pstage,
    unsigned int pevents);
# 26 "headers.h" 2
# 1 "dlite.h" 1
# 149 "dlite.h"
# 1 "machine.h" 1
# 150 "dlite.h" 2






typedef char *
(*dlite_reg_obj_t)(struct regs_t *regs,
     int is_write,
     enum md_reg_type rt,
     int reg,
     struct eval_value_t *val);



typedef char *
(*dlite_mem_obj_t)(struct mem_t *mem,
     int is_write,
     md_addr_t addr,
     char *p,
     int nbytes);



typedef char *
(*dlite_mstate_obj_t)(FILE *stream,
        char *cmd,
        struct regs_t *regs,
        struct mem_t *mem);


void
dlite_init(dlite_reg_obj_t reg_obj,
    dlite_mem_obj_t mem_obj,
    dlite_mstate_obj_t mstate_obj);






char *
dlite_mem_obj(struct mem_t *mem,
       int is_write,
       md_addr_t addr,
       char *p,
       int nbytes);


char *
dlite_mstate_obj(FILE *stream,
   char *cmd,
   struct regs_t *regs,
   struct mem_t *mem);







extern md_addr_t dlite_fastbreak ;


extern int dlite_active ;


extern int dlite_check ;


int
__check_break(md_addr_t next_PC,
       int access,
       md_addr_t addr,
       counter_t icount,
       counter_t cycle);
# 234 "dlite.h"
void
dlite_main(md_addr_t regs_PC,
    md_addr_t next_PC,
    counter_t cycle,
    struct regs_t *regs,
    struct mem_t *mem);
# 27 "headers.h" 2

# 1 "network.h" 1





# 1 "machine.h" 1
# 7 "network.h" 2

# 1 "smt.h" 1
# 9 "network.h" 2
# 22 "network.h"
char *network_type;
char *inter_cfg;
char *intra_cfg;
int total_chip_num;
int Line_chip_num;
int Column_chip_num;
enum network_class {
 FSOI,
 MESH,
 COMB,
 HYBRID
};

void scheduleThroughNetwork(struct DIRECTORY_EVENT *event, long start, unsigned int type, int vc);
void popnetMessageInsert(long s1, long s2, long d1, long d2, long long int sim_cycle, long size, counter_t msgNo, md_addr_t addr, int operation, int vc);


void EUP_entry_init(int id);
int EUP_entry_replacecheck(int id, md_addr_t addr);
int EUP_entry_check(int id, md_addr_t addr);
void EUP_entry_allocate(int id, md_addr_t addr);
void EUP_entry_dellocate(int id, md_addr_t addr);
int EarlyUpgrade(struct DIRECTORY_EVENT *event);
int EarlyUpgrateGenerate(struct DIRECTORY_EVENT *event);
# 29 "headers.h" 2
# 1 "mystats.h" 1

# 1 "machine.h" 1
# 3 "mystats.h" 2






typedef struct ADDR_TABLE_ENTRY{
md_addr_t addr;
int valid;
int read;
int write;
int private_access;
int private_access_r;
int private_access_w;
int srw_access;
int srw_access_r;
int srw_access_w;
int private_count;
int srw_count;
int word;
int use;
int type;
int owner;
} addr_table_entry;

struct ADDR_TABLE{
addr_table_entry mem[1048576];
counter_t count;
}addr_table;

counter_t Cache_access[101];
counter_t word_utilization[101];
counter_t Cache_access_p[101];
counter_t word_utilization_p[101];
counter_t Cache_access_m[101];
counter_t word_utilization_m[101];
counter_t Cache_access_s[101];
counter_t word_utilization_s[101];
counter_t Cache_access_srw[101];
counter_t word_utilization_srw[101];
counter_t Cache_acc_srw_private[101];
counter_t Cache_acc_srw_srw[101];
counter_t Cache_acc_srw_pri_r[101];
counter_t Cache_acc_srw_pri_w[101];
counter_t Cache_acc_srw_r[101];
counter_t Cache_acc_srw_w[101];
counter_t Cache_dynamic_acc_private[101];
counter_t Cache_dynamic_acc_migrate[101];
counter_t Cache_dynamic_acc_shared[101];
counter_t Cache_dynamic_acc_srw[101];
counter_t private_count;
counter_t migrate_count;
counter_t shared_count;
counter_t shared_rw_count;
counter_t private_others;
counter_t private_dynamic_accesses;
counter_t migrate_dynamic_accesses;
counter_t shared_dynamic_accesses;
counter_t sharedrw_dynamic_accesses;
counter_t line_inflight_accesses;
counter_t line_accesses;
counter_t type_changed;
counter_t private_to_shared_rw;
counter_t shared_rw_to_private;
counter_t inflight_private;
counter_t inflight_migrate;
counter_t inflight_shared_rw;
counter_t inflight_shared_only;
counter_t shared_rw_constant;


void stats_allocate(md_addr_t addr, int read, int write, int word, int type, int owner);
void stats_update(md_addr_t addr, int read, int write, int word, int type, int owner, int hit_count);
int stats_type_check(int old_type, int type, int old_owner, int owner);
int stats_compare(md_addr_t addr);
void stats_do(md_addr_t addr, int read, int write, int word, int type, int owner);
void stats_collect();
# 30 "headers.h" 2


# 1 "opticalForSimplescalar/point-point.h" 1
# 14 "opticalForSimplescalar/point-point.h"
# 1 "opticalForSimplescalar/../host.h" 1
# 15 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../smt.h" 1
# 16 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../machine.h" 1
# 17 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../options.h" 1
# 18 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../cache.h" 1
# 19 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../syscall.h" 1
# 20 "opticalForSimplescalar/point-point.h" 2
# 1 "opticalForSimplescalar/../context.h" 1
# 9 "opticalForSimplescalar/../context.h"
# 1 "opticalForSimplescalar/../host.h" 1
# 10 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../misc.h" 1
# 11 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../machine.h" 1
# 12 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../endian.h" 1
# 100 "opticalForSimplescalar/../endian.h"
# 1 "opticalForSimplescalar/../smt.h" 1
# 101 "opticalForSimplescalar/../endian.h" 2
# 13 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../regs.h" 1
# 14 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../memory.h" 1
# 15 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../sim.h" 1
# 16 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../eio.h" 1
# 92 "opticalForSimplescalar/../eio.h"
FILE *eio_create(char *fname);

FILE *eio_open(char *fname);


int eio_valid(char *fname);

void eio_close(FILE *fd);



counter_t
eio_write_chkpt(struct regs_t *regs,
  struct mem_t *mem,
  FILE *fd);



counter_t
eio_read_chkpt(struct regs_t *regs,
  struct mem_t *mem,
  FILE *fd);




void
eio_write_trace(FILE *eio_fd,
  counter_t icnt,
  struct regs_t *regs,
  mem_access_fn mem_fn,
  struct mem_t *mem,
  md_inst_t inst);




void
eio_read_trace(FILE *eio_fd,
        counter_t icnt,
        struct regs_t *regs,
        mem_access_fn mem_fn,
        struct mem_t *mem,
        md_inst_t inst);


void eio_fast_forward(FILE *eio_fd, counter_t icnt);
# 17 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../loader.h" 1
# 18 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../bpred.h" 1
# 19 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../bitmap.h" 1
# 20 "opticalForSimplescalar/../context.h" 2

# 1 "opticalForSimplescalar/../power.h" 1
# 54 "opticalForSimplescalar/../power.h"
# 1 "opticalForSimplescalar/../flp.h" 1
# 34 "opticalForSimplescalar/../flp.h"
typedef struct unit_t_st
{
 char name[256];
 double width;
 double height;
 double leftx;
 double bottomy;
}unit_t;


typedef struct flp_t_st
{
 unit_t *units;
 int n_units;
} flp_t;
# 57 "opticalForSimplescalar/../flp.h"
void print_flp_fig (flp_t *flp, FILE *outfile);


flp_t *read_flp(char *file);


void free_flp(flp_t *flp);


int get_blk_index(flp_t *flp, char *name);


int exists_blk_index(flp_t *flp, char *name);


int is_horiz_adj(flp_t *flp, int i, int j);


int is_vert_adj (flp_t *flp, int i, int j);


double get_shared_len(flp_t *flp, int i, int j);


double get_total_width(flp_t *flp);


double get_total_height(flp_t *flp);
# 55 "opticalForSimplescalar/../power.h" 2
# 1 "opticalForSimplescalar/../stats.h" 1
# 56 "opticalForSimplescalar/../power.h" 2


# 1 "opticalForSimplescalar/../smt.h" 1
# 59 "opticalForSimplescalar/../power.h" 2
# 603 "opticalForSimplescalar/../power.h"
typedef struct {
   int tech;
   int iw;
   int winsize;
   int nvreg;
   int npreg;
   int nvreg_width;
   int npreg_width;
   int data_width;
} parameter_type;

typedef struct {
  double btb;
  double btb_gc;
  double local_predict;
  double local_predict_gc;
  double global_predict;
  double global_predict_gc;
  double chooser;
  double chooser_gc;
  double ras;
  double ras_gc;
  double rat_driver;
  double rat_decoder;
  double rat_wordline;
  double rat_bitline;
  double rat_senseamp;
  double rat_gc;
  double dcl_compare;
  double dcl_pencode;
  double inst_decoder_power;
  double iwakeup_tagdrive;
  double iwakeup_tagmatch;
  double iwakeup_ormatch;
  double iwakeup_gc;
  double fwakeup_tagdrive;
  double fwakeup_tagmatch;
  double fwakeup_ormatch;
  double fwakeup_gc;
  double lsq_wakeup_tagdrive;
  double lsq_wakeup_tagmatch;
  double lsq_wakeup_ormatch;
  double lsq_wakeup_gc;
  double iselection;
  double fselection;
  double iregfile_driver;
  double iregfile_decoder;
  double iregfile_wordline;
  double iregfile_bitline;
  double iregfile_senseamp;
  double iregfile_gc;
  double fregfile_driver;
  double fregfile_decoder;
  double fregfile_wordline;
  double fregfile_bitline;
  double fregfile_senseamp;
  double fregfile_gc;
# 672 "opticalForSimplescalar/../power.h"
  double lsq_rs_driver;
  double lsq_rs_decoder;
  double lsq_rs_wordline;
  double lsq_rs_bitline;
  double lsq_rs_senseamp;
  double lsq_rs_gc;

  double iresultbus;
  double fresultbus;

  double icache_decoder;
  double icache_wordline;
  double icache_bitline;
  double icache_senseamp;
  double icache_tagarray;
  double icache_gc;

  double icache;

  double dcache_decoder;
  double dcache_wordline;
  double dcache_bitline;
  double dcache_senseamp;
  double dcache_tagarray;
  double dcache_gc;

  double dtlb;
  double itlb;
  double dtlb_gc;
  double itlb_gc;

  double dcache2_decoder;
  double dcache2_wordline;
  double dcache2_bitline;
  double dcache2_senseamp;
  double dcache2_tagarray;
  double dcache2_gc;

  double total_power;
  double total_power_nodcache2;
  double ialu1_power;
  double ialu2_power;
  double falu1_power;
  double falu2_power;
  double bpred_power;
  double rename_power;
  double iqram_power;
  double fqram_power;
  double clock1_power;
  double clock2_power;
  double clock3_power;
  double rob1_power;
  double rob2_power;
  double rat_power;
  double dcl_power;
  double lsq_power;
  double iwakeup_power;
  double fwakeup_power;
  double lsq_wakeup_power;




  double lsq_rs_power;
  double lsq_rs_power_nobit;
  double iselection_power;
  double fselection_power;
  double iregfile_power;
  double fregfile_power;
  double iregfile_power_nobit;
  double fregfile_power_nobit;
  double result_power;
  double icache_power;
  double dcache_power;
  double dcache2_power;





  double clock_power;





  double link_rx_power[8];
  double link_rx_power_cl[8];
  double link_tx_power[8];
  double link_tx_power_cl[8];
  double qram_power[8];
  double qram_power_cl[8];


  double compare_power;
  double d_flip_flop_power;
  double two_to_1_mux_power;
  double duplication_power;
  double Powerfactor;
  double SensePowerfactor;

  double vdd_reduction;

} power_result_type;



typedef struct {
   int cache_size;
   int number_of_sets;
   int associativity;
   int block_size;
} time_parameter_type;

typedef struct {
   double access_time,cycle_time;
   int best_Ndwl,best_Ndbl;
   int best_Nspd;
   int best_Ntwl,best_Ntbl;
   int best_Ntspd;
   double decoder_delay_data,decoder_delay_tag;
   double dec_data_driver,dec_data_3to8,dec_data_inv;
   double dec_tag_driver,dec_tag_3to8,dec_tag_inv;
   double wordline_delay_data,wordline_delay_tag;
   double bitline_delay_data,bitline_delay_tag;
  double sense_amp_delay_data,sense_amp_delay_tag;
  double senseext_driver_delay_data;
   double compare_part_delay;
   double drive_mux_delay;
   double selb_delay;
   double data_output_delay;
   double drive_valid_delay;
   double precharge_delay;

} time_result_type;


double logtwo(double x);
double gatecap(double width,double wirelength);
double gatecappass(double width,double wirelength);
double draincap(double width,int nchannel,int stack);
double restowidth(double res,int nchannel);
double simple_array_power(int rows,int cols,int rports,int wports,int cache);
double simple_array_decoder_power(int rows,int cols,int rports,int wports,int cache);
double simple_array_bitline_power(int rows,int cols,int rports,int wports,int cache);
double simple_array_wordline_power(int rows,int cols,int rports,int wports,int cache);
double squarify_new(int rows,int cols);
void clear_access_stats();




void power_reg_stats(struct stat_sdb_t *sdb);
void calculate_time(time_result_type*, time_parameter_type*);
void output_data(time_result_type*, time_parameter_type*);
void calculate_power(power_result_type*);
int pop_count(quad_t bits);
int pop_count_slow(quad_t bits);


void power_clear();
void sim_cyc(unsigned long);
void power_value(FILE *fp);
# 22 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../smt.h" 1
# 23 "opticalForSimplescalar/../context.h" 2
# 1 "opticalForSimplescalar/../branchCorr.h" 1



# 1 "opticalForSimplescalar/../machine.h" 1
# 5 "opticalForSimplescalar/../branchCorr.h" 2
# 14 "opticalForSimplescalar/../branchCorr.h"
typedef struct
{
    int id;
    md_inst_t inst;
    enum md_opcode op;
    md_addr_t PC;
    md_addr_t NPC;
    counter_t time;
    counter_t sim_num_insn;
    int instType;
} branchInst;

typedef struct
{
    branchInst bI[1024];
    int boqSize;
    int corrNum;
    int totalNum;
    int indBrNum;
    int corrHead;
    int corrCurrentHead;
    int corrTail;

    int bIntrvCount;
    counter_t lastUpdtCycle;
} branchCorr;


void initBranchCorr(branchCorr *pQ);
void resetQueue(branchCorr *pQ);
int pushBranchPred(branchCorr *pQ, branchInst **branch, enum md_opcode op);
int popBranchPred(branchCorr *pQ, branchInst **branch);
void commitPrediction(branchCorr *pQ, int index);
int queueSize(branchCorr *pQ);
void recoverPredQueue(branchCorr *pQ, int boqIndex);
# 24 "opticalForSimplescalar/../context.h" 2
# 40 "opticalForSimplescalar/../context.h"
int thrdPerJobCnt;
# 89 "opticalForSimplescalar/../context.h"
extern int MTAcontexts;
struct lreg_id_t
{
  int threadid;
  int lreg;
};
# 105 "opticalForSimplescalar/../context.h"
typedef unsigned int INST_TAG_TYPE;




typedef unsigned int INST_SEQ_TYPE;
# 140 "opticalForSimplescalar/../context.h"
struct RUU_station
{

    int index;
    int threadid;
    md_inst_t IR;
    enum md_opcode op;
    md_addr_t PC, next_PC, pred_PC;
    int in_LSQ;
    int ea_comp;
    int recover_inst;
    int stack_recover_idx;
    struct bpred_update_t dir_update;
    int spec_mode;
    int spec_mode_next;
    md_addr_t addr;
 int miss_flag;
    INST_TAG_TYPE tag;

    INST_SEQ_TYPE seq;

    unsigned int ptrace_seq;

    int duplicate;
 int pref_flag;


    int queued;
    int issued;
    int completed;


    quad_t val_ra, val_rb, val_rc, val_ra_result;




    int onames[2];
    struct RS_link *odep_list[2];







    int idep_ready[3];
    unsigned long long when_idep_ready[3];
    int idep_name[3];

    struct RUU_station *prod[3];
    counter_t disp_time;
    counter_t finish_time;
    int cache_ready;
    counter_t fetch_time;
    counter_t commit_time;
    counter_t issue_time;
    int invalidationReceived;

    int out1, in1, in2, in3;

    int oldpreg;
    int opreg;

    int cluster;
    int when_ready[3];
    int when_inq;
    int pbank;
    int abank;
    int in_qwait;
    int freed;
    int ipreg[3];

    int st_reach[64];
    long instnum;
    int distissue;

    int counted_iissueq;
    int counted_fissueq;

    int counted_iready;
    int counted_fready;
    int counted_lsqready;


    int counted_non_issue_lsq;







    int spec_rdb_miss;
    int spec_wrb_miss;
# 255 "opticalForSimplescalar/../context.h"
    int faulting_instr;
    long long int wrongCycle;
    int dl2_missed;
    counter_t sim_num_insn;
    int outReg;
    qword_t prevRegVal;
    struct regs_t prevReg;

    counter_t sqStoreForwardT;



    half_t ushFlag;

    half_t ushSpecLdDelay;



    int replayThisEntry, entryReplayed;

    int ldAccessFlag;
    struct regs_t backupReg;
    int robEntry;
    int lsqEntry;
    int isPrefetch;
    int isL1Miss;
    int writewait;
    int ReadShareDir;
    int writemiss;
    int readAfterWrite;
 int STL_C_fail;
# 297 "opticalForSimplescalar/../context.h"
    int isSyncInst;
    int isSyncInstBar;
    int isSyncInstBarRel;
};
# 317 "opticalForSimplescalar/../context.h"
struct RS_link {
  struct RS_link *next;
  struct RUU_station *rs;
  INST_TAG_TYPE tag;
  union {
    tick_t when;
    INST_SEQ_TYPE seq;
    int opnum;
  } x;
  counter_t last_use;
  counter_t rs_link_id;
};



struct CV_link {
  struct RUU_station *rs;
  int odep_num;
};

struct RS_list {
 struct RS_list *next;
 struct RUU_station *rs;
 tick_t when;
 int spec_mode;
};


struct wb_mem_ent {
    struct wb_mem_ent *next;
    md_addr_t instr;
    md_addr_t PC;
    md_addr_t addr;
    unsigned int data[2];
    int nbytes;
    counter_t sim_num_insn;
    counter_t disp_time;
    int lsqId;
    counter_t completeCycle;
    struct wb_mem_ent *prev;
    int is_STL_C;
    int needBusAccess;
    int accessed;
    int writeAlreadyDone;
};







struct spec_mem_ent {
  struct spec_mem_ent *next;
  md_addr_t addr;
  unsigned int data[2];
};




struct fetch_rec
{
    int index;
    int threadid;
    unsigned long fetch_time;
    md_inst_t IR;
    md_addr_t regs_PC, pred_PC;
    struct bpred_update_t dir_update;
    int stack_recover_idx;
    unsigned int ptrace_seq;

    unsigned int is_ctrl2 : 1;
    int is_dup;




};

typedef struct context_t
{
    int running;
    unsigned long long finish_cycle;
    unsigned long long start_cycle;
    int id;





    int masterid;
    int parent;
    int num_child;
    int num_child_active;
    unsigned long long fastfwd_count;

    int fastfwd_done;
    int barrierReached;
    int startReached;
    int jobThdId;
    int helpThdId;
    int oracleId;

    FILE *argfile;
    char *sim_progout;
    char *sim_progin;
    FILE *sim_progfd;
    int sim_inputfd;


    char *fname;
    char **argv;
    int argc;


    struct regs_t regs;


    struct mem_t *mem;




    md_addr_t ld_text_base ;


    unsigned int ld_text_size ;


    md_addr_t ld_data_base ;


    md_addr_t ld_brk_point ;


    unsigned int ld_data_size ;


    md_addr_t ld_stack_base ;


    unsigned int ld_stack_size ;


    md_addr_t ld_stack_min ;


    char *ld_prog_fname ;


    md_addr_t ld_prog_entry;


    md_addr_t ld_environ_base ;


    int ld_target_big_endian;



    char *sim_eio_fname;
    char *sim_chkpt_fname;
    FILE *sim_eio_fd;


    int sim_swap_bytes;
    int sim_swap_words;






    int oldwindowilp[360];
    int oldwindowbr[360];
    long oldwindowpc[360];
    int owindow_head;

    int ltopmap[( 32 + 32 + 3 + 1 + 1 + 1)];
    int ltopmap_old[( 32 + 32 + 3 + 1 + 1 + 1)][64][((64*1)/2)];
    int lprod[( 32 + 32 + 3 + 1 + 1 + 1)];
    int lprod_rd[( 32 + 32 + 3 + 1 + 1 + 1)];
    int ltopmap_chk[( 32 + 32 + 3 + 1 + 1 + 1)];
    int lprod_chk[( 32 + 32 + 3 + 1 + 1 + 1)];
    int lprod_rd_chk[( 32 + 32 + 3 + 1 + 1 + 1)];

    struct lreg_id_t ptolmap[1024];
    struct lreg_id_t consumers[1024];
    struct lreg_id_t ptolmap_chk[1024];


    counter_t sim_num_insn;


    counter_t sim_total_insn;


    counter_t fetch_num_insn;


    counter_t fetch_total_insn;


    counter_t sim_num_refs;


    counter_t sim_total_refs;


    counter_t sim_num_loads;


    counter_t sim_total_loads;


    counter_t sim_num_branches;


    counter_t sim_total_branches;


    counter_t sim_invalid_addrs;






    unsigned int inst_seq;


    unsigned int ptrace_seq;





    int spec_mode;
    int spec_mode_next;


 int delay_slot_mark;
 md_addr_t delay_slot_pc;


    int fault_mode;


    unsigned ruu_fetch_issue_delay;
    int wait_for_fetch;



    struct RUU_station *RUU;
    int RUU_head, RUU_tail;
    int RUU_num;
    counter_t RUU_count_thrd;
    counter_t RUU_fcount_thrd;


    struct RUU_station *LSQ;
    int LSQ_head, LSQ_tail;
    int LSQ_num;
    int LSQ_count;
    int LSQ_fcount;
    short m_shLQNum;
    short m_shSQNum;


    int fetch_num_thrd;
    int iissueq_thrd;
    int fissueq_thrd;

    int non_issue_lsq_thrd;
    int lsq_thrd;

    int icount_thrd;





    unsigned int (use_spec_cv)[(((( 32 + 32 + 3 + 1 + 1 + 1))+31)/32)];
    unsigned int (use_spec_R)[(((32)+31)/32)];
    unsigned int (use_spec_F)[(((32)+31)/32)];
    unsigned int (use_spec_C)[(((32)+31)/32)];

    struct CV_link create_vector[( 32 + 32 + 3 + 1 + 1 + 1)];
    struct CV_link spec_create_vector[( 32 + 32 + 3 + 1 + 1 + 1)];



    tick_t create_vector_rt[( 32 + 32 + 3 + 1 + 1 + 1)];
    tick_t spec_create_vector_rt[( 32 + 32 + 3 + 1 + 1 + 1)];


    md_gpr_t spec_regs_R;


    md_fpr_t spec_regs_F;


    md_ctrl_t spec_regs_C;


    md_addr_t pred_PC;
    md_addr_t recover_PC;


    md_addr_t fetch_regs_PC;
    md_addr_t fetch_pred_PC;



    struct RS_link last_op;


    struct spec_mem_ent *store_htable[32];

    struct spec_mem_ent *bucket_free_list;


    struct wb_mem_ent *WBtableHead;
    struct wb_mem_ent *WBtableTail;

    struct wb_mem_ent *WBbucket_free_list;



    int fetch_redirected;



    double fetch_delay_stat;
    double max_fetch_delay_stat;



    unsigned long spec_rdb_miss_count;
    unsigned long spec_wrb_miss_count;
    unsigned long non_spec_rdb_miss_count;
    unsigned long non_spec_wrb_miss_count;
    unsigned long inst_miss_count;
    unsigned long load_miss_count;
    unsigned long store_miss_count;
# 678 "opticalForSimplescalar/../context.h"
    md_addr_t stack_base;


    unsigned long numDL1CacheAccess;
    unsigned long numLocalHits;
    unsigned long numRemoteHits;
    unsigned long numMemAccess;
    unsigned long numReadCacheAccess;
    unsigned long numWriteCacheAccess;
    unsigned long numInvalidations;
    unsigned long numDL1Hits;
    unsigned long numDL1Misses;
    unsigned long numInsn;




    unsigned int *branch_address2;
    int branch_head2, branch_tail2;
    int my_last_tag;
    unsigned cycle_mask;
    float latency_factor;
    int active_this_cycle;
    int pcb_penalty;
    int main_thread;
    power_result_type power;


    counter_t rename_access;
    counter_t iqram_access;
    counter_t fqram_access;
    counter_t rob1_access;
    counter_t rob2_access;
    counter_t bpred_access;
    counter_t iwakeup_access;
    counter_t fwakeup_access;
    counter_t iselection_access;
    counter_t fselection_access;
    counter_t iregfile_access;
    counter_t fregfile_access;

    counter_t lsq_access;
    counter_t icache_access;
    counter_t dcache_access;
    counter_t dcache2_access;
    counter_t input_buf_access;
    counter_t output_buf_access;
    counter_t icache2_access;

    counter_t ialu1_access;
    counter_t ialu2_access;
    counter_t falu1_access;
    counter_t falu2_access;
    counter_t iresultbus_access;
    counter_t fresultbus_access;
    counter_t lsq_preg_access;
    counter_t lsq_wakeup_access;

    int isFFdone;


    struct bpred_t *pred;
    struct fetch_rec *fetch_data[128];
    int fetch_num;
    int fetch_tail, fetch_head;


    unsigned long TotalnumDL1CacheAccess;
    unsigned long TotalnumLocalHits;
    unsigned long TotalnumRemoteHits;
    unsigned long TotalnumMemAccess;
    unsigned long TotalnumReadCacheAccess;
    unsigned long TotalnumWriteCacheAccess;
    unsigned long TotalnumInvalidations;
    unsigned long TotalnumDL1Hits;
    unsigned long TotalnumDL1Misses;
    unsigned long TotalnumInsn;
    unsigned long NRLocalHitsLoad;
    unsigned long NRRemoteHitsLoad;
    unsigned long NRMissLoad;
    unsigned long NRLocalHitsStore;
    unsigned long NRRemoteHitsStore;
    unsigned long NRMissStore;
    unsigned long present;


    unsigned long numInstrBarrier;
    unsigned long numCycleBarrier;
    unsigned long totalBarrierInstr;
    unsigned long totalBarrierCycle;

    unsigned long numInstrLock;
    unsigned long numCycleLock;
    unsigned long totalLockInstr;
    unsigned long totalLockCycle;

    unsigned int L0BufferHits;
    unsigned int TotalLoads;

    unsigned int DataLocatorHit;
    unsigned int DataLocatorMiss;

    unsigned long sleptAt;
    int freeze;
    int stallThread;
    int waitFor;
    int atMB;
    int waitForSTLC;
    int numOfWBEntry;
    int WBFull;
    int waitForBranchResolve;
    unsigned long loadLatency;
    unsigned long numLoads;
    int stopThread;
    int actualid;
    int ffStall;
    int localSubEpoch;
    int lastSubEpochSeen[32];







   struct DIRECTORY_EVENT *event;
} context;

extern int numcontexts;
extern context *thecontexts[64];


struct sharedAddressList_s {
    unsigned long long address;
    unsigned int size;
    struct sharedAddressList_s * next;
};

struct sharedAddressList_s *sharedAddressList[512];





int
read_thread_args(char *env[], char *filename, int *curcontext);

void update_power_stats(power_result_type, int, context*);
# 21 "opticalForSimplescalar/point-point.h" 2


extern int mesh_size;
# 89 "opticalForSimplescalar/point-point.h"
int ConfRecord[64];


counter_t large_retry;
counter_t small_retry;
counter_t acrossUsed;

int confirmation_bit_inf[((8 +2)*(8 +2))];
counter_t bit_overflow;
counter_t bit_used;
counter_t transmitter_busy;
counter_t wb_close;
extern int meta_total_num;
extern int meta_collision_total;
extern int data_total_num;
extern int data_collision_total;
# 147 "opticalForSimplescalar/point-point.h"
int currentFlits;

int input_extra_overflow;
extern int cache_dl1_set_shift;

extern FILE *fp_trace;
extern struct DIRECTORY_EVENT *dir_event_queue;
extern counter_t Output_queue_full;
counter_t last_Output_queue_full[((8 +2)*(8 +2))];
counter_t more_than_two_conflict;
counter_t meta_more_than_two_conflict;
counter_t meta_sync_conf_event;
counter_t meta_sync_conf_packets;
counter_t meta_ldl_more_than_two_conflict;
counter_t meta_ldl_conf_event;
counter_t meta_ldl_conf_packets;
counter_t sync_conf_packets;
counter_t sync_conf_event;
extern counter_t Stall_output_queue;


counter_t reply_time_distribution[250];
counter_t reply_L1_time_distribution[50];

counter_t queue_distr[24];

int meta_conf_event;
int data_conf_event;
counter_t data_conflict_pro;
counter_t meta_conflict_pro;

counter_t input_buf_access;
counter_t output_buf_access;
counter_t output_buffer_flits[((8 +2)*(8 +2))];

int laser_warmup_time;

int laser_setup_time;

int laser_switchoff_timeout;

int flit_tranfer_time;
int data_flit_tranfer_time;

int laser_cycle;

int meta_transmitter_size;
int data_transmitter_size;

int flit_size;






int confirmation_bit;

int input_buffer_size;

int output_buffer_size;
int output_ports;

int packet_queue_size;

int meta_receivers;

int data_receivers;

int transmitters;

int confirmation_trans;

int confirmation_receiver;

int time_slot_data;

int data_chan_timeslot;
int meta_chan_timeslot;

int exp_backoff;

float first_slot_num;

int retry_algr;

int TBEB_algr;

int confirmation_time;

int conf_ack_packets;
counter_t conf_ack_packets_read;
int conf_upgrades;
int conf_readupgrades;
int conf_sync_lock;
int acknowledge_packets;


typedef struct Flit{
int flit_type;
struct Flit *next;
int Num;
int PID;
}Flit;


typedef struct Flit_list{
Flit *head;
Flit *tail;
int flits_in_list;
}Flit_list;

struct Flit_list free_flit_list;
void allocate_free_flit_list();
Flit * allocate_flit();


typedef struct Packet{



counter_t start_time;
counter_t transfer_time;
counter_t transmitter_time;
md_addr_t addr;
int packet_type;
unsigned long packet_size;
long src;
long des;
int flitnum;
int msgno;
int meta_id;
int data_id;
int retry;
int pending[64];
int con_flag[4];
int retry_num;
int operation;
int channel;
int meta_delay;
int data_delay;
int prefetch;

counter_t arrival_time;
int queue_time;
int steering_time;
int miss_flag;
int dirty_flag;
int ts_delay;
int data_reply;
int conf_bit;
int conf_hint;
int early_conf;
int schedule;
int escape_channel;
int isSyncAccess;
int ldl;
int SyncLock;
}Packet;


typedef struct Msg{
int msg_type;
counter_t when;
struct Msg *next;
struct Msg *pre;
struct Packet packet;
}Msg;


typedef struct Msg_list{
Msg *head;
Msg *tail;
}Msg_list;


int Map_algr;
int network_algr;

struct Input_entry_t{
int isValid;
Packet packet;
counter_t time_stamp;
};

struct Input_buffer{
int flits_in_buffer;
int packets_in_buffer;
struct Input_entry_t InputEntry[256];
};


counter_t last_packet_cycle[((8 +2)*(8 +2))][2];
counter_t dist_bin[20];
counter_t channel_occupancy;
counter_t meta_packets;
counter_t data_packets;
counter_t meta_packet_transfer;
counter_t data_packet_transfer;
counter_t channel_busy_data[((8 +2)*(8 +2))];
counter_t channel_busy_meta[((8 +2)*(8 +2))];

counter_t req_conf[((8 +2)*(8 +2))];
counter_t data_conf[((8 +2)*(8 +2))];
counter_t data_conf_involves[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t write_back_involves[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t write_back_inv_bincount[3];
counter_t data_conf_inv_bincount[7];
counter_t data_way_conf[((8 +2)*(8 +2))];
counter_t meta_way_conf[((8 +2)*(8 +2))];
counter_t bin_count_end[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t bin_count_start[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t req_cycle_conflicts[((8 +2)*(8 +2))];
counter_t data_cycle_conflicts[((8 +2)*(8 +2))];
counter_t last_cycle[((8 +2)*(8 +2))][4];
Msg *conf_list[((8 +2)*(8 +2))][4];
counter_t no_write_back;
counter_t all_write_back;
counter_t partial_write_back;
counter_t no_solution_pwb;


counter_t total_wb_msg;
counter_t wb_split_conf_event;
counter_t WbSplitConf;
counter_t WbSplitFailConf;
counter_t total_wbhead_msg;
counter_t total_wb_head_success;
counter_t total_wb_head_fail;
counter_t total_wbreq_confirmation;
counter_t total_wbreq_convention;
counter_t total_wb_req_convention_success;
counter_t total_wb_req_convention_fail_event;
counter_t total_wb_req_convention_fail_time;

counter_t total_mem_msg;
counter_t mem_split_conf_event;
counter_t MemSplitConf;
counter_t MemSplitFailConf;
counter_t total_memhead_msg;
counter_t total_mem_head_success;
counter_t total_mem_head_fail;
counter_t total_memreq_confirmation;
counter_t total_memreq_convention;
counter_t total_mem_req_convention_success;
counter_t total_mem_req_convention_fail_event;
counter_t total_mem_req_convention_fail_time;


int max_conf;
int max_packet_retry;
int max_packets_inbuffer;
int max_flits_inbuffer;

counter_t MemPckConfEvent;
counter_t MemSecPckConfEvent;
counter_t WriteBackConfEvent;
counter_t RetransmissionConfEvent;
counter_t ReplyConfEvent;

counter_t retry_conflict;
counter_t L1_L2_conflict;
counter_t all_L2_miss_conflict;
counter_t L2_miss_conflict;
counter_t L2_dirty_conflict;
counter_t queue_delay_conflict;
counter_t l2_fifo_conflict;
counter_t fifo_queue_steering_conflict;
counter_t steering_queue_conflict;
counter_t queue_conflict;
counter_t wrong_conflict;
counter_t request_close_conflict;
counter_t max_queue_delay;

struct packet_conflict_list{
Packet packet[((8 +2)*(8 +2))];
int packet_num;
}packet_conflict[((8 +2)*(8 +2))][5];

counter_t last_data_time[((8 +2)*(8 +2))];
counter_t last_time[((8 +2)*(8 +2))];
counter_t RT_time[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t RTCC;
counter_t RTCC_fail;
counter_t RTCC_half;
counter_t RTCC_miss;
counter_t RTCC_reduced;
counter_t RTCC_flag[((8 +2)*(8 +2))];
counter_t meta_close_packets;
counter_t meta_reduced_packets;
counter_t data_packet_generate;
extern counter_t global_data_packets_generation;
counter_t data_packet_generate_max;


counter_t network_queue_delay;
counter_t output_queue_delay;
counter_t data_network_queue_delay;
counter_t meta_network_queue_delay;
counter_t pending_delay;
counter_t steering_delay;
counter_t data_confliction_delay;
counter_t meta_confliction_delay;
counter_t laser_switch_on_delay;
counter_t timeslot_wait_time;
counter_t meta_timeslot_wait_time;

counter_t network_queue_Delay[((8 +2)*(8 +2))];
counter_t output_queue_Delay[((8 +2)*(8 +2))];
counter_t data_network_queue_Delay[((8 +2)*(8 +2))];
counter_t meta_network_queue_Delay[((8 +2)*(8 +2))];
counter_t pending_Delay[((8 +2)*(8 +2))];
counter_t steering_Delay[((8 +2)*(8 +2))];
counter_t data_confliction_Delay[((8 +2)*(8 +2))];
counter_t meta_confliction_Delay[((8 +2)*(8 +2))];
counter_t laser_switch_on_Delay[((8 +2)*(8 +2))];
counter_t timeslot_wait_Delay[((8 +2)*(8 +2))];
counter_t meta_timeslot_wait_Delay[((8 +2)*(8 +2))];

counter_t no_queue_delay;
counter_t network_delay_in_fiber;
counter_t confliction_delay;
counter_t data_conflict_packet_num;
counter_t meta_conflict_packet_num;
counter_t mem_data_conflict;
counter_t mem_req_conflict;
counter_t mem_data_retry;
counter_t mem_req_retry;
counter_t reply_data_packets;
counter_t original_reply_data_packets;
counter_t write_back_packets;
counter_t original_write_back_packets;
counter_t data_retry_packet_num;
counter_t meta_retry_packet_num;
counter_t pending_packet_num;
counter_t wbreq_timeslot_wait_time;
counter_t packets_sending[((8 +2)*(8 +2))];
counter_t packets_sending_bin_count[5];
counter_t last_packet_time[((8 +2)*(8 +2))];
counter_t last_close_time[((8 +2)*(8 +2))];
counter_t last_meta_packet[3][((8 +2)*(8 +2))];
counter_t next_meta_packet[3][((8 +2)*(8 +2))];
counter_t last_meta_packet_fake[((8 +2)*(8 +2))];
counter_t meta_wait_time[((8 +2)*(8 +2))];
counter_t backup_transfer_waittime[((8 +2)*(8 +2))];
counter_t last_delay_for_data[((8 +2)*(8 +2))];
counter_t transmitter_backup_schedule[((8 +2)*(8 +2))];
counter_t first_packet_time[((8 +2)*(8 +2))];
counter_t retry_data_queue;
counter_t retry_meta_queue;
counter_t receiver_occ_time[((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t meta_delay_packets;
counter_t wbreq_delay_packets;
counter_t meta_l1_delay_packets;
counter_t meta_packets_forward;
counter_t data_packets_forward;


counter_t total_cycle_laser_power_on;
counter_t laser_power_switchon_counter;
counter_t laser_power_switchoff_counter;
counter_t laser_direction_switch_counter;
counter_t flits_transmit_counter;
counter_t flits_receiving_counter;
counter_t data_packets_delay;
counter_t data_packets_no_delay;
counter_t data_delay;
counter_t total_cycle_conf_laser_power_on;
counter_t conf_laser_power_switchon_counter;
counter_t conf_laser_power_switchoff_counter;


Msg_list *msg_list;


Flit_list transmitter_meta[((8 +2)*(8 +2))];
Flit_list transmitter_data[((8 +2)*(8 +2))];
Flit_list transmitter_backup[((8 +2)*(8 +2))];
struct Input_buffer input_buffer[((8 +2)*(8 +2))];
int last_packet_des[((8 +2)*(8 +2))];
int last_meta_packet_des[3][((8 +2)*(8 +2))];
int last_meta_packet_des_fake[((8 +2)*(8 +2))];
int last_packet_des_backup[((8 +2)*(8 +2))];
counter_t delay_counter[2][((8 +2)*(8 +2))];
counter_t delay_count[2][((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t delay_counter_backup[((8 +2)*(8 +2))];


Flit_list out_buffer[((8 +2)*(8 +2))];
Packet packet_queue[((8 +2)*(8 +2))][256];
int packet_queue_tail[((8 +2)*(8 +2))];
int packet_queue_head[((8 +2)*(8 +2))];
int packet_queue_num[((8 +2)*(8 +2))];
int input_buffer_num[((8 +2)*(8 +2))][2];





struct ReqPending {
int valid;
int des;
md_addr_t addr;
counter_t time;
int op_code;
};

counter_t conflict_table[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t meta_conflict_table[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))][((8 +2)*(8 +2))];
counter_t meta_ldl_conflict_table[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))][((8 +2)*(8 +2))];



struct ConfPredTable {
int LastPred;
int LLastPred;
int counter;
int Lcounter;
};

struct ConfPredTable confpred[((8 +2)*(8 +2))*3];

counter_t tencase;
counter_t MultiCase[((8 +2)*(8 +2))];

struct ReqPending ReqPendingQueue[((8 +2)*(8 +2))][256];
int ReqPendingQueue_num[((8 +2)*(8 +2))];
int MaxReqPending;

int conf_packet_list[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))];
Packet conf_packet[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))];
int conf_packet_num[((8 +2)*(8 +2))*3];
int conf_PID[((8 +2)*(8 +2))*3];
int ConfWait[((8 +2)*(8 +2))*3];
counter_t wb_retry_conf;
counter_t predict_correct;
counter_t predict_fail;
counter_t predictCorrect_two;
counter_t predictCorrect_more;
counter_t predictFail_two;
counter_t predictFail_more;
counter_t predict_table_correct;
counter_t predict_req_correct;
counter_t hint_received;
counter_t hint_received_wrong;
counter_t packet_conf_hint_conf;
counter_t packet_conf_hint_suc;
counter_t MultiPendingError;
counter_t WbPendingError;
counter_t ReqPendingError;
counter_t ReqPendingError2;
counter_t TotalReqPendingNum;
counter_t ReqPendingBin[12];
void ConfPacketListInsert(Packet packet, int PID);
void ConfPacketListClean(counter_t sim_cycle);
void ConfPredictor(counter_t sim_cycle);
int PredictTable(int pid, int pid_bar, int seed, int m);
int PidTableCheck(int PID, int src, int j, counter_t sim_cycle);
void input_buffer_check(Packet packet, counter_t sim_cycle);
void conf_hint(Packet packet, counter_t sim_cycle);


int meta_conf_packet_list[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))];
Packet meta_conf_packet[((8 +2)*(8 +2))*3][((8 +2)*(8 +2))];
int meta_conf_packet_num[((8 +2)*(8 +2))*3];
void MetaConfPacketListInsert(Packet packet, int PID);
void MetaConfPacketListClean(counter_t sim_cycle);
void MetaEarlyConf(counter_t sim_cycle);
# 659 "opticalForSimplescalar/point-point.h"
int PID_form(int PID);


Flit_list *data_receiver[((8 +2)*(8 +2))], *meta_receiver[((8 +2)*(8 +2))];

int laser_power[2][((8 +2)*(8 +2))];
counter_t laser_power_on_cycle[2][((8 +2)*(8 +2))];
counter_t laser_power_start_cycle[2][((8 +2)*(8 +2))];
int conf_laser_power[2][((8 +2)*(8 +2))];
counter_t conf_laser_power_on_cycle[2][((8 +2)*(8 +2))];
counter_t conf_laser_power_start_cycle[2][((8 +2)*(8 +2))];


void optical_options(struct opt_odb_t *odb);

void optical_reg_stats (struct opt_odb_t *sdb);
int packet_retry_algr(Packet packet);


int add_flit(Flit *flit, Flit_list *flit_list);
int free_flit(Flit *flit, Flit_list *flit_list);



void add_message(counter_t start_time, int msg_type, Packet packet);

void free_message(Msg *oldmsg);

void add_packet(Packet packet, long des);
void free_packet(long des);


void maindirectsim(int map_algr, int net_algr);
void Msg_list_init(Msg_list *msg_list);
void flit_list_init(Flit_list flit_alist);


int conflict_check(Packet *packet, counter_t when);
void conflict_type_change(Flit_list *flit_list, int flit_id);
int cycle_conflict_check(Packet packet, counter_t when, int receivers);

void conlict_bincount_collect(counter_t sim_cycle);

void input_buffer_add(Packet packet, counter_t time_stamp);

void input_buffer_free(Packet packet, counter_t sim_cycle);
int is_appending_addr(Packet packet);
void input_buffer_lookup(long src, counter_t sim_cycle);
void retry_packet(int msgno, counter_t sim_cycle, long src);


void receive_msg(Packet packet, counter_t sim_cycle);

int setup_delay(int src, int des, counter_t sim_cycle, int p_type);

int channel_busy_check(int src, int des, int type, counter_t sim_cycle);


void receive_msg_data(Packet pck, counter_t sim_cycle);

void receive_msg_meta(Packet pck, counter_t sim_cycle);

void receive_flit_msg(Packet pck, counter_t sim_cycle);


void receive_ack_msg(Packet pck, counter_t sim_cycle);



void directMsgInsert(long s1, long s2, long d1, long d2, counter_t sim_cycle, long size, long long int msgNo, md_addr_t addr, int operation, int delay, int L2miss_flag, int prefetch, int dirty_flag, counter_t arrival_time, int data_reply, int conf_bit, int escape_channel, int even_flag, int isSyncAccess, int SyncLock



);

void directRunSim(counter_t sim_cycle);
int opticalBufferSpace(long des1, long des2, int opt);

int finishMsg(long src, long des, counter_t start_time, counter_t popnetmsgno, int packet_type, counter_t transfer_time, int meta_delay, counter_t req_time, int operation, int out_buffer_dec);

void free_out_buffer_flit(int iteration, long des);



void sending_flit(Packet packet, counter_t sim_cycle);

void receive_flit(Packet packet, counter_t sim_cycle);


int receiver_map(long src, long des, int receiver, md_addr_t addr);
# 33 "headers.h" 2


# 1 "smt.h" 1
# 36 "headers.h" 2




# 1 "context.h" 1
# 41 "headers.h" 2




# 1 "cluster.h" 1
# 46 "cluster.h"
# 1 "smt.h" 1
# 47 "cluster.h" 2
# 319 "cluster.h"
struct listelt {
  int preg;
  struct listelt *next;
  struct listelt *prev;
};



extern double *link_width_dist;

extern int ring1[64][5000];
extern int ring2[64][5000];
extern int ring3[64][5000];
extern int ring4[64][5000];

extern int *reg1[64][5000];
extern int *reg2[64][5000];




extern int reg3[64][5000];
extern int reg4[64][5000];
# 46 "headers.h" 2

# 1 "cluster-opts.h" 1



extern int n_way;
extern int n_way_cache;
extern int n_way_adjacent;
extern int uni_lat_comm;
extern int two_lat_comm;
extern int link_width;
extern int hop_time;

extern int tokenB;

extern char *optical_type;
extern char optical_type_char;
extern int optical_link_width;
extern int optical_comm;
extern int optical_hop_time;


extern counter_t *optical_link_width_dist;
extern counter_t comm_opt_qram_access_cl[64];
extern counter_t total_slip_cycles;
extern counter_t max_slip_cycles;
extern counter_t total_issue_slip_cycles;
extern counter_t max_issue_slip_cycles;





extern counter_t total_delay;
extern counter_t total_number_delay;
extern counter_t st_total_delay;
extern struct stat_stat_t *delay_dist;
extern struct stat_stat_t *st_delay_dist;
extern struct stat_stat_t *commit_width_stat;

extern counter_t total_hop;
extern struct stat_stat_t *hop_dist;


void cluster_reg_options(struct opt_odb_t *odb);
void cluster_reg_stats(struct stat_sdb_t *sdb);
void cluster_check_options(void);



extern char * link_definitions[8];
extern int link_definitions_argc;
extern char * link_custom_destinations[8];
extern int link_custom_destinations_argc;
# 48 "headers.h" 2

# 1 "hotspot.h" 1
# 54 "hotspot.h"
int hotspot_active;

FILE *sim_hotspotout_fd;






extern double base_proc_freq;

typedef struct hotspot_power_t_st
{

 double fmul;
 double freg;
 double fadd;
 double dtb0;
 double fqueue;
 double iqueue;
 double lsq;
 double ireg0;
 double ialu0;
 double ialu1;
# 88 "hotspot.h"
 double comm_link_tx[8];
 double comm_link_rx[8];
 double comm_qram[8];

 double dl1cache;
 double ul2cache;
 double raq;
 double iresultbus;
 double fresultbus;
 double clock1;
 double clock2;
 double clock3;





 double bpred;
 double icache;
 double rob;
 double irename;
 double itlb;
 double fetch;




 double cpbuf;
 double broutq;
 double pcbuf;

 double bus0;
 double bus1;


 double sysintf;

 double ialu2;
 double frename;

 double ialu3;
 double dtb1;
 double ireg1;

}hotspot_power_array_t;
extern hotspot_power_array_t hotspot_perperiod[64];

extern counter_t last_hotspot_cycle;





void hotspot_init(void);
void hotspot_uninit(void);
void hotspot_reg_options(struct opt_odb_t *odb);
void update_hotspot_stats(int elapsed_cycles);
void hotspot_dumpstats(void);



void leakage_power_value(FILE *fp);
void leakage_power_clear();
# 50 "headers.h" 2

# 1 "cmt.h" 1
# 25 "cmt.h"
void steer_init(void);
# 52 "headers.h" 2




# 1 "tokencoherence.h" 1
# 44 "tokencoherence.h"
typedef enum {shared,exclusive,persistent} tc_request_type;


typedef struct {
    int has_data;
    int has_owner_token;
    int nonowner_token_count;
    md_addr_t addr;
} tc_messagetoken_ack;

typedef struct {
    int from;
    tc_request_type type;
} tc_messagetoken_req;



typedef struct tc_blockinfo_struct
{
    struct tc_blockinfo_struct * next;
    char exists;
    char valid;
    char i_am_owner;
    char nonowner_token_count;
    md_addr_t addr;




    short read_in_pipeline;
    short write_in_pipeline;
    char modified;
    counter_t state_as_of;
} tc_blockinfo;

typedef struct hashtable_entry_struct
{
    struct hashtable_entry_struct * next;
    md_addr_t addr;
    int cache_number;
    tc_blockinfo * blockinfo_head;
} hashtable_entry;
# 106 "tokencoherence.h"
void tc_init(int num_caches, int num_blocks, int block_size);

void tc_reg_stats(struct stat_sdb_t *sdb);


int tc_access(md_addr_t addr, int cache_number,int cluster, int is_write, int is_hint, counter_t cycle);


void tc_commit_predict(md_addr_t addr,int cache_number, int is_write, counter_t cycle, counter_t issue_cycle);
void tc_commit_real(md_addr_t addr,int cache_number, int is_write, counter_t predicted_cycle, counter_t real_cycle);


void tc_block_alloc(md_addr_t addr, int cache_number, counter_t cycle);


void tc_block_free(md_addr_t addr, int cache_number, counter_t cycle);
# 57 "headers.h" 2
# 65 "headers.h"
extern counter_t sim_cycle;
extern int actual_clusters;
extern double tot_del;
extern double tot_del_bw;
extern double num_bw_of;
extern int RUU_size;




extern int hotspot_cycle_sampling_intvl;
# 114 "sim-outorder.c" 2

# 1 "main.h" 1
# 22 "main.h"
typedef struct RES_DESC
{
 char *strName;
 int nCnt;

 int oplat;

 int issuelat;


 int Busy[16];

}ResDesc, *PResDesc;

ResDesc m_SQPort;
# 116 "sim-outorder.c" 2

# 1 "instManip.h" 1




int GetMemAccWidth(enum md_opcode op);
bool_t isFPMemAcc(enum md_opcode op);
void formatDataM2R(enum md_opcode op, qword_t memData, qword_t *regData);
void formatDataR2M(enum md_opcode op, qword_t regData, qword_t *memData);
void getRegValue(enum md_opcode op, context *current, int ra, qword_t *data);
# 118 "sim-outorder.c" 2


 counter_t TotalBarriers = 0;
 counter_t TotalLocks = 0;
 counter_t pure_num_insn = 0;
 counter_t total_num_insn = 0;
 counter_t rename_access = 0;
 counter_t iqram_access = 0;
 counter_t fqram_access = 0;
 counter_t rob1_access = 0;
 counter_t rob2_access = 0;
 counter_t bpred_access = 0;
 counter_t iwakeup_access = 0;
 counter_t fwakeup_access = 0;
 counter_t iselection_access = 0;
 counter_t fselection_access = 0;
 counter_t iregfile_access = 0;
 counter_t fregfile_access = 0;

 counter_t lsq_access = 0;
 counter_t icache_access = 0;
 counter_t dcache_access = 0;
 counter_t dcache2_access = 0;
 counter_t icache2_access = 0;

 counter_t ialu1_access = 0;
 counter_t ialu2_access = 0;
 counter_t falu1_access = 0;
 counter_t falu2_access = 0;
 counter_t iresultbus_access = 0;
 counter_t fresultbus_access = 0;
 counter_t lsq_preg_access = 0;
 counter_t lsq_wakeup_access = 0;


 extern counter_t launch_sp_access ;
 extern counter_t l1launch_sp_access ;

 int pcb_blk_count = 0;

    int fl_count;
    fl_count = 0;

 counter_t sleepCount[64];



 counter_t duplication_access, DUPLICATION_access[64], duplication_total = 0;
 counter_t compare_access, COMPARE_access[64], compare_total = 0;



 counter_t predict_commit (struct RUU_station *rs);


 int bpred_btb_use_masterid = 0;
 extern int ilink_run;
 extern int em3d_run;


 extern int mainPopnet(int array_size);
 extern int popnetMsgComplete(long w, long x, long y, long z, long long int stTime, long long int msgNo);
 extern int popnetBufferSpace(long s1, long s2, int opt);
 extern void popnet_options(struct opt_odb_t *odb);

 extern counter_t popnetMsgNo;
 int mshr_pending_event[64];

 counter_t same_L1_L2_fifo_full;
 counter_t L1_mshr_full;
 counter_t last_L1_mshr_full[64];
 counter_t L2_mshr_full;
 counter_t last_L2_mshr_full;
 counter_t L2_mshr_full_prefetch;
 counter_t L1_fifo_full;
 counter_t last_L1_fifo_full[64 +8*2];
 counter_t Dir_fifo_full;
 counter_t last_Dir_fifo_full[64 +8*2];
 counter_t Input_queue_full;
 counter_t last_Input_queue_full[64 +8*2];
 counter_t Output_queue_full;
 counter_t lock_fifo_full;
 counter_t lock_fifo_wrong;
 counter_t lock_fifo_writeback;
 counter_t lock_fifo_benefit;
 counter_t lock_cache_hit;
 counter_t lock_cache_miss;

 counter_t Stall_L1_mshr;
 counter_t Stall_L2_mshr;
 counter_t Stall_L1_fifo;
 counter_t Stall_dir_fifo;
 counter_t Stall_input_queue;
 counter_t Stall_output_queue;

 counter_t WM_Miss;
 counter_t WM_Clean;
 counter_t WM_S;
 counter_t WM_EM;
 counter_t write_shared_used_conf;

 counter_t SyncInstCacheAccess;
 counter_t TestCacheAccess;
 counter_t TestSecCacheAccess;
 counter_t SetCacheAccess;
 counter_t SyncLoadReadMiss;
 counter_t SyncLoadLReadMiss;
 counter_t SyncLoadHit;
 counter_t SyncLoadLHit;
 counter_t SyncStoreCHit;
 counter_t SyncStoreCWriteMiss;
 counter_t SyncStoreCWriteUpgrade;
 counter_t SyncStoreHit;
 counter_t SyncStoreWriteMiss;
 counter_t SyncStoreWriteUpgrade;
 counter_t BarStoreWriteMiss;
 counter_t BarStoreWriteUpgrade;
 counter_t Sync_L2_miss;


 extern counter_t nack_counter, L1_flip_counter, flip_counter, e_to_m;
 extern counter_t normal_nacks, write_nacks, prefetch_nacks, sync_nacks;
 extern counter_t store_conditional_failed;
 counter_t totalMeshHopCount, totalMeshHopDelay, totalEventCount, totalEventProcessTime;
 counter_t totalMeshNorHopCount, totalMeshNorHopDelay, totalMeshSyncHopCount, totalMeshSyncHopDelay;
 counter_t totalOptHopCount, totalOptHopDelay, totalOptNorHopCount, totalOptNorHopDelay, totalOptSyncHopCount, totalOptSyncHopDelay;
 counter_t load_link_shared, load_link_exclusive;
 extern tick_t totalmisshandletime;
 extern counter_t L1_prefetch_usefull;
 extern counter_t L1_prefetch_writeafter;
 extern long long int totaleventcountnum;
 extern counter_t totalWriteIndicate;
 extern counter_t total_exclusive_modified;
 extern counter_t total_exclusive_conf;
 extern counter_t total_exclusive_cross;

 extern counter_t totalSyncEvent;
 extern counter_t totalNormalEvent;
 extern counter_t totalSyncWriteM;
 extern counter_t totalSyncReadM;
 extern counter_t totalSyncWriteup;
 extern counter_t totalmisstimeforNormal;
 extern counter_t totalmisstimeforSync;
 extern counter_t total_mem_lat;
 extern counter_t total_mem_access;
 extern counter_t totalL2misstime;
 extern counter_t totalWrongL2misstime;
 extern counter_t TotalL2misses;
 extern long long int total_L1_prefetch;
 extern counter_t l2_prefetch_num;
 extern counter_t write_back_early;
 extern long long int total_L1_first_prefetch;
 extern long long int total_L1_sec_prefetch;
 extern long long int totalreqcountnum;
 extern long long int totalmisscountnum;
 extern counter_t local_cache_access, remote_cache_access, localdirectory, remotedirectory;
 extern counter_t involve_2_hops, involve_2_hop_touch, involve_2_hop_wb, involve_2_hops_wm, involve_4_hops_wm, involve_2_hops_upgrade, involve_4_hops, involve_4_hops_miss, involve_2_hops_miss, involve_4_hops_upgrade;
 counter_t totalSplitNo, totalSplitWM;
 extern counter_t data_private_write, data_private_read, data_shared_write, data_shared_read;
 extern counter_t total_all_close, total_all_almostclose, total_not_all_close, total_p_c_events, total_consumers, total_packets_in_neighbor, total_packets_at_corners;
 extern counter_t total_data_consumers, total_data_close, total_data_far, total_data_at_corner;
 extern counter_t sharer_num[64];
 extern double average_inside_percent;
 extern double average_outside_percent;
 extern double average_outside_abs_percent;
 extern double average_corner_percent;
 int mem_port_lat[16];
 counter_t port_accord[16];
# 301 "sim-outorder.c"
 struct quiesceStruct quiesceAddrStruct[64];
 md_addr_t TempInstr = 0x1A2B3C4D;
 int access_mem = 0;
 int access_mem_id = -1;
 int stopped_num_threads = 0;
 int ReadFromWB = 0;
 counter_t cacheMiss[64], hitInOtherCache[64];
 counter_t m_sqPrefetchCnt = 0;
 long long int executeMaxInsn;
 long long int dl2ActuallyAccessed, markedLineReplaced;
 long long int quienseWakeup[64];
 long long int simInsn[64];
 int flushImpStats = 0;


 int threadForked[4], allForked, storeCondFail, timeToReturn = 0;
 counter_t StoreConditionFailNum;
 int collectStatBarrier, collectStatStop[64];
 long long int realSimCycle;
 int actualProcess;
 int disable_ray = 1;
 int fu_busy[64], wb_done[64], issue_done[64], fetch_done[64], commit_done[64], dispatch_done[64];
 counter_t brRecovery[64], extraInsn[64];
# 334 "sim-outorder.c"
 counter_t pullbackBubble[64], pullbackWaitCycle[64], pullbackDoneThisCycle[64], pullbackHitPred[64], dl1MissThisCycle[64], dl1HitThisCycle[64], pullbackCycleCount[64],
 pullbackCount[64];
counter_t predHitHit[64], predHitMiss[64], predMissHit[64], predMissMiss[64];



int mshr_size = 0;
int mshr_full = 0;
double mshr_count;


double mshr_size_dist[10000000];

double mshr_full_count;






short m_shLQSize;
short m_shSQSize;
counter_t m_totalStall[64];
counter_t m_sqLQFull[64];
counter_t m_sqSQFull[64];
counter_t m_RUUFull[64];
counter_t m_regFull[64];
counter_t m_issueFull[64];
counter_t m_il1Miss[64];
counter_t m_fetchEmpty[64];
counter_t m_STLC[64];
counter_t m_trap[64];
counter_t m_LoadStallMiss[64];
counter_t m_StoreStallMiss[64];
counter_t m_LoadStallHit[64];
counter_t m_StoreStallHit[64];
counter_t m_LoadRealMiss[64];
counter_t m_StoreRealMiss[64];
counter_t m_LoadRealHit[64];
counter_t m_StoreRealHit[64];
counter_t m_LoadMiss[64];
counter_t m_StoreMiss[64];
counter_t m_StoreUpdateMiss[64];
counter_t m_update_miss_depend_start[64];
counter_t m_update_miss_flag[64];
counter_t UpdateDependCycle;
volatile int prefetch_flag = 1;
extern counter_t m_update_miss[64];
extern int lock_waiting[64];
extern int barrier_waiting[64];

counter_t m_commitStall[64];

counter_t invalidation_replay[64];
counter_t loadLoadReplayCount[64];
int invalidationStall[64], invalidateOtherCache;
int commitStall[64];
# 411 "sim-outorder.c"
int checkLSQforSt (int i, context * current);
counter_t loadRejectReplay[64], loadRejectCount[64], loadRejectStat[64], m_sqNumLdReplay[64], replayIndex[64];
int rejectRetryCycle = 3;
counter_t ldIssueCount, ldstRejectionCount[64];

long long int seqConsReplay[64], seqConsInsnReplay[64];
counter_t totalRUUsize[64], totalLQsize[64], totalSQsize[64];
double avgRUUsize[64], avgLQsize[64], avgSQsize[64];

extern int mta_maxthreads;
extern int numThreads[64];
int collect_stats = 0;
int COHERENT_CACHE;
int MSI;
int spec_benchmarks;
extern counter_t num_of_invalidations;

int collect_barrier_stats[64];
int collect_barrier_release;

int collect_lock_stats[64];
md_addr_t LockInitPC;
md_addr_t last_pc;
md_addr_t last_last_pc;
long long int freezeCounter;
int stopsim;
int fastfwd;

int store_conditional_waiting[64];

int oc_or_cc_access = 2;


int BRANCH_Q_NUM;
int CHECKER_NUMBER = 0;
int PCB_BLK_SIZE = 128;
int INORDER_CHECKER = 0;
int OUTSTANDING_STORE_NUM = 128;
float checkerVDD, checkerFreq;



extern md_inst_t MD_NOP_INST;
static int delay_slot_spec = 0;
static int delay_slot_mark = 0;
static md_addr_t delay_slot_pc = 0;

int get_free_reg (int, int);
void commitWrite (md_addr_t addr, int threadID, counter_t completeCycle, int needBusAccess, int accessed);
void completeWrite ();
void initParallelSimulation ();
void completeStore (int threadid, md_addr_t addr, int width, int isFail);
void completeStore_l (int threadid, md_addr_t addr, int width);

enum md_fault_type WB_access1 (struct mem_t *mem, enum mem_cmd cmd, md_addr_t addr, void *p, int nbytes, int threadID, md_addr_t instr);


void seqConsistancyReplay (int replay_index, int threadid);
void fixSpecState (int replay_index, int threadid);



struct listelt *ifreelist_head[64], *ifreelist_tail[64];
struct listelt *ffreelist_head[64], *ffreelist_tail[64];
# 490 "sim-outorder.c"
int hotspot_cycle_sampling_intvl;


static unsigned long max_insts;
static int max_barrier;


static int ptrace_nelt = 0;
static char *ptrace_opts[2];


static int ruu_ifq_size;


static int ruu_branch_penalty;


static int fetch_speed;



char *pred_type;





char *pred_type2;



const int combined2 = 0;



const int hist_imm = 0;







static int bimod_nelt = 1;
int bimod_config[1] = { 2048 };


static int twolev_nelt = 4;
int twolev_config[4] = { 1, 1024, 8, 0 };


static int comb_nelt = 1;
int comb_config[1] = { 1024 };


static int twobcgskew_nelt = 6;
static int twobcgskew_config[6] = { 32768, 32768, 0, 22,
                     4, 4
};
# 560 "sim-outorder.c"
int ras_size = 8;


static int btb_nelt = 2;
int btb_config[2] = { 512, 4 };


int ruu_decode_width;
int ruu_issue_width;



int ruu_inorder_issue;
int LSQ_NUM_MORE_THAN_TWO;


static int ruu_include_spec = 1;


int ruu_commit_width;


int RUU_size = 1024;


int LSQ_size = 1024;

int LSQ_size_cluster;



static char *cache_dl1_opt;


int cache_dl1_lat;


static char *cache_dl2_opt;


int cache_dl2_lat;

int mesh_size;

static char *cache_il1_opt;


int cache_il1_lat;


static char *cache_il2_opt;


static int cache_il2_lat;


static int flush_on_syscalls;


static int compress_icache_addrs;


static int mem_nelt = 2;
int mem_lat[2] = { 18, 2 };


int mem_bus_width;
float mem_bus_speed;
int mem_port_num;


static char *itlb_opt;


static char *dtlb_opt;


static int tlb_miss_lat;


static int network_receiver;
static int network_conflict;


int res_ialu = 0;


int res_imult = 0;



int res_membank = 0;


int res_mem_port_bank = 0;

int res_membank_cluster;




int res_memport = 0;


int res_fpalu = 0;


int res_fpmult = 0;


int res_ialu_cluster = 0;
int res_imult_cluster = 0;
int res_fpalu_cluster = 0;
int res_fpmult_cluster = 0;


int data_width = 64;


extern power_result_type power;



int activecontexts;

int thread_fetch = 8;
int inst_thread_fetch = 1024;
int thread_commit = 0;



int ibank = 0;


int priorityslot = 0;
int priority[64];


int key[64];



counter_t iqram_access_cl[64];
counter_t fqram_access_cl[64];
counter_t iwakeup_access_cl[64];
counter_t fwakeup_access_cl[64];
counter_t iselection_access_cl[64];
counter_t fselection_access_cl[64];
counter_t iregfile_access_cl[64];
counter_t fregfile_access_cl[64];
counter_t ialu1_access_cl[64];
counter_t ialu2_access_cl[64];
counter_t falu1_access_cl[64];
counter_t falu2_access_cl[64];
counter_t iresultbus_access_cl[64];
counter_t fresultbus_access_cl[64];


counter_t lsq_store_data_access = 0;


counter_t lsq_preg_access_cl[64];
counter_t lsq_wakeup_access_cl[64];
counter_t lsq_access_cl[64];
int extra_lsq = 0;
double extra_lsq_count = 0;
double disp_store_stall = 0;







int iq_cl_full_mask;
int fq_cl_full_mask;
int ireg_cl_full_mask;
int freg_cl_full_mask;
int res1_cl_thrd_mask[64];


counter_t lsq_total_pop_count_cycle = 0;
counter_t lsq_num_pop_count_cycle = 0;
counter_t iregfile_total_pop_count_cycle = 0;
counter_t iregfile_num_pop_count_cycle = 0;
counter_t fregfile_total_pop_count_cycle = 0;
counter_t fregfile_num_pop_count_cycle = 0;
counter_t iresultbus_total_pop_count_cycle = 0;
counter_t iresultbus_num_pop_count_cycle = 0;
counter_t fresultbus_total_pop_count_cycle = 0;
counter_t fresultbus_num_pop_count_cycle = 0;
# 760 "sim-outorder.c"
static int pcstat_nelt = 0;
static char *pcstat_vars[8];
# 774 "sim-outorder.c"
static int bugcompat_mode;
# 788 "sim-outorder.c"
struct res_desc fu_config[] = {
 {
  "integer-ALU",
  4,
  0,
  0,
  0,
  {
   {IntALU, 1, 1}
  }
 },
 {
  "integer-MULT/DIV",
  1,
  0,
  0,
  0,
  {



   {IntMULT, 3, 1},
   {IntDIV, 20, 19}
  }
 },
 {
  "memory-port",
  1,
  0,
  0,
  0,
  {
   {RdPort, 2, 1},
   {WrPort, 2, 1}
  }
 },
 {
  "FP-adder",
  4,
  0,
  0,
  0,
  {
   {FloatADD, 2, 1},
   {FloatCMP, 2, 1},
   {FloatCVT, 2, 1}
  }
 },
 {
  "FP-MULT/DIV",
  1,
  0,
  0,
  0,
  {
   {FloatMULT, 4, 1},
   {FloatDIV, 12, 12},
   {FloatSQRT, 24, 24}
  }
 },
};
# 864 "sim-outorder.c"
int actual_clusters = 64;





int CACHEPORTS;
int RES_CACHEPORTS;
extern int RES_CACHE_PORTS;
int actual_cacheports;
# 882 "sim-outorder.c"
int dispatch_cl[64];
# 894 "sim-outorder.c"
int NEIGHBOR_SEEK_N_WAY = 64 / 2;

int steer_cluster_thrd[64][64];
double abs_steer = 0;
void steer_init (void);
# 929 "sim-outorder.c"
int n_limit_thrd[64];





int n_start_thrd[64];
int neighbor_limit_thrd[64];
# 971 "sim-outorder.c"
double n_limit_thrd_dist[64][64 + 1];
double n_limit_dist[64 + 1];
# 992 "sim-outorder.c"
int n_cache_start_thrd[64];
int n_cache_limit_thrd[64];
# 1027 "sim-outorder.c"
double mem_ref_thrd[64];
double mem_ref;







int no_cluster_thrd[64];


double abs_res_steer = 0;
double num_steer = 0;

long int_distilpthresh = (long) (10000 / 6);
int distilptable[16384];
struct tag_id_t distilptabletagid[16384];
long distilpcounter[16384];
long distilpsamples[16384];
int distilpcount = 0;
long int_distilp = 0;

int skipped_br = 0;
long distilp = 0;
long distilp_valid = 0;

long insn16 = 0;
long insn4 = 0;

int insn_interval = 10000;
int h_regs[3];

int num_sent = 0;
int num_trips = 1;
int lastcluster = 0;
long instseqnum = 0;

int rthresh;
int brthresh;
int msthresh;
int imsthresh;
int cycthresh;
int rnoise;
int brnoise;
int msnoise;
int imsnoise;

double regdelay = 0;
double regtrans = 0;
double totallat = 0;
double totlds = 0;

double flushes = 0;
double num_flushes = 0;
double free_cluster = 0;
# 1100 "sim-outorder.c"
int IIQ_size = 1048;
int FIQ_size = 1048;
int IPREG_size = 4000;
int FPREG_size = 4000;

int IIQ_size_cluster;
int FIQ_size_cluster;
int IPREG_size_cluster;
int FPREG_size_cluster;
# 1118 "sim-outorder.c"
double non_crit = 0;
double crit = 0;
double tab2_corr = 0;
double tab2_incorr = 0;
double tab2_miss = 0;
double tab_corr = 0;
double tab_incorr = 0;
double tab_miss = 0;
long table_tags[64][4096];
int table_num[64][4096];
long table2_tags[64][4096];
int table2_num[64][4096];
# 1138 "sim-outorder.c"
long add_alu = 0;
long nonadd_alu = 0;



int notwarm = 1;
unsigned long cyclecheck;
# 1156 "sim-outorder.c"
int iissueq;
int fissueq;


int iready = 0;
int fready = 0;
int lsqready = 0;
int iunready = 0;
int funready = 0;
int lsqunready = 0;
double IREADY_count = 0;
double FREADY_count = 0;
double LSQREADY_count = 0;
int iready_cl[64];
int fready_cl[64];
int lsqready_cl[64];
int iunready_cl[64];
int funready_cl[64];



int lsq_cl[64];
int lsqunready_cl[64];





int lsq_part_bank;
int lsq_part_cl = 64 / 64;
int lsq_part_thrd;


int iregfile;
int fregfile;
int iregfile_cl[64];
int iextra_cl[64];
int fregfile_cl[64];
int fextra_cl[64];
int iissueq_cl[64];
int fissueq_cl[64];
int num_storeq[64];
int max_storeq[64];
int disp_delay = 0;

int inchk = 0;
long inchk2 = 0;
long inchk3 = 0;
counter_t inilpchk = 0;
int cycchk = 0;
long cycchk2 = 0;
long cycchk3 = 0;
int brchk = 0;
int refchk = 0;
int insnchkpt = 0;
int cyclechkpt = 0;
int brchkpt = 0;
int refchkpt = 0;
int imischkpt = 0;
int mischkpt = 0;
int delchkpt = 0;
int original_bsize = 0;
int cache_dl1_set_shift = 0;
int phase = 64;
int cycle_count[64 + 1];
float stable_count = 0;
int stop_expl = 0;

int iextra;
int fextra;
int ivalid;
int fvalid;

double tot_ireg = 0;
double tot_freg = 0;
double tot_iext = 0;
double tot_fext = 0;
double tot_inondup = 0;
double tot_fnondup = 0;

double comm_delay = 0;
double num_single = 0;
double iss_stall = 0;
double fe_stall = 0;
double n_ready = 0;
double num_semi_f = 0;
double num_qwstall = 0;
double in_this = 0;
double num_freed = 0;
double tot_del = 0;
double tot_del_bw = 0;
double num_bw_of = 0;
double rrobin = 0;

double min_addr = 5600000000ULL;
long max_addr = 0;

double stddev = 0;
int ban0 = 0;
int ban1 = 0;
int ban2 = 0;
int ban3 = 0;
long bin_acc_tot = 0;
long bin_mis_tot = 0;
long bin_acc[(5400000000ULL - 4799987712ULL) / 16384];
long bin_lds[(5400000000ULL - 4799987712ULL) / 16384];
long bin_tol[(5400000000ULL - 4799987712ULL) / 16384];
long bin_mis[(5400000000ULL - 4799987712ULL) / 16384];
# 1274 "sim-outorder.c"
long addr0, addr1, addr2;


int num_issued = 0;
int iss_rate[4];
int issue_rate = 0;
long tol[4][3];
long tol0 = 0;
long tol1 = 0;
long tol2 = 0;
long tot_tol = 0;
long tot_tol0 = 0;
long tot_tol1 = 0;
long tot_tol2 = 0;
long tot_tol3 = 0;
long bank_conf = 0;
long st_bank_conf = 0;


long miss_num[512];
long ref_num[512];




long ref_N;

long disp_time[( 32 + 32 + 3 + 1 + 1 + 1)];
long lifetime1 = 0;
long lifetime2 = 0;
long waittime1 = 0;
long waittime2 = 0;
long conswaittime1 = 0;
long conswaittime2 = 0;
long num1 = 0;
long num2 = 0;
long num11 = 0;
long num22 = 0;
long histo[122];

double disp_stalls = 0;
double cause1 = 0;
double cause2 = 0;
double cause3 = 0;
double cause4 = 0;
double cause5 = 0;


double IISSUEQ_count = 0;
double IISSUEQ_fcount = 0;
double FISSUEQ_count = 0;
double FISSUEQ_fcount = 0;
double IPREG_count = 0;
double Iextra_count = 0;
double IPREG_fcount = 0;
double FPREG_count = 0;
double Fextra_count = 0;
double FPREG_fcount = 0;

double iregfile_cl_count[64];
double iextra_cl_count[64];
double fregfile_cl_count[64];
double fextra_cl_count[64];
double iissueq_cl_count[64];
double fissueq_cl_count[64];


double lsq_cl_count[64];


double no_disp_cluster = 0;
double disp_dist[1024 + 1];
# 1361 "sim-outorder.c"
int p_total_regs = 4000 +4000 +1;







int shiftreg1[64][1024];
int specshiftreg1[64][1024];
int shiftreg2[64][1024];
int specshiftreg2[64][1024];
int shiftreg3[64][1024];
int specshiftreg3[64][1024];
int shiftreg4[64][1024];
int specshiftreg4[64][1024];
int shiftreg5[64][1024];
int specshiftreg5[64][1024];
int lev2pred1[4096];
int lev2pred2[4096];
int lev2pred3[4096];
int lev2pred4[4096];
int lev2pred5[4096];

long bank_pred_corr = 0;
long bank_pred_wrong = 0;
long ac_bank_pred_corr = 0;
long ac_bank_pred_wrong = 0;


int spec_rdb_miss = 0;
int spec_wrb_miss = 0;
int count_error = 0;



void power_parameter_copy ();

void bin_init ();
void cache_init ();
void ilp_init ();
void bankpred_init ();
void reg_init (int);
void cache_change_config (int);
void ring_free ();
void cache_update ();
void compute_queue (int);
void reg_count ();
void bpred_init (int);


long simple_cache_flush (struct cache_t *);
int cluster_check (md_addr_t);
void bank_update (md_addr_t, int, int);
void st_ring_lat (struct RUU_station *);
int ring_lat (int, int, int, int);
void copy_from (int);
void freelist_insert (int, int);
void check_RUU_LSQ_match (void);
void check_reg (void);
void power_clear (void);
void sim_cyc (unsigned long);
void calculate_priority (void);
void insert_fillq (long, md_addr_t);





void general_stat (void);
# 1441 "sim-outorder.c"
static counter_t sim_total_insn = 0;


static counter_t sim_num_refs = 0;


static counter_t sim_total_refs = 0;


static counter_t sim_num_loads = 0;


static counter_t sim_total_loads = 0;


static counter_t sim_num_branches = 0;


static counter_t sim_total_branches = 0;
# 1468 "sim-outorder.c"
counter_t sim_cycle = 0;
counter_t global_data_packets_generation = 0;
counter_t TotalMetaPacketsInAll = 0;
counter_t TotalDataPacketsInAll = 0;
counter_t TotalSyncDataPackets = 0;
counter_t TotalSyncMetaPackets = 0;
counter_t MetaPackets_1;
counter_t DataPackets_1;
counter_t warmupEndCycle = 0;
counter_t data_packets_sync = 0;
counter_t meta_packets_sync = 0;
counter_t data_packets_sending[300][300];
counter_t meta_packets_sending[300][300];
counter_t link_ser_lat[300][300];
counter_t meta_even_req_close[300];
counter_t meta_odd_req_close[300];
counter_t optical_data_packets = 0;
counter_t optical_meta_packets = 0;
counter_t mesh_data_packets = 0;
counter_t mesh_meta_packets = 0;

counter_t parallel_sim_cycle = 1;
int disp2, disp1;


counter_t IFQ_count;
counter_t IFQ_fcount;
counter_t RUU_count;
counter_t RUU_fcount;
counter_t LSQ_count;
counter_t LSQ_fcount;

counter_t pfl2Hit = 0;
counter_t pfl2SecMiss = 0;
counter_t pfl2PrimMiss = 0;


double non_issue_LSQ_count;
double non_issue_LSQ_fcount;



static counter_t sim_invalid_addrs;






static unsigned int ptrace_seq = 0;







static int pred_perfect = 0;


static char *bpred_spec_opt;
static enum
{ spec_ID, spec_WB, spec_CT } bpred_spec_update;


struct cache_t *cache_il1[64];


struct cache_t *cache_il2;


struct cache_t *cache_dl1[64];


struct cache_t *cache_dl2;


struct cache_t *itlb[64];


struct cache_t *dtlb[64];
# 1569 "sim-outorder.c"
struct res_pool *fu_pool = ((void *)0);


static struct stat_stat_t *pcstat_stats[8];
static counter_t pcstat_lastvals[8];
static struct stat_stat_t *pcstat_sdists[8];
# 1587 "sim-outorder.c"
int ClusterStruct[64][64];
extern long ThrdAccessPattern[64][64];
extern FILE *outFile;
void periodic_adaptation (void);

int stop_fetch = 0;
unsigned long lastSimCycle = 0;


int startTakingStatistics = 0;




 void
initClusterInfo ()
{
 int i, l;

 for (i = 0; i < 64; i++)
  for (l = 0; l < 64; l++)
   ClusterStruct[i][l] = -1;
 return;
}

int HavePrinted = 0;

 void
PrintClusterInfo ()
{
 int gg, rr;

 for (rr = 0; rr < 64; rr++)
 {
  printf ("\n");
  for (gg = 0; gg < 64; gg++)
   printf ("%d", ClusterStruct[rr][gg]);
 }
}



 static unsigned int
mem_access_latency (int blk_sz)
{
 int chunks = (cache_dl1[0]->bsize)*mem_port_num/ mem_bus_width;


 ((chunks > 0) ? (void) (0) : (__assert_fail ("chunks > 0", "sim-outorder.c", 1635, __PRETTY_FUNCTION__), (void) (0)));

 return ( mem_lat[0] +
   ( ((float)4/mem_bus_speed) * (chunks - 1)));

}
# 1649 "sim-outorder.c"
counter_t dl1_acc_fn_num, dl2_acc_fn_num, il1_acc_fn_num, il2_acc_fn_num;
counter_t dl1_acc_fn_num=0;
counter_t dl2_acc_fn_num=0;
counter_t il1_acc_fn_num=0;
counter_t il2_acc_fn_num=0;
struct RUU_station *rsCacheAccess = ((void *)0);
FILE *fp_trace;

unsigned int
dl1_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



       )
{
 unsigned int lat;
 int which_thread, i;
 int flag = 0;
 which_thread = threadid;
    dl1_acc_fn_num++;





 if (cache_dl2)
 {


  lat = cache_access (cache_dl2, cmd, baddr, ((void *)0), bsize, now, ((void *)0), ((void *)0), ((void *)0), which_thread, ((void *)0));

  dcache2_access++;
  thecontexts[threadid]->dcache2_access++;
  if (cmd == Read)
   return lat;
  else
   return 0;
 }
 else
 {

  if (cmd == Read)
   return mem_access_latency (bsize);
  else
   return 0;
 }
}

extern int dl2_prefetch_active;


static unsigned int
dl2_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



       )
{


 if (!dl2_prefetch_active)
 {
  insert_sp (baddr, threadid);
 }


 int lat;
    dl2_acc_fn_num++;


 {
  int src, port_num, x, y;
  src = (baddr >> cache_dl2->set_shift) % numcontexts;
  x = (src /mesh_size);
  y = (src %mesh_size);
  port_num = (x/(mesh_size/2))*2+y/(mesh_size/(mem_port_num/2));
  lat = mem_access_latency (bsize) + mem_port_lat[port_num];
  mem_port_lat[port_num] += (bsize*mem_port_num/mem_bus_width)*((float)4/mem_bus_speed);
  return lat;
 }


}


static unsigned int
il1_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



       )
{
 unsigned int lat = 0;
 int matchnum = 0;
    il1_acc_fn_num++;
 if (cache_il2)
 {

  lat = cache_access (cache_il2, cmd, baddr, ((void *)0), bsize, now, ((void *)0), ((void *)0), ((void *)0), threadid , ((void *)0));

  dcache2_access++;
  thecontexts[threadid]->dcache2_access++;

  if (cmd == Read)
   return lat;
  else
   _panic("sim-outorder.c", __FUNCTION__, 1770, "writes to instruction memory not supported");
 }
 else
 {

  if (cmd == Read)
   return mem_access_latency (bsize);
  else
   _panic("sim-outorder.c", __FUNCTION__, 1778, "writes to instruction memory not supported");
 }
 return lat;
}


static unsigned int
il2_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



       )
{ il2_acc_fn_num++;


 int lat = 0;
 if (cmd == Read)
 {
  int src, port_num, x, y;
  src = (baddr >> cache_dl2->set_shift) % numcontexts;
  x = (src /mesh_size);
  y = (src %mesh_size);
  port_num = (x/(mesh_size/2))*2+y/(mesh_size/(mem_port_num/2));
  lat = mem_access_latency (bsize) + mem_port_lat[port_num];
  mem_port_lat[port_num] += (bsize*mem_port_num/mem_bus_width)*((float)4/mem_bus_speed);
  port_accord[port_num] ++;
  return lat;
 }
 else
  _panic("sim-outorder.c", __FUNCTION__, 1812, "writes to instruction memory not supported");
 return 0;
}







static unsigned int
itlb_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



        )
{
 md_addr_t *phy_page_ptr = (md_addr_t *) blk->user_data;


 ((phy_page_ptr) ? (void) (0) : (__assert_fail ("phy_page_ptr", "sim-outorder.c", 1837, __PRETTY_FUNCTION__), (void) (0)));


 *phy_page_ptr = 0;


 return tlb_miss_lat;
}


static unsigned int
dtlb_access_fn (enum mem_cmd cmd,
  md_addr_t baddr,
  int bsize,
  struct cache_blk_t *blk,
  tick_t now,
  int threadid



        )
{
 md_addr_t *phy_page_ptr = (md_addr_t *) blk->user_data;


 ((phy_page_ptr) ? (void) (0) : (__assert_fail ("phy_page_ptr", "sim-outorder.c", 1862, __PRETTY_FUNCTION__), (void) (0)));


 *phy_page_ptr = 0;


 return tlb_miss_lat;
}



 void
sim_reg_options (struct opt_odb_t *odb)
{
 opt_reg_header (odb,
   "sim-outorder: This simulator implements a very detailed out-of-order issue\n"
   "superscalar processor with a two-level memory system and speculative\n" "execution support.  This simulator is a performance simulator, tracking the\n" "latency of all pipeline operations.\n");


 opt_reg_uint (odb, "-max:inst", "maximum number of inst's to execute/thread", (unsigned int *) (&max_insts), 0,
               1, ((void *)0));


 opt_reg_uint (odb, "-max:barrier", "maximum number of barriers to execute", (unsigned int *) (&max_barrier), 0,
               1, ((void *)0));


 opt_reg_int (odb, "-network:meshsize", "mesh size of the network", &mesh_size, 4,
               1, ((void *)0));


 opt_reg_string_list (odb, "-ptrace", "generate pipetrace, i.e., <fname|stdout|stderr> <range>", ptrace_opts, 2, &ptrace_nelt, ((void *)0),
                0, ((void *)0), 0);


 opt_reg_note (odb, "####### Network configuration #######\n");

 opt_reg_note (odb, "Optical interconnect\n");


 opt_reg_note (odb, "Popnet interconnect\n");





 opt_reg_note (odb, "Confirmation based optimazation for Invalidation\n");





 opt_reg_note (odb, "Write back split in network level\n");


 opt_reg_note (odb, "Inorder probability-based scheduling (IRD)\n");
# 1932 "sim-outorder.c"
 opt_reg_note (odb, "Ordering by addr\n");

 opt_reg_note (odb, "###### network configuration end ######\n");

 opt_reg_note (odb,
   "  Pipetrace range arguments are formatted as follows:\n"
   "\n"
   "    {{@|#}<start>}:{{@|#|+}<end>}\n"
   "\n"
   "  Both ends of the range are optional, if neither are specified, the entire\n"
   "  execution is traced.  Ranges that start with a `@' designate an address\n"
   "  range to be traced, those that start with an `#' designate a cycle count\n"
   "  range.  All other range values represent an instruction count range.  The\n"
   "  second argument, if specified with a `+', indicates a value relative\n"
   "  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may\n"
   "  be used in all contexts.\n"
   "\n"
   "    Examples:   -ptrace FOO.trc #0:#1000\n" "                -ptrace BAR.trc @2000:\n" "                -ptrace BLAH.trc :1500\n" "                -ptrace UXXE.trc :\n" "                -ptrace FOOBAR.trc @main:+278\n");


 opt_reg_int (odb, "-fetch:ifqsize", "instruction fetch queue size (in insts)", &ruu_ifq_size, 16,
               1, ((void *)0));

 opt_reg_int (odb, "-fetch:mplat", "extra branch mis-prediction latency", &ruu_branch_penalty, 7,
               1, ((void *)0));

 opt_reg_int (odb, "-fetch:speed", "speed of front-end of machine relative to execution core", &fetch_speed, 1,
               1, ((void *)0));



 opt_reg_note (odb,
   "  Branch predictor configuration examples for 2-level predictor:\n"
   "    Configurations:   N, M, W, X\n"
   "      N   # entries in first level (# of shift register(s))\n"
   "      W   width of shift register(s)\n"
   "      M   # entries in 2nd level (# of counters, or other FSM)\n"
   "      X   (yes-1/no-0) xor history and address for 2nd level index\n"
   "    Sample predictors:\n"
   "      GAg     : 1, W, 2^W, 0\n"
   "      GAp     : 1, W, M (M > 2^W), 0\n" "      PAg     : N, W, 2^W, 0\n" "      PAp     : N, W, M (M == 2^(N+W)), 0\n" "      gshare  : 1, W, 2^W, 1\n" "  Predictor `comb' combines a bimodal and a 2-level predictor.\n");

 opt_reg_string (odb, "-bpred", "branch predictor type {nottaken|taken|perfect|bimod|2lev|comb|2bcgskew}", &pred_type, "comb",
               1, ((void *)0));

 opt_reg_flag (odb, "-bpred:btb_use_masterid", "use masterid in place of threadid when interacting with BTB, giving you per-process instead of per-thread entries", &bpred_btb_use_masterid, 1,
               1, ((void *)0));

 opt_reg_int_list (odb, "-bpred:bimod", "bimodal predictor config (<table size>)", bimod_config, bimod_nelt, &bimod_nelt,
                 bimod_config,
               1, ((void *)0), 0);

 opt_reg_int_list (odb, "-bpred:2lev", "2-level predictor config " "(<l1size> <l2size> <hist_size> <xor>)", twolev_config, twolev_nelt, &twolev_nelt,
                 twolev_config,
               1, ((void *)0), 0);

 opt_reg_int_list (odb, "-bpred:comb", "combining predictor config (<meta_table_size>)", comb_config, comb_nelt, &comb_nelt,
                 comb_config,
               1, ((void *)0), 0);


 opt_reg_int (odb, "-disp1", "2bcgskew table displacement for lev 1", &disp1, 0,
               1, ((void *)0));


 opt_reg_int (odb, "-disp2", "2bcgskew table displacement for lev 2", &disp2, 0,
               1, ((void *)0));


 opt_reg_int_list (odb, "-bpred:2bcgskew", "2Bc-gskew predictor config (<bim_size> <size> <bim_hist_size> <g0_hist_size> <g1_hist_size> <meta_hist_size>)", twobcgskew_config, twobcgskew_nelt, &twobcgskew_nelt,
                 twobcgskew_config,
               1, ((void *)0), 0);


 opt_reg_int (odb, "-bpred:ras", "return address stack size (0 for no return stack)", &ras_size, ras_size,
               1, ((void *)0));

 opt_reg_int_list (odb, "-bpred:btb", "BTB config (<num_sets> <associativity>)", btb_config, btb_nelt, &btb_nelt,
                 btb_config,
               1, ((void *)0), 0);

 opt_reg_string (odb, "-bpred:spec_update", "speculative predictors update in {ID|WB} (default non-spec)", &bpred_spec_opt, ((void *)0),
               1, ((void *)0));
# 2026 "sim-outorder.c"
 opt_reg_int (odb, "-decode:width", "instruction decode B/W (insts/cycle)", &ruu_decode_width, 5,
               1, ((void *)0));



 opt_reg_int (odb, "-thrdf:limit", "Number of thread fetch (thrd/cycle<=8)", &thread_fetch, 8,
               1, ((void *)0));

 opt_reg_int (odb, "-instthrdf:width", "instruction fetch B/w per thread (insts/cycle<=decode_width)", &inst_thread_fetch, 8,
               1, ((void *)0));


 opt_reg_int (odb, "-ipregf:size", "integer physical register file size (per cluster)", &IPREG_size_cluster, 80,
               1, ((void *)0));

 opt_reg_int (odb, "-fpregf:size", "floating point physical register file size (per cluster)", &FPREG_size_cluster, 80,
               1, ((void *)0));

 opt_reg_int (odb, "-iqueue:size", "integer queue size (insts) (per cluster)", &IIQ_size_cluster, 32,
               1, ((void *)0));

 opt_reg_int (odb, "-fqueue:size", "floating point queue size (insts) (per cluster)", &FIQ_size_cluster, 32,
               1, ((void *)0));







 opt_reg_int (odb, "-issue:width", "instruction issue B/W (insts/cluster/cycle)", &ruu_issue_width, 4,
               1, ((void *)0));





 opt_reg_flag (odb, "-issue:inorder", "run pipeline with in-order issue", &ruu_inorder_issue, 0,
               1, ((void *)0));

 opt_reg_flag (odb, "-issue:wrongpath", "issue instructions down wrong execution paths", &ruu_include_spec, 1,
               1, ((void *)0));


 opt_reg_int (odb, "-commit:width", "instruction commit B/W (insts/thread/cycle)", &ruu_commit_width, 4,
               1, ((void *)0));


 opt_reg_int (odb, "-ruu:size", "register update unit (RUU) size", &RUU_size, 16,
               1, ((void *)0));


 opt_reg_int (odb, "-lsq:size", "load/store queue (LSQ) size (per cluster)", &LSQ_size_cluster, 8,
               1, ((void *)0));

 opt_reg_int (odb, "-lq:size", "load queue (LQ) size", &m_shLQSize, 8,
               1, ((void *)0));

 opt_reg_int (odb, "-sq:size", "store queue (SQ) size", &m_shSQSize, 8,
               1, ((void *)0));

 opt_reg_float (odb, "-checker:vdd", "checker vdd", &checkerVDD, 0.6,
               1, ((void *)0));

 opt_reg_float (odb, "-checker:freq", "checker running at what fraction of full freq", &checkerFreq, 0.5,
               1, ((void *)0));


 opt_reg_note (odb,
   "  The cache config parameter <config> has the following format:\n"
   "\n"
   "    <name>:<nsets>:<bsize>:<assoc>:<repl>\n"
   "\n"
   "    <name>   - name of the cache being defined\n"
   "    <nsets>  - number of sets in the cache\n"
   "    <bsize>  - block size of the cache\n"
   "    <assoc>  - associativity of the cache\n" "    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random\n" "\n" "    Examples:   -cache:dl1 dl1:4096:32:1:l\n" "                -dtlb dtlb:128:4096:32:r\n");


 opt_reg_string (odb, "-cache:dl1", "l1 data cache config, i.e., {<config>|none} (each cluster)", &cache_dl1_opt, "dl1:128:32:4:l",
               1, ((void *)0));

 opt_reg_int (odb, "-cache:dl1lat", "l1 data cache hit latency (in cycles)", &cache_dl1_lat, 1,
               1, ((void *)0));

 opt_reg_string (odb, "-cache:dl2", "l2 data cache config, i.e., {<config>|none}", &cache_dl2_opt, "ul2:1024:64:4:l",
               1, ((void *)0));

 opt_reg_int (odb, "-cache:dl2lat", "l2 data cache hit latency (in cycles)", &cache_dl2_lat, 6,
               1, ((void *)0));





 opt_reg_string (odb, "-cache:il1", "l1 inst cache config, i.e., {<config>|dl1|dl2|none}", &cache_il1_opt, "il1:512:32:1:l",
               1, ((void *)0));

 opt_reg_note (odb,
   "  Cache levels can be unified by pointing a level of the instruction cache\n"
   "  hierarchy at the data cache hiearchy using the \"dl1\" and \"dl2\" cache\n"
   "  configuration arguments.  Most sensible combinations are supported, e.g.,\n"
   "\n"
   "    A unified l2 cache (il2 is pointed at dl2):\n"
   "      -cache:il1 il1:128:64:1:l -cache:il2 dl2\n"
   "      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l\n"
   "\n" "    Or, a fully unified cache hierarchy (il1 pointed at dl1):\n" "      -cache:il1 dl1\n" "      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l\n");

 opt_reg_int (odb, "-cache:il1lat", "l1 instruction cache hit latency (in cycles)", &cache_il1_lat, 1,
               1, ((void *)0));

 opt_reg_string (odb, "-cache:il2", "l2 instruction cache config, i.e., {<config>|dl2|none}", &cache_il2_opt, "dl2",
               1, ((void *)0));

 opt_reg_int (odb, "-cache:il2lat", "l2 instruction cache hit latency (in cycles)", &cache_il2_lat, 6,
               1, ((void *)0));





 opt_reg_flag (odb, "-cache:flush", "flush caches on system calls", &flush_on_syscalls, 0, 1, ((void *)0));

 opt_reg_flag (odb, "-cache:icompress", "convert 64-bit inst addresses to 32-bit inst equivalents", &compress_icache_addrs, 0,
               1, ((void *)0));


 opt_reg_int_list (odb, "-mem:lat", "memory access latency (<first_chunk> <inter_chunk>)", mem_lat, mem_nelt, &mem_nelt, mem_lat,
               1, ((void *)0), 0);

 opt_reg_int (odb, "-mem:width", "memory access bus width (in bytes)", &mem_bus_width, 32,
               1, ((void *)0));
 opt_reg_float (odb, "-mem:speed", "memory access bus speed (in GHz)", &mem_bus_speed, 1,
               1, ((void *)0));
 opt_reg_int (odb, "-mem:ports", "memory access port number", &mem_port_num, 4,
               1, ((void *)0));


 opt_reg_string (odb, "-tlb:itlb", "instruction TLB config, i.e., {<config>|none}", &itlb_opt, "itlb:16:4096:4:l", 1, ((void *)0));

 opt_reg_string (odb, "-tlb:dtlb", "data TLB config, i.e., {<config>|none}", &dtlb_opt, "dtlb:32:4096:4:l", 1, ((void *)0));

 opt_reg_int (odb, "-tlb:lat", "inst/data TLB miss latency (in cycles)", &tlb_miss_lat, 30,
               1, ((void *)0));





 opt_reg_int (odb, "-network:rec_algr", "receiver algorism for network", &network_receiver, 0,
               1, ((void *)0));
 opt_reg_int (odb, "-network:net_algr", "confliction algorism for network", &network_conflict, 0,
               1, ((void *)0));



 opt_reg_int (odb, "-res:ialu", "total number of integer ALU's available (per cluster)", &res_ialu_cluster, fu_config[0].quantity,
               1, ((void *)0));


 opt_reg_int (odb, "-res:imult", "total number of integer multiplier/dividers available (per cluster)", &res_imult_cluster, fu_config[1].quantity,
               1, ((void *)0));


 opt_reg_int (odb, "-maxThrds", "Maximum Number of Threads Allowed", &mta_maxthreads, 1, 1, ((void *)0));

 opt_reg_flag (odb, "-Coherent_Cache", "Coherent Cache", &COHERENT_CACHE, 1, 1, ((void *)0));

 opt_reg_flag (odb, "-MSI_prot", "MSI Protocol", &MSI, 0, 1, ((void *)0));

 opt_reg_flag (odb, "-SPEC", "SPEC Benchmarks", &spec_benchmarks, 1, 1, ((void *)0));


 opt_reg_int (odb, "-res:membank", "number of data cache banks available (per Cluster to CPU)", &res_membank_cluster, 2,
               1, ((void *)0));

 opt_reg_int (odb, "-res:memport", "total number of memory system ports available (per bank)", &res_mem_port_bank, 1,
               1, ((void *)0));





 opt_reg_int (odb, "-res:fpalu", "total number of floating point ALU's available (per cluster)", &res_fpalu_cluster, fu_config[3].quantity,
               1, ((void *)0));


 opt_reg_int (odb, "-res:fpmult", "total number of floating point multiplier/dividers available (per cluster)", &res_fpmult_cluster, fu_config[4].quantity,
               1, ((void *)0));


 opt_reg_string_list (odb, "-pcstat", "profile stat(s) against text addr's (mult uses ok)", pcstat_vars, 8, &pcstat_nelt, ((void *)0),
                0, ((void *)0), 1);

 opt_reg_flag (odb, "-bugcompat", "operate in backward-compatible bugs mode (for testing only)", &bugcompat_mode, 0, 1, ((void *)0));

 opt_reg_int (sim_odb, "-hotspot:sampling_intvl", "how many cycles between calls to update_hotspot_stats", &hotspot_cycle_sampling_intvl,
                 10000, 0, ((void *)0));

 opt_reg_int (odb, "-ray:disabled", "ray active", &disable_ray, 1,
               1, ((void *)0));

 cluster_reg_options (odb);
 hotspot_reg_options (odb);


 network_reg_options (odb);
}


 void
sim_check_options (struct opt_odb_t *odb,
  int argc, char **argv)
{
 char name[128], c;
 int nsets, bsize, assoc;

 int i;
 context *current;
# 2262 "sim-outorder.c"
 if (ruu_issue_width < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2263, "issue width must be positive non-zero");







 IIQ_size = IIQ_size_cluster;
 FIQ_size = FIQ_size_cluster;
 IPREG_size = IPREG_size_cluster;
 FPREG_size = FPREG_size_cluster;

 p_total_regs = IPREG_size + FPREG_size + 1;

 if (IIQ_size < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2279, "integer queue must be positive non-zero and a power of two");

 if (FIQ_size < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2282, "floating point queue must be positive non-zero and a power of two");





 if (IPREG_size < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2289, "integer physical register file must be positive non-zero and a power of two");

 if (FPREG_size < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2292, "floating point physical register file must be positive non-zero and a power of two");







 if (ruu_commit_width < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2301, "commit width must be positive non-zero");

 if (RUU_size < 2 || (RUU_size > 1024))
  _fatal("sim-outorder.c", __FUNCTION__, 2304, "RUU size must be a positive number > 1 and < %d", 1024);

 LSQ_size = LSQ_size_cluster;

 if (LSQ_size < 2 || (LSQ_size > 1024))
  _fatal("sim-outorder.c", __FUNCTION__, 2309, "LSQ size must be a positive number > 1 and < %d", 1024);



 if (!mystricmp (cache_dl1_opt, "none"))
 {

  if (strcmp (cache_dl2_opt, "none"))
   _fatal("sim-outorder.c", __FUNCTION__, 2317, "the l1 data cache must defined if the l2 cache is defined");
  cache_dl2 = ((void *)0);
 }
 else
 {
  if (sscanf (cache_dl1_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
   _fatal("sim-outorder.c", __FUNCTION__, 2323, "bad l1 D-cache parms: <name>:<nsets>:<bsize>:<assoc>:<repl>");

  for (i = 0; i < 64; i++)
  {
   cache_dl1[i] = cache_create (name, nsets, bsize, 1,
                 0, assoc, cache_char2policy (c),
     dl1_access_fn, cache_dl1_lat, i);





  }
  cache_dl1_set_shift = cache_dl1[0]->set_shift;
  original_bsize = bsize;

  if (!mystricmp (cache_dl2_opt, "none"))
   cache_dl2 = ((void *)0);
  else
  {
   if (sscanf (cache_dl2_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
    _fatal("sim-outorder.c", __FUNCTION__, 2344, "bad l2 D-cache parms: " "<name>:<nsets>:<bsize>:<assoc>:<repl>");

   cache_dl2 = cache_create (name, nsets, bsize, 1,
                 0, assoc, cache_char2policy (c),
     dl2_access_fn, cache_dl2_lat, -1);
  }
 }


 if (!mystricmp (cache_il1_opt, "none"))
 {
  cache_il1[0] = ((void *)0);


  if (strcmp (cache_il2_opt, "none"))
   _fatal("sim-outorder.c", __FUNCTION__, 2359, "the l1 inst cache must defined if the l2 cache is defined");
  cache_il2 = ((void *)0);
 }
 else if (!mystricmp (cache_il1_opt, "dl1"))
 {

  if (strcmp (cache_il2_opt, "none"))
   _fatal("sim-outorder.c", __FUNCTION__, 2366, "the l1 inst cache must defined if the l2 cache is defined");
  cache_il2 = ((void *)0);
 }
 else if (!mystricmp (cache_il1_opt, "dl2"))
 {
  if (!cache_dl2)
   _fatal("sim-outorder.c", __FUNCTION__, 2372, "I-cache l1 cannot access D-cache l2 as it's undefined");
  cache_il1[0] = cache_dl2;


  if (strcmp (cache_il2_opt, "none"))
   _fatal("sim-outorder.c", __FUNCTION__, 2377, "the l1 inst cache must defined if the l2 cache is defined");
  cache_il2 = ((void *)0);
 }
 else
 {
  if (sscanf (cache_il1_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
   _fatal("sim-outorder.c", __FUNCTION__, 2383, "bad l1 I-cache parms: <name>:<nsets>:<bsize>:<assoc>:<repl>");

  for (i = 0; i < 64; i++)
  {
   cache_il1[i] = cache_create (name, nsets, bsize, 0,
                 0, assoc, cache_char2policy (c),
     il1_access_fn, cache_il1_lat, i);
  }

  if (!mystricmp (cache_il2_opt, "none"))
   cache_il2 = ((void *)0);
  else if (!mystricmp (cache_il2_opt, "dl2"))
  {
   if (!cache_dl2)
    _fatal("sim-outorder.c", __FUNCTION__, 2397, "I-cache l2 cannot access D-cache l2 as it's undefined");
   cache_il2 = cache_dl2;
  }
  else
  {
   if (sscanf (cache_il2_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
    _fatal("sim-outorder.c", __FUNCTION__, 2403, "bad l2 I-cache parms: " "<name>:<nsets>:<bsize>:<assoc>:<repl>");

   cache_il2 = cache_create (name, nsets, bsize, 0,
                 0, assoc, cache_char2policy (c),
     il2_access_fn, cache_il2_lat, -1);
  }
 }


 for (i = 0; i < 64; i++)
 {
  if (sscanf (itlb_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
   _fatal("sim-outorder.c", __FUNCTION__, 2415, "bad TLB parms: <name>:<nsets>:<page_size>:<assoc>:<repl>");

  itlb[i] = cache_create (name, nsets, bsize, 0,
                sizeof (md_addr_t), assoc,
    cache_char2policy (c), itlb_access_fn,
                      1, i);
 }

 for (i = 0; i < 64; i++)
 {
  if (sscanf (dtlb_opt, "%[^:]:%d:%d:%d:%c", name, &nsets, &bsize, &assoc, &c) != 5)
   _fatal("sim-outorder.c", __FUNCTION__, 2426, "bad TLB parms: <name>:<nsets>:<page_size>:<assoc>:<repl>");
  dtlb[i] = cache_create (name, nsets, bsize, 0,
                sizeof (md_addr_t), assoc,
    cache_char2policy (c), dtlb_access_fn,
                      1, i);
 }

 if (cache_dl1_lat < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2434, "l1 data cache latency must be greater than zero");

 if (cache_dl2_lat < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2437, "l2 data cache latency must be greater than zero");

 if (cache_il1_lat < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2440, "l1 instruction cache latency must be greater than zero");

 if (cache_il2_lat < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2443, "l2 instruction cache latency must be greater than zero");

 if (mem_nelt != 2)
  _fatal("sim-outorder.c", __FUNCTION__, 2446, "bad memory access latency (<first_chunk> <inter_chunk>)");

 if (mem_lat[0] < 1 || mem_lat[1] < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2449, "all memory access latencies must be greater than zero");

 if (mem_bus_width < 1 || (mem_bus_width & (mem_bus_width - 1)) != 0)
  _fatal("sim-outorder.c", __FUNCTION__, 2452, "memory bus width must be positive non-zero and a power of two");

 if (tlb_miss_lat < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2455, "TLB miss latency must be greater than zero");

 res_ialu = res_ialu_cluster * 64;

 if (res_ialu < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2460, "number of integer ALU's must be greater than zero");
 if (res_ialu > 1024)
  _fatal("sim-outorder.c", __FUNCTION__, 2462, "number of integer ALU's must be <= MAX_INSTS_PER_CLASS");

 fu_config[0].quantity = res_ialu;


 res_imult = res_imult_cluster * 64;
 if (res_imult < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2469, "number of integer multiplier/dividers must be greater than zero");
 if (res_imult > 1024)
  _fatal("sim-outorder.c", __FUNCTION__, 2471, "number of integer mult/div's must be <= MAX_INSTS_PER_CLASS");
 fu_config[1].quantity = res_imult;



 res_membank = res_membank_cluster * 64;

 if (res_membank < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2479, "number of memory system banks must be greater than zero");



 lsq_part_bank = res_membank / 64;

 if (res_mem_port_bank < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2486, "number of memory system ports/bank must be greater than zero");
 if (res_mem_port_bank * res_membank > 1024)
  _fatal("sim-outorder.c", __FUNCTION__, 2488, "number of total memory system ports must be <= MAX_INSTS_PER_CLASS");
 if (res_mem_port_bank * res_membank > 512)
  _fatal("sim-outorder.c", __FUNCTION__, 2490, "number of total memory system ports must be <= MAXCACHEPORTS");
 fu_config[2].quantity = res_memport = res_mem_port_bank * res_membank;
# 2500 "sim-outorder.c"
 res_fpalu = res_fpalu_cluster * 64;
 if (res_fpalu < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2502, "number of floating point ALU's must be greater than zero");
 if (res_fpalu > 1024)
  _fatal("sim-outorder.c", __FUNCTION__, 2504, "number of floating point ALU's must be <= MAX_INSTS_PER_CLASS");
 fu_config[3].quantity = res_fpalu;


 res_fpmult = res_fpmult_cluster * 64;
 if (res_fpmult < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 2510, "number of floating point multiplier/dividers must be > zero");
 if (res_fpmult > 1024)
  _fatal("sim-outorder.c", __FUNCTION__, 2512, "number of FP mult/div's must be <= MAX_INSTS_PER_CLASS");
 fu_config[4].quantity = res_fpmult;







 network_check_options ();
 cluster_check_options ();
 init_link_descr_tables ();
 init_routing_table ();
 arbitrary_routing_table_init ();
}


 void
sim_aux_config (FILE * stream)
{

}


counter_t totalUpgrades = 0;
counter_t totalNetUpgrades = 0;
counter_t totalUpgradesUsable = 0;
counter_t totalUpgradesBeneficial = 0;
counter_t lock_network_access = 0;


counter_t req_spand[261];
counter_t spand[5];
counter_t downgrade_w, downgrade_r;

extern counter_t sharer_distr[64];
extern counter_t total_corner_packets, total_neighbor_packets, total_far_packets;

counter_t totalNetWrites = 0;
counter_t totalWritesUsable = 0;
counter_t totalWritesBeneficial = 0;
counter_t exclusive_somewhere = 0;
counter_t front_write = 0;




counter_t totalL2WriteReqHits = 0;
counter_t totalL2WriteReqNoSharer = 0;
counter_t totalL2WriteReqDirty = 0;
counter_t delayL2WriteReqDirty = 0;
counter_t totalL2WriteReqShared = 0;
counter_t delayL2WriteReqShared = 0;

counter_t totalL2ReadReqHits = 0;
counter_t totalL2ReadReqNoSharer = 0;
counter_t totalL2ReadReqDirty = 0;
counter_t delayL2ReadReqDirty = 0;

counter_t totalL2ReadReqShared = 0;
counter_t totalL2WriteReqSharedWT = 0;
counter_t totalL2WriteReqDirtyWT = 0;
counter_t totalL2ReadReqDirtyWT = 0;

counter_t totalL1LinePrefUse = 0;
counter_t totalL1LinePrefNoUse = 0;
counter_t totalL1LineReadUse = 0;
counter_t totalL1LineReadNoUse = 0;
counter_t totalL1LineWriteUse = 0;
counter_t totalL1LineWriteNoUse = 0;

counter_t totalL1LineExlUsed = 0;
counter_t totalL1LineExlInv = 0;
counter_t totalL1LineExlDrop = 0;

counter_t totalL2ReqPrimMiss = 0;
counter_t totalL2ReqSecMiss = 0;
counter_t totalL2ReqHit = 0;
counter_t totalL2ReqInTrans = 0;
counter_t totalL2OwnReqInTrans = 0;
counter_t totalL2ReqInInv = 0;

counter_t delayL2ReqPrimMiss = 0;
counter_t delayL2ReqSecMiss = 0;
counter_t delayL2ReqHit = 0;
counter_t delayL2ReqInTrans = 0;
counter_t delayL2OwnReqInTrans = 0;
counter_t delayL2ReqInInv = 0;

counter_t totalWriteReq = 0;
counter_t totalWriteReqInv = 0;
counter_t totalWriteDelay = 0;
counter_t totalWriteInvDelay = 0;
counter_t totalUpgradeReq = 0;
counter_t totalUpgradeReqInv = 0;
counter_t totalUpgradeDelay = 0;
counter_t totalUpgradeInvDelay = 0;

counter_t countNonAllocReadEarly = 0;


 void
sim_reg_stats (struct stat_sdb_t *sdb)
{
 int i, j;


 stat_reg_sqword (sdb, "sim_num_insn", "total number of instructions committed not including consistency replay instructions", &sim_num_insn, sim_num_insn, ((void *)0));
 stat_reg_sqword (sdb, "pure_num_insn", "total number of instructions committed not including synchronization instructions", &pure_num_insn, pure_num_insn, ((void *)0));
 stat_reg_sqword (sdb, "total_num_insn", "total number of instructions committed including synchronization instructions", &total_num_insn, total_num_insn, ((void *)0));
 stat_reg_sqword (sdb, "TotalBarriers", "total number of barriers", &TotalBarriers, 0, ((void *)0));
 stat_reg_sqword (sdb, "TotalLocks", "total number of locks", &TotalLocks, 0, ((void *)0));
 stat_reg_sqword (sdb, "sim_num_refs", "total number of loads and stores committed", &sim_num_refs, 0, ((void *)0));
 stat_reg_sqword (sdb, "sim_num_loads", "total number of loads committed", &sim_num_loads, 0, ((void *)0));
 stat_reg_formula (sdb, "sim_num_stores", "total number of stores committed", "sim_num_refs - sim_num_loads", ((void *)0));
 stat_reg_sqword (sdb, "sim_num_branches", "total number of branches committed", &sim_num_branches, 0, ((void *)0));
 stat_reg_int (sdb, "sim_elapsed_time", "total simulation time in seconds", &sim_elapsed_time, 0, ((void *)0));
 stat_reg_formula (sdb, "sim_inst_rate", "simulation speed (in insts/sec)", "sim_num_insn / sim_elapsed_time", ((void *)0));
 stat_reg_sqword (sdb, "sim_total_insn", "total number of instructions executed", &sim_total_insn, 0, ((void *)0));
 stat_reg_sqword (sdb, "sim_total_refs", "total number of loads and stores executed", &sim_total_refs, 0, ((void *)0));
 stat_reg_sqword (sdb, "sim_total_loads", "total number of loads executed", &sim_total_loads, 0, ((void *)0));
 stat_reg_formula (sdb, "sim_total_stores", "total number of stores executed", "sim_total_refs - sim_total_loads", ((void *)0));
 stat_reg_sqword (sdb, "sim_total_branches", "total number of branches executed", &sim_total_branches, 0, ((void *)0));

 stat_reg_sqword (sdb, "sim_cycle", "total simulation time in cycles", &sim_cycle, 0, ((void *)0));
 stat_reg_sqword (sdb, "realSimCycle", "", &realSimCycle, 0, ((void *)0));
 stat_reg_formula (sdb, "sim_IPC", "instructions per cycle", "sim_num_insn / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "realSimIPC", "", "pure_num_insn / realSimCycle", ((void *)0));
 stat_reg_formula (sdb, "mainEffectiveIPC", "", "pure_num_insn / (realSimCycle - main_thread_stall_count)", ((void *)0));
 stat_reg_sqword (sdb, "num_of_invalidations", "Number_Of_Validations", &num_of_invalidations, 0, ((void *)0));







 stat_reg_formula (sdb, "sim_CPI", "cycles per instruction", "sim_cycle / sim_num_insn", ((void *)0));
 stat_reg_formula (sdb, "sim_exec_BW", "total instructions (mis-spec + committed) per cycle", "sim_total_insn / sim_cycle", ((void *)0));
 stat_reg_sqword (sdb, "ldIssueCount", "total ld issue attmept", &ldIssueCount, 0, ((void *)0));

 char ch2[32];

 for (i = 0; i < numcontexts; i++)
 {
  sprintf (ch2, "pullbackCycleCnt_%d", i);
  stat_reg_sqword (sdb, ch2, "", &pullbackCycleCount[i], 0, ((void *)0));
 }

 stat_reg_sqword (sdb, "max_lsq_num", "", &LSQ_NUM_MORE_THAN_TWO, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_counts", "total num of data packets in all", &TotalDataPacketsInAll, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_meta_counts", "total num of meta packets in all", &TotalMetaPacketsInAll, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_sync_counts", "total num of data sync packets in all", &TotalSyncDataPackets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_meta_sync_counts", "total num of meta sync packets in all", &TotalSyncMetaPackets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_optical_data_counts", "total num of data packets in optical network", &optical_data_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_optical_meta_counts", "total num of meta packets in optical network", &optical_meta_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_mesh_data_counts", "total num of data packets in mesh network", &mesh_data_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_mesh_meta_counts", "total num of meta packets in mesh network", &mesh_meta_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_writeup", "total num of event inital created", &totalSyncWriteup, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_writemiss", "total num of event inital created", &totalSyncWriteM, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_readmiss", "total num of event inital created", &totalSyncReadM, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_normal_event_count", "total num of event inital created", &totalNormalEvent, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_event_count", "total num of event inital created", &totalSyncEvent, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_event_count", "total num of event inital created", &totaleventcountnum, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_write_indicate", "", &totalWriteIndicate, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_exclusive_modified", "", &total_exclusive_modified, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_exclusive_conf", "", &total_exclusive_conf, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_exclusive_cross", "", &total_exclusive_cross, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_wb_early", "total num of event created due to L1 prefetch", &write_back_early, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l1_count", "total num of event created due to L1 prefetch", &total_L1_prefetch, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l2_count", "total num of event created due to L2 prefetch", &l2_prefetch_num, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l1_first_count", "total num of event created due to L1 prefetch", &total_L1_first_prefetch, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l1_sec_count", "total num of event created due to L1 prefetch", &total_L1_sec_prefetch, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l1_usefull", "total num of usefull L1 prefetch", &L1_prefetch_usefull, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_l1_writeafter", "total num of usefull L1 prefetch", &L1_prefetch_writeafter, 0, ((void *)0));

    stat_reg_sqword (sdb, "total_l1_prefetches", "total call times of l1launch_sp()", &l1launch_sp_access, 0, ((void *)0));
    stat_reg_sqword (sdb, "total_l2_prefetches", "total call times of launch_sp()", &launch_sp_access, 0, ((void *)0));
    stat_reg_sqword (sdb, "dl1_acc_fn_times", "total call times of dl1_access_fn()", &dl1_acc_fn_num, 0, ((void *)0));
    stat_reg_sqword (sdb, "dl2_acc_fn_times", "total call times of dl2_access_fn()", &dl2_acc_fn_num, 0, ((void *)0));
    stat_reg_sqword (sdb, "il1_acc_fn_times", "total call times of il1_access_fn()", &il1_acc_fn_num, 0, ((void *)0));
    stat_reg_sqword (sdb, "il2_acc_fn_times", "total call times of il2_access_fn()", &il2_acc_fn_num, 0, ((void *)0));
# 2712 "sim-outorder.c"
 stat_reg_sqword (sdb, "total_req_event_count", "total num of request event inital created", &totalreqcountnum, 0, ((void *)0));
 stat_reg_sqword (sdb, "StoreConditionFailNum", "Total store conditional failed num", &StoreConditionFailNum, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_network_access", "", &lock_network_access, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgrades", "total number of upgrades seen", &totalUpgrades, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_miss_event_count", "total num of miss event intial created", &totalmisscountnum, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalNetUpgrades", "total number of upgrades seen", &totalNetUpgrades, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradesUsable", "total number of upgrades not usable", &totalUpgradesUsable, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradesBeneficial", "total number of upgrades not usable", &totalUpgradesBeneficial, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradesUse2", "total number of upgrades usable without confirmation", &totalSplitNo, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalSyncdata", "total number of data packets due to sync", &data_packets_sync, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalSyncmeta", "total number of meta packets due to sync", &meta_packets_sync, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalNetWrites", "total number of Writes seen", &totalNetWrites, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWritesUsable", "total number of Writes not usable", &totalWritesUsable, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWritesBeneficial", "total number of Writes not usable", &totalWritesBeneficial, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWritesUse2", "total number of Writes usable without confirmation", &totalSplitWM, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalNoExclusive", "total number of Writes unusable because of exclusive somewhere else", &exclusive_somewhere, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalFrontWrite", "total number of Writes unusavle because of front write", &front_write, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalL2WriteReqHits", "total num of write events", &totalL2WriteReqHits, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2WriteReqNoSharer", "total num of write req with no sharers", &totalL2WriteReqNoSharer, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2WriteReqDirty", "total  num of write req with just one sharer", &totalL2WriteReqDirty, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2WriteReqDirty", "Extra delay to complete write req with just one sharer, in case the earlier write would had been write through", &delayL2WriteReqDirty, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2WriteReqDirtyWT", "total times write req with just one sharer, in case the earlier write would had been write through", &totalL2WriteReqDirtyWT, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2WriteReqShared", "total num of write req with multiple sharers", &totalL2WriteReqShared, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2WriteReqShared", "Extra delay to complete write req with multiple sharers, in case earlier reads would had been read through", &delayL2WriteReqShared, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2WriteReqSharedWT", "total times write req with multiple sharers, in case earlier reads would had been read through", &totalL2WriteReqSharedWT, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalL2ReadReqHits", "total num of Read events", &totalL2ReadReqHits, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReadReqNoSharer", "total num of Read req with no sharers", &totalL2ReadReqNoSharer, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReadReqDirty", "total  num of Read req with just one sharer", &totalL2ReadReqDirty, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2ReadReqDirty", "Extra delay to complete Read req with just one sharer, in case the earlier write would had been write through", &delayL2ReadReqDirty, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReadReqDirtyWT", "total times Read req with just one sharer, in case the earlier write would had been write through", &totalL2ReadReqDirtyWT, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReadReqShared", "total num of read req with multiple sharers", &totalL2ReadReqShared, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalL1LinePrefUse", "total L1 line prefetches useful", &totalL1LinePrefUse, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LinePrefNoUse", "total L1 line prefetches not useful", &totalL1LinePrefNoUse, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineReadUse", "total L1 line read misses useful", &totalL1LineReadUse, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineReadNoUse", "total L1 line read misses not useful", &totalL1LineReadNoUse, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineWriteUse", "total L1 line write misses useful", &totalL1LineWriteUse, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineWriteNoUse", "total L1 line write misses not useful", &totalL1LineWriteNoUse, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalL1LineExlUsed", "total L1 line in exclusive mode useful", &totalL1LineExlUsed, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineExlInv", "total L1 line in exclusive mode invalidated without use", &totalL1LineExlInv, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL1LineExlDrop", "total L1 line in exclusive mode droped without use", &totalL1LineExlDrop, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalL2ReqPrimMiss", "Total number of directory requests involve in primary miss", &totalL2ReqPrimMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReqSecMiss", "Total number of directory requests involve in secondary miss", &totalL2ReqSecMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReqHit", "Total number of directory requests involve in clean hit", &totalL2ReqHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReqInTrans", "Total number of directory requests find line in transition", &totalL2ReqInTrans, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2OwnReqInTrans", "Total number of directory ownership requests find line in transition", &totalL2OwnReqInTrans, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalL2ReqInInv", "Total number of directory requests have to invalidate", &totalL2ReqInInv, 0, ((void *)0));

 stat_reg_sqword (sdb, "delayL2ReqPrimMiss", "delay of Total number of directory requests involve in primary miss", &delayL2ReqPrimMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2ReqSecMiss", "delay of Total number of directory requests involve in secondary miss", &delayL2ReqSecMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2ReqHit", "delay of Total number of directory requests involve in clean hit", &delayL2ReqHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2ReqInTrans", "delay of Total number of directory requests find line in transition", &delayL2ReqInTrans, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2OwnReqInTrans", "delay of Total number of directory ownership requests find line in transition", &delayL2OwnReqInTrans, 0, ((void *)0));
 stat_reg_sqword (sdb, "delayL2ReqInInv", "delay of Total number of directory requests have to invalidate", &delayL2ReqInInv, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalWriteReq", "Total number of write request to L2", &totalWriteReq, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWriteReqInv", "Total number of write requests with invalidations to L2", &totalWriteReqInv, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWriteDelay", "Time spent in write requests to L2", &totalWriteDelay, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalWriteInvDelay", "Time spent in invalidation for write requests to L2", &totalWriteInvDelay, 0, ((void *)0));

 stat_reg_sqword (sdb, "totalUpgradeReq", "Total number of write request to L2", &totalUpgradeReq, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradeReqInv", "Total number of write requests with invalidations to L2", &totalUpgradeReqInv, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradeDelay", "Time spent in write requests to L2", &totalUpgradeDelay, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradeInvDelay", "Time spent in invalidation for write requests to L2", &totalUpgradeInvDelay, 0, ((void *)0));
 stat_reg_sqword (sdb, "totalUpgradeDependDelay", "Time spent in depend delay for update requests to L2", &UpdateDependCycle, 0, ((void *)0));

 stat_reg_sqword (sdb, "countNonAllocReadEarly", "Number of times a read miss request from L1 has been serviced early without allocation", &countNonAllocReadEarly, 0, ((void *)0));





 stat_reg_sqword (sdb, "WM_Miss", "", &WM_Miss, 0, ((void *)0));
 stat_reg_sqword (sdb, "WM_Clean", "", &WM_Clean, 0, ((void *)0));
 stat_reg_sqword (sdb, "WM_S", "", &WM_S, 0, ((void *)0));
 stat_reg_sqword (sdb, "WM_EM", "", &WM_EM, 0, ((void *)0));
 stat_reg_sqword (sdb, "WM_ShardUseConf", "", &write_shared_used_conf, 0, ((void *)0));

 stat_reg_sqword (sdb, "Sync_L2_miss", "", &Sync_L2_miss, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncInstCacheAccess", "", &SyncInstCacheAccess, 0, ((void *)0));
 stat_reg_sqword (sdb, "TestCacheAccess", "", &TestCacheAccess, 0, ((void *)0));
 stat_reg_sqword (sdb, "TestSecCacheAccess", "", &TestSecCacheAccess, 0, ((void *)0));
 stat_reg_sqword (sdb, "SetCacheAccess", "", &SetCacheAccess, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncLoadReadMiss", "", &SyncLoadReadMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncLoadLReadMiss", "", &SyncLoadLReadMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncLoadHit", "", &SyncLoadHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncLoadLHit", "", &SyncLoadLHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreCHit", "", &SyncStoreCHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreCWriteMiss", "", &SyncStoreCWriteMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreCWriteUpgrade", "", &SyncStoreCWriteUpgrade, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreHit", "", &SyncStoreHit, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreWriteMiss", "", &SyncStoreWriteMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "SyncStoreWriteUpgrade", "", &SyncStoreWriteUpgrade, 0, ((void *)0));
 stat_reg_sqword (sdb, "BarStoreWriteMiss", "", &BarStoreWriteMiss, 0, ((void *)0));
 stat_reg_sqword (sdb, "BarStoreWriteUpgrade", "", &BarStoreWriteUpgrade, 0, ((void *)0));
 stat_reg_formula (sdb, "test_hit_ratio", "", "SyncLoadHit / TestCacheAccess", ((void *)0));
 stat_reg_formula (sdb, "test_sec_hit_ratio", "", "SyncLoadLHit / TestSecCacheAccess", ((void *)0));
 stat_reg_formula (sdb, "set_hit_ratio", "", "SyncStoreCHit / SetCacheAccess", ((void *)0));

 stat_reg_sqword (sdb, "lock_fifo_full", "total number of lock fifo overflow", &lock_fifo_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_fifo_wrong", "total number of lock fifo overflow", &lock_fifo_wrong, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_fifo_writeback", "total number of lock fifo overflow", &lock_fifo_writeback, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_fifo_benefit", "total number of lock fifo benefit", &lock_fifo_benefit, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_cache_hit", "total number of lock fifo benefit", &lock_cache_hit, 0, ((void *)0));
 stat_reg_sqword (sdb, "lock_cache_miss", "total number of lock fifo benefit", &lock_cache_miss, 0, ((void *)0));
 stat_reg_sqword (sdb, "L1_mshr_full", "total number of L1 mshr overflow", &L1_mshr_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_L1_mshr", "total stall cycles for L1 mshr overflow", &Stall_L1_mshr, 0, ((void *)0));
 stat_reg_sqword (sdb, "L2_mshr_full", "total number of L2 mshr overflow", &L2_mshr_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_L2_mshr", "total stall cycles for L2 mshr overflow", &Stall_L2_mshr, 0, ((void *)0));
 stat_reg_sqword (sdb, "L2_mshr_full_prefetch", "total number of L2 mshr overflow when prefetch", &L2_mshr_full_prefetch, 0, ((void *)0));
 stat_reg_sqword (sdb, "L1_fifo_full", "total number of L1 fifo overflow", &L1_fifo_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_L1_fifo", "total stall cycles for L1 fifo overflow", &Stall_L1_fifo, 0, ((void *)0));
 stat_reg_sqword (sdb, "Dir_fifo_full", "total number of dir fifo overflow", &Dir_fifo_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_dir_fifo", "total stall cycles for dir fifo overflow", &Stall_dir_fifo, 0, ((void *)0));
 stat_reg_sqword (sdb, "Input_queue_full", "total number of input queue overflow", &Input_queue_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Output_queue_full", "total number of output queue overflow", &Output_queue_full, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_input_queue", "total stall cycles due to input queue overflow", &Stall_input_queue, 0, ((void *)0));
 stat_reg_sqword (sdb, "Stall_output_queue", "total stall cycles due to output queue overflow", &Stall_output_queue, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_load_link_shared", "total load link shared", &load_link_shared, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_load_link_exclusive", "total load link shared", &load_link_exclusive, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_normal_miss_handle_time", "total time of handling the missing", &totalmisstimeforNormal, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_miss_handle_time", "total time of handling the missing", &totalmisstimeforSync, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_L2_miss_handle_time", "total time of handling the missing", &totalL2misstime, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_Wrong_L2_miss_handle_time", "total time of handling the missing", &totalWrongL2misstime, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_L2_misses", "total time of handling the missing", &TotalL2misses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_mem_lat", "total time of handling the missing", &total_mem_lat, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_mem_access", "total time of handling the missing", &total_mem_access, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_miss_handle_time", "total time of handling the missing", &totalmisshandletime, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_nack_count", "total num of nack messages sending", &nack_counter, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_prefetch_nack_count", "total num of nack messages sending", &prefetch_nacks, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_normal_nack_count", "total num of nack messages sending", &normal_nacks, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_write_nack_count", "total num of nack messages sending", &write_nacks, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_nack_count", "total num of nack messages sending", &sync_nacks, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sc_fail_count", "total num of store conditional fail", &store_conditional_failed, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_flip_count", "total num of flipped messages", &flip_counter, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_L1_flip_count", "total num of flipped messages", &L1_flip_counter, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_reply_benefit", "total num of data reply benefit", &e_to_m, 0, ((void *)0));
 stat_reg_formula (sdb, "average_normal_miss_handle_time", "cycles per every miss and invalidation", "total_normal_miss_handle_time / total_normal_event_count", ((void *)0));
 stat_reg_formula (sdb, "average_L2_miss_handle_time", "cycles per every miss and invalidation", "total_L2_miss_handle_time / total_normal_event_count", ((void *)0));
 stat_reg_formula (sdb, "average_sync_miss_handle_time", "cycles per every miss and invalidation", "total_sync_miss_handle_time / total_sync_event_count", ((void *)0));
 stat_reg_formula (sdb, "average_miss_handle_time", "cycles per every miss and invalidation", "total_miss_handle_time / total_event_count", ((void *)0));
 stat_reg_sqword (sdb, "total_mesh_network_access", "total mesh_network access", &totalMeshHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_mesh_network_delay", "total mesh_network delay", &totalMeshHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_mesh_network_time", "cycles per mesh_network access", "total_mesh_network_delay / total_mesh_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_normal_mesh_network_access", "total mesh_network access", &totalMeshNorHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_normal_mesh_network_delay", "total mesh_network delay", &totalMeshNorHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_normal_mesh_network_time", "cycles per mesh_network access", "total_noraml_mesh_network_delay / total_noraml_mesh_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_sync_mesh_network_access", "total mesh_network access", &totalMeshSyncHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_mesh_network_delay", "total mesh_network delay", &totalMeshSyncHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_sync_mesh_network_time", "cycles per mesh_network access", "total_sync_mesh_network_delay / total_sync_mesh_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_opt_network_access", "total opt_network access", &totalOptHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_opt_network_delay", "total opt_network delay", &totalOptHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_opt_network_time", "cycles per opt_network access", "total_opt_network_delay / total_opt_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_normal_opt_network_access", "total opt_network access", &totalOptNorHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_normal_opt_network_delay", "total opt_network delay", &totalOptNorHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_normal_opt_network_time", "cycles per opt_network access", "total_normal_opt_network_delay / total_normal_opt_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_sync_opt_network_access", "total opt_network access", &totalOptSyncHopCount, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_sync_opt_network_delay", "total opt_network delay", &totalOptSyncHopDelay, 0, ((void *)0));
 stat_reg_formula (sdb, "average_sync_opt_network_time", "cycles per opt_network access", "total_sync_opt_network_delay / total_sync_opt_network_access", ((void *)0));
 stat_reg_sqword (sdb, "total_local_cache_access", "total local dl2 cache access number", &local_cache_access, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_remote_cache_access", "total remote dl2 cache access number", &remote_cache_access, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involve_wb", "total two hops involves due to write back", &involve_2_hop_wb, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involve_touch", "total two hops involves due to touch", &involve_2_hop_touch, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involves", "total two hops involves", &involve_2_hops, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_four_hops_involves", "total four hops involves", &involve_4_hops, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involves_wm", "total two hops involves", &involve_2_hops_wm, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_four_hops_involves_wm", "total four hops involves", &involve_4_hops_wm, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involve_miss", "total two hops involves", &involve_2_hops_miss, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_four_hops_involve_miss", "total four hops involves", &involve_4_hops_miss, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_four_hops_involve_upgrade", "total four hops involves", &involve_4_hops_upgrade, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_two_hops_involve_upgrade", "total two hops involves", &involve_2_hops_upgrade, 0, ((void *)0));
 stat_reg_sqword (sdb, "data_private_read", "total private data for read miss", &data_private_read, 0, ((void *)0));
 stat_reg_sqword (sdb, "data_private_write", "total private data for write miss", &data_private_write, 0, ((void *)0));
 stat_reg_sqword (sdb, "data_shared_read", "total shared data for read miss", &data_shared_read, 0, ((void *)0));
 stat_reg_sqword (sdb, "data_shared_write", "total shared data for write miss", &data_shared_write, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_all_close", "total numbers of all closed consumers", &total_all_close, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_not_all_close", "total numbers of not all closed consumers", &total_not_all_close, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_p_c_events", "total producer and consumers events (should equal to 4 hops)", &total_p_c_events, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_consumers", "total numbers of consumers", &total_consumers, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_packets_in_neighbor", "total packets are in neighborhood", &total_packets_in_neighbor, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_packets_at_corners", "total packets are at corners", &total_packets_at_corners, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_all_almostclose", "total numbers of all closed and corner consumers", &total_all_almostclose, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_consumers", "total data packets of consumers", &total_data_consumers, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_at_corner", "total data packets supply from at corners", &total_data_at_corner, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_close", "total data packets are supplied from closeby sources", &total_data_close, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_data_far", "total data packets are sumpplied from far sources", &total_data_far, 0, ((void *)0));
 stat_reg_double (sdb, "average_inside_percent", "average inside packets percent(should be divided by total_not_all_close)", &average_inside_percent, 0, ((void *)0));
 stat_reg_double (sdb, "average_outside_percent", "average outside packets percent(should be divided by total_not_all_close)", &average_outside_percent, 0, ((void *)0));
 stat_reg_double (sdb, "average_outside_abs_percent", "average absolutly outside packets percent(far - corner)", &average_outside_abs_percent, 0, ((void *)0));
 stat_reg_double (sdb, "average_corner_percent", "average outside packets percent(corner: should be divided by total_not_all_clos)", &average_corner_percent, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_far_packets", "", &total_far_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_corner_packets", "", &total_corner_packets, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_neighbor_packets", "", &total_neighbor_packets, 0, ((void *)0));

 stat_reg_double (sdb, "pending_invalid_cycles", "how many cycles to invalidate the cache line", &pending_invalid_cycles, 0, ((void *)0));






 stat_reg_sqword (sdb, "total_down_r", "", &downgrade_r, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_down_w", "", &downgrade_w, 0, ((void *)0));
 for (i=0;i<5;i++)
 {
  sprintf (ch2, "down_spand_%d", i);
  stat_reg_sqword (sdb, ch2, "", &spand[i], 0, ((void *)0));
 }

 stat_reg_sqword (sdb, "total_private_counts", "", &private_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_migration_counts", "", &migrate_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_shared_counts", "", &shared_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_shared_rw_counts", "", &shared_rw_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_private_dynamic_counts", "", &private_dynamic_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_migrate_dynamic_counts", "", &migrate_dynamic_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_shared_dynamic_counts", "", &shared_dynamic_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_srw_dynamic_counts", "", &sharedrw_dynamic_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_inflight_private", "", &inflight_private, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_inflight_migrate", "", &inflight_migrate, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_inflight_shared_only", "", &inflight_shared_only, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_inflight_shared_rw", "", &inflight_shared_rw, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_private_others", "", &private_others, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_type_changed", "", &type_changed, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_line_accesses", "", &line_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_inflight_accesses", "", &line_inflight_accesses, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_p_to_srw", "", &private_to_shared_rw, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_srw_to_p", "", &shared_rw_to_private, 0, ((void *)0));
 stat_reg_sqword (sdb, "total_srw_constatnt", "", &shared_rw_constant, 0, ((void *)0));

 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_dynamic_acc_private%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_dynamic_acc_private[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_dynamic_acc_migrate%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_dynamic_acc_migrate[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_dynamic_acc_shared%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_dynamic_acc_shared[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_dynamic_acc_srw%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_dynamic_acc_srw[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_pri_r%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_pri_r[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_pri_w%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_pri_w[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_r%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_r[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_w%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_w[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_private%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_private[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_acc_srw_srw_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_acc_srw_srw[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_access_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_access[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "word_utilization_%d", i);
  stat_reg_sqword (sdb, ch2, "", &word_utilization[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_access_p_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_access_p[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "word_utilization_p_%d", i);
  stat_reg_sqword (sdb, ch2, "", &word_utilization_p[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_access_s_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_access_s[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "word_utilization_s_%d", i);
  stat_reg_sqword (sdb, ch2, "", &word_utilization_s[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_access_m_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_access_m[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "word_utilization_m_%d", i);
  stat_reg_sqword (sdb, ch2, "", &word_utilization_m[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "Cache_access_srw_%d", i);
  stat_reg_sqword (sdb, ch2, "", &Cache_access_srw[i], 0, ((void *)0));
 }
 for (i=0;i<101;i++)
 {
  sprintf (ch2, "word_utilization_srw_%d", i);
  stat_reg_sqword (sdb, ch2, "", &word_utilization_srw[i], 0, ((void *)0));
 }
 for (i = 0; i < 16; i++)
 {
  char ch2[20];
  sprintf (ch2, "port_%d", i);
  stat_reg_sqword (sdb, ch2, "", &port_accord[i], 0, ((void *)0));
 }
 for (i = 0; i < 64; i++)
 {
  char ch2[20];
  sprintf (ch2, "sharer_distr_%d", i);
  stat_reg_sqword (sdb, ch2, "", &sharer_distr[i], 0, ((void *)0));
 }
# 3090 "sim-outorder.c"
 optical_reg_stats (sdb);

 stat_reg_sqword (sdb, "IFQ_count", "cumulative IFQ occupancy", &IFQ_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "IFQ_fcount", "cumulative IFQ full count", &IFQ_fcount, 0, ((void *)0));
 stat_reg_formula (sdb, "ifq_occupancy", "avg IFQ occupancy (insn's)", "IFQ_count / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "ifq_rate", "avg IFQ dispatch rate (insn/cycle)", "sim_total_insn / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "ifq_latency", "avg IFQ occupant latency (cycle's)", "ifq_occupancy / ifq_rate", ((void *)0));
 stat_reg_formula (sdb, "ifq_full", "fraction of time (cycle's) IFQ was full", "IFQ_fcount / sim_cycle", ((void *)0));

 stat_reg_sqword (sdb, "RUU_count", "cumulative RUU occupancy", &RUU_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "RUU_fcount", "cumulative RUU full count", &RUU_fcount, 0, ((void *)0));
 stat_reg_formula (sdb, "ruu_occupancy", "avg RUU occupancy (insn's)", "RUU_count / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "ruu_rate", "avg RUU dispatch rate (insn/cycle)", "sim_total_insn / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "ruu_latency", "avg RUU occupant latency (cycle's)", "ruu_occupancy / ruu_rate", ((void *)0));
 stat_reg_formula (sdb, "ruu_full", "fraction of time (cycle's) RUU was full", "RUU_fcount / sim_cycle", ((void *)0));

 stat_reg_sqword (sdb, "LSQ_count", "cumulative LSQ occupancy", &LSQ_count, 0, ((void *)0));
 stat_reg_sqword (sdb, "LSQ_fcount", "cumulative LSQ full count", &LSQ_fcount, 0, ((void *)0));
 stat_reg_formula (sdb, "lsq_occupancy", "avg LSQ occupancy (insn's)", "LSQ_count / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "lsq_rate", "avg LSQ dispatch rate (insn/cycle)", "sim_total_insn / sim_cycle", ((void *)0));
 stat_reg_formula (sdb, "lsq_latency", "avg LSQ occupant latency (cycle's)", "lsq_occupancy / lsq_rate", ((void *)0));
 stat_reg_formula (sdb, "lsq_full", "fraction of time (cycle's) LSQ was full", "LSQ_fcount / sim_cycle", ((void *)0));
 stat_reg_sqword (sdb, "dl2ActuallyAccessed", "", &dl2ActuallyAccessed, 0, ((void *)0));

 stat_reg_sqword (sdb, "prefetchLoad", "", &m_sqPrefetchCnt, 0, ((void *)0));

 for (i = 0; i < numcontexts; i++)
 {
  char ch[20], fm[30], ch2[20];

  sprintf (ch2, "brRecovery_%d", i);
  stat_reg_sqword (sdb, ch2, "total wrong branches", &brRecovery[i], 0, ((void *)0));

  sprintf (ch2, "extraInsn_%d", i);
  stat_reg_sqword (sdb, "extraInsn", "total number of wrong path insn executed", &extraInsn[i], 0, ((void *)0));
 }

 for (i = 0; i < 64; i++)
 {
  char ch2[20];

 }

 for (i = 0; i < 64; i++)
 {
  char ch2[20];


  sprintf (ch2, "thread_sim_insn_%d", i);
  stat_reg_sqword (sdb, ch2, "per thread sim num insn", &simInsn[i], 0, ((void *)0));
  sprintf (ch2, "StallCount_%d", i);
  stat_reg_sqword (sdb, ch2, "total stall count", &sleepCount[i], 0, ((void *)0));
  sprintf (ch2, "quienseWakeup_%d", i);
  stat_reg_sqword (sdb, ch2, "", &quienseWakeup[i], 0, ((void *)0));
  sprintf (ch2, "seqConsReplay_%d", i);
  stat_reg_sqword (sdb, ch2, "", &seqConsReplay[i], 0, ((void *)0));
  sprintf (ch2, "seqConsInsnReplay_%d", i);
  stat_reg_sqword (sdb, ch2, "", &seqConsInsnReplay[i], 0, ((void *)0));
  sprintf (ch2, "ldstRejectionCount_%d", i);
  stat_reg_sqword (sdb, ch2, "", &ldstRejectionCount[i], 0, ((void *)0));
  sprintf (ch2, "TrueReplay_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_sqNumLdReplay[i], 0, ((void *)0));

  sprintf (ch2, "InvalidationReplay_%d", i);
  stat_reg_sqword (sdb, ch2, "", &invalidation_replay[i], 0, ((void *)0));


  sprintf (ch2, "loadLoadReplay_%d", i);
  stat_reg_sqword (sdb, ch2, "", &loadLoadReplayCount[i], 0, ((void *)0));

  sprintf (ch2, "avgRUUsize_%d", i);
  stat_reg_double (sdb, ch2, "", &avgRUUsize[i], 0, ((void *)0));
  sprintf (ch2, "avgLQsize_%d", i);
  stat_reg_double (sdb, ch2, "", &avgLQsize[i], 0, ((void *)0));
  sprintf (ch2, "avgSQsize_%d", i);
  stat_reg_double (sdb, ch2, "", &avgSQsize[i], 0, ((void *)0));
  sprintf (ch2, "CommitStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_commitStall[i], 0, ((void *)0));
  sprintf (ch2, "TotalStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_totalStall[i], 0, ((void *)0));
  sprintf (ch2, "RUUStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_RUUFull[i], 0, ((void *)0));
  sprintf (ch2, "LQStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_sqLQFull[i], 0, ((void *)0));
  sprintf (ch2, "SQStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_sqSQFull[i], 0, ((void *)0));
  sprintf (ch2, "StoreMissStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreMiss[i], 0, ((void *)0));
  sprintf (ch2, "LQHitStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_LoadRealHit[i], 0, ((void *)0));
  sprintf (ch2, "LQMissStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_LoadRealMiss[i], 0, ((void *)0));
  sprintf (ch2, "SQHitStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreRealHit[i], 0, ((void *)0));
  sprintf (ch2, "SQMissStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreRealMiss[i], 0, ((void *)0));
  sprintf (ch2, "StoreStallMiss_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreStallMiss[i], 0, ((void *)0));
  sprintf (ch2, "StoreStallHit_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreStallHit[i], 0, ((void *)0));
  sprintf (ch2, "LoadStallMiss_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_LoadStallMiss[i], 0, ((void *)0));
  sprintf (ch2, "LoadStallHit_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_LoadStallHit[i], 0, ((void *)0));
  sprintf (ch2, "StoreUpdateMissStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_StoreUpdateMiss[i], 0, ((void *)0));
  sprintf (ch2, "LoadMissStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_LoadMiss[i], 0, ((void *)0));
  sprintf (ch2, "RegStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_regFull[i], 0, ((void *)0));
  sprintf (ch2, "IssueStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_issueFull[i], 0, ((void *)0));
  sprintf (ch2, "Il1missStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_il1Miss[i], 0, ((void *)0));
  sprintf (ch2, "FetchStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_fetchEmpty[i], 0, ((void *)0));
  sprintf (ch2, "STLCStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_STLC[i], 0, ((void *)0));
  sprintf (ch2, "TrapStall_%d", i);
  stat_reg_sqword (sdb, ch2, "", &m_trap[i], 0, ((void *)0));
 }
# 3219 "sim-outorder.c"
 for (i = 0; i < numcontexts; i++)
 {
  ld_reg_stats (sdb, i);
  mem_reg_stats (thecontexts[i]->mem, sdb);
 }

 for (i = 0; i < 64; i++)
 {
  if (cache_dl1[i])
   cache_reg_stats (cache_dl1[i], sdb, i);
  if (cache_il1[i])
   cache_reg_stats (cache_il1[i], sdb, i);
  if (itlb[i])
   cache_reg_stats (itlb[i], sdb, i);
  if (dtlb[i])
   cache_reg_stats (dtlb[i], sdb, i);
 }


 if (cache_dl2)
  cache_reg_stats (cache_dl2, sdb, 0);


 power_reg_stats (sdb);


 stat_reg_sqword (sdb, "sim_invalid_addrs", "total non-speculative bogus addresses seen (debug var)", &sim_invalid_addrs, 0, ((void *)0));

 for (i = 0; i < pcstat_nelt; i++)
 {
  char buf[512], buf1[512];
  struct stat_stat_t *stat;



  stat = stat_find_stat (sdb, pcstat_vars[i]);
  if (!stat)
   _fatal("sim-outorder.c", __FUNCTION__, 3256, "cannot locate any statistic named `%s'", pcstat_vars[i]);


  if (stat->sc != sc_int && stat->sc != sc_uint && stat->sc != sc_sqword)
   _fatal("sim-outorder.c", __FUNCTION__, 3260, "`-pcstat' statistical variable `%s' is not an integral type", stat->name);


  pcstat_stats[i] = stat;
  pcstat_lastvals[i] = ((stat)->sc == sc_int ? (counter_t)*((stat)->variant.for_int.var) : ((stat)->sc == sc_uint ? (counter_t)*((stat)->variant.for_uint.var) : ((stat)->sc == sc_sqword ? *((stat)->variant.for_sqword.var) : (_panic("sim-outorder.c", __FUNCTION__, 3264, "bad stat class"), 0))));


  sprintf (buf, "%s_by_pc", stat->name);
  sprintf (buf1, "%s (by text address)", stat->desc);
  pcstat_sdists[i] = stat_reg_sdist (sdb, buf, buf1,
                        0,
                       (0x0001 | 0x0002),
                 "0x%lx %lu %.2f",
                   ((void *)0));
 }






 cluster_reg_stats (sdb);
}


void lsq_init (int);
static void rslink_init (int nlinks);
static void rs_cache_init (void);
static void eventq_init (void);
static void readyq_init (void);
void cv_init (int threadid);
void ruu_init (int threadid);
static void tracer_init (int threadid);
void fetch_init (int threadid);

static void dir_eventq_init(void);


 void
sim_init (void)
{
 int i;

 sim_num_refs = 0;

 if (!mystricmp (pred_type, "bimod"))
 {

  if (bimod_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 3309, "bad bimod predictor config (<table_size>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 3311, "bad btb config (<num_sets> <associativity>)");


  for (i = 0; i < numcontexts; i++)
  {
   thecontexts[i]->pred = bpred_create (BPred2bit,
                            bimod_config[0],
                        0,
                        0,
                           0,
                            0,
                               0,
                    btb_config[0],
                     btb_config[1],
                               ras_size);
  }
 }
 else if (!mystricmp (pred_type, "2lev"))
 {

  if (twolev_nelt != 4)
   _fatal("sim-outorder.c", __FUNCTION__, 3332, "bad 2-level pred config (<l1size> <l2size> <hist_size> <xor>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 3334, "bad btb config (<num_sets> <associativity>)");

  for (i = 0; i < numcontexts; i++)
  {
   thecontexts[i]->pred = bpred_create (BPred2Level,
                            0,
                        twolev_config[0],
                        twolev_config[1],
                           0,
                            twolev_config[2],
                               twolev_config[3],
                    btb_config[0],
                     btb_config[1],
                               ras_size);
  }
 }
 else if (!mystricmp (pred_type, "comb"))
 {

  if (twolev_nelt != 4)
   _fatal("sim-outorder.c", __FUNCTION__, 3354, "bad 2-level pred config (<l1size> <l2size> <hist_size> <xor>)");
  if (bimod_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 3356, "bad bimod predictor config (<table_size>)");
  if (comb_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 3358, "bad combining predictor config (<meta_table_size>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 3360, "bad btb config (<num_sets> <associativity>)");

  for (i = 0; i < numcontexts; i++)
  {
   thecontexts[i]->pred = bpred_create (BPredComb,
                            bimod_config[0],
                   twolev_config[0],
                   twolev_config[1],
                           comb_config[0],
                            twolev_config[2],
                               twolev_config[3],
                    btb_config[0],
                     btb_config[1],
                               ras_size);
  }
 }
# 3396 "sim-outorder.c"
 CACHEPORTS = RES_CACHEPORTS = RES_CACHE_PORTS = res_membank;
 res_memport = res_mem_port_bank * res_membank;
# 3406 "sim-outorder.c"
 for (i = 0; i < numcontexts; i++)
 {
  if (i == 0)
  {
   thecontexts[i]->power.Powerfactor = (base_proc_freq) * (5 * 0.2) * (5 * 0.2);
   thecontexts[i]->power.SensePowerfactor = (base_proc_freq) * ((5 * 0.2) / 2) * ((5 * 0.2) / 2);
   thecontexts[i]->power.vdd_reduction = 1;
  }
  else
  {
   thecontexts[i]->power.Powerfactor = (base_proc_freq) * checkerVDD * (5 * 0.2) * checkerVDD * (5 * 0.2);
   thecontexts[i]->power.SensePowerfactor = (base_proc_freq) * checkerVDD * ((5 * 0.2) / 2) * checkerVDD * ((5 * 0.2) / 2);
   thecontexts[i]->power.vdd_reduction = checkerVDD;
  }

  calculate_power (&(thecontexts[i]->power));

  if (i)
  {
   thecontexts[i]->power.bpred_power = 0;
   thecontexts[i]->power.dcache2_power = thecontexts[0]->power.dcache2_power;

   thecontexts[i]->power.dcache2_decoder = thecontexts[0]->power.dcache2_decoder;
   thecontexts[i]->power.dcache2_wordline = thecontexts[0]->power.dcache2_wordline;
   thecontexts[i]->power.dcache2_bitline = thecontexts[0]->power.dcache2_bitline;
   thecontexts[i]->power.dcache2_senseamp = thecontexts[0]->power.dcache2_senseamp;
   thecontexts[i]->power.dcache2_tagarray = thecontexts[0]->power.dcache2_tagarray;
   thecontexts[i]->power.dcache2_gc = thecontexts[0]->power.dcache2_gc;
  }
 }

 if (hotspot_active)
  hotspot_init ();
}


static char *
simoo_reg_obj (struct regs_t *regs,
  int is_write,
  enum md_reg_type rt,
  int reg,
  struct eval_value_t *val);


static char *
simoo_mem_obj (struct mem_t *mem,
  int is_write,
  md_addr_t addr,
  char *p,
  int nbytes);


static char *
simoo_mstate_obj (FILE * stream,
  char *cmd,
  struct regs_t *regs,
  struct mem_t *mem);



counter_t rs_link_num = 0;

int MAX_BR_NUM;


 void
sim_load_threads (int argc, char **argv,
  char **envp)
{
 int j, arg_status = 1;
 context *current;

 numcontexts = 0;
 for (j = 0; (j < argc) && (numcontexts < 64) && arg_status; j++)
 {
  fprintf (stderr, "initializing context %d\n", numcontexts);

  arg_status = read_thread_args (envp, argv[j], &numcontexts);

  current = thecontexts[j];

  current->actualid = 0;


  ld_load_prog (current->fname, current->argc, current->argv, envp, &(current->regs), current->mem, 1, j);
 }


 if (ptrace_nelt == 2)
 {

  ptrace_open ( ptrace_opts[0], ptrace_opts[1]);
 }
 else if (ptrace_nelt == 0)
 {
                       ;
 }
 else
  _fatal("sim-outorder.c", __FUNCTION__, 3504, "bad pipetrace args, use: <fname|stdout|stderr> <range>");


 MAX_BR_NUM = ruu_ifq_size + RUU_size;




 fu_pool = res_create_pool ("fu-pool", fu_config, (sizeof(fu_config)/sizeof((fu_config)[0])));
 rslink_init (65536);
 rs_cache_init();
 activecontexts = numcontexts;
 for (j = 0; j < numcontexts; j++)
  tracer_init (j);
 for (j = 0; j < numcontexts; j++)
  fetch_init (j);
 for (j = 0; j < numcontexts; j++)
  cv_init (j);
 eventq_init ();
 readyq_init ();



 dir_eventq_init();
 for(j = 0; j < 64 +mesh_size*2; j++)
 {
  dir_fifo_head[j] = 0;
  dir_fifo_tail[j] = 0;
  dir_fifo_num[j] = 0;
  dir_fifo_portuse[j] = 0;
  l1_fifo_head[j] = 0;
  l1_fifo_tail[j] = 0;
  l1_fifo_num[j] = 0;
  l1_fifo_portuse[j] = 0;
  last_L1_mshr_full[j] = 0;
  last_L1_fifo_full[j] = 0;
  last_Dir_fifo_full[j] = 0;
  last_Input_queue_full[j] = 0;
 }
 last_L2_mshr_full = 0;
 same_L1_L2_fifo_full = 0;
 L1_mshr_full = 0;
 L2_mshr_full = 0;
 L2_mshr_full_prefetch = 0;
 L1_fifo_full = 0;
 Dir_fifo_full = 0;
 Input_queue_full = 0;
 Output_queue_full = 0;

 Stall_L1_mshr = 0;
 Stall_L2_mshr = 0;
 Stall_L1_fifo = 0;
 Stall_dir_fifo = 0;
 Stall_input_queue = 0;
 Stall_output_queue = 0;

 for (j = 0; j < numcontexts; j++)
 {
  ruu_init (j);
  lsq_init (j);
 }

 for (j = 0; j < numcontexts; j++)
 {
  priority[j] = j;
  key[j] = 0;




 }
# 3595 "sim-outorder.c"
}


 void
sim_aux_stats (FILE * stream)
{

}


 void
sim_uninit (void)
{
 if (ptrace_nelt > 0)
  ptrace_close ();


}
# 3631 "sim-outorder.c"
 void
ruu_init (int threadid)
{
 int i = 0;
 context *current;

 current = thecontexts[threadid];
 current->RUU = calloc (RUU_size, sizeof (struct RUU_station));
 if (!current->RUU)
  _fatal("sim-outorder.c", __FUNCTION__, 3640, "out of virtual memory");

 for (i = 0; i < RUU_size; i++)
 {
  current->RUU[i].index = i;
  current->RUU[i].threadid = threadid;
 }
 current->RUU_num = 0;
 current->RUU_head = current->RUU_tail = 0;
 current->RUU_count_thrd = 0;
 current->RUU_fcount_thrd = 0;
 RUU_count = 0;
 RUU_fcount = 0;

 if (threadid)
 {
  current->cycle_mask = 0xffffffff;
  current->latency_factor = 1;
  current->main_thread = 1;
  cache_dl1[threadid]->hit_latency *= current->latency_factor;
 }

 for (i = 0; i < 64; i++)
 {
  iregfile_cl_count[i] = 0;
  iextra_cl_count[i] = 0;
  fregfile_cl_count[i] = 0;
  fextra_cl_count[i] = 0;
  iissueq_cl_count[i] = 0;
  fissueq_cl_count[i] = 0;



 }
}


 static void
ruu_dumpent (struct RUU_station *rs,
  int index,
  FILE * stream,
  int header)
{
 if (!stream)
  stream = stderr;

 if (header)
  fprintf (stream, "idx: %2d: opcode: %s, inst: `", index, (md_op2name[rs->op]));
 else
  fprintf (stream, "       opcode: %s, inst: `", (md_op2name[rs->op]));
 md_print_insn (rs->IR, rs->PC, stream);
 fprintf (stream, "'\n");
 myfprintf (stream, "         PC: 0x%08p, NPC: 0x%08p (pred_PC: 0x%08p)\n", rs->PC, rs->next_PC, rs->pred_PC);
 fprintf (stream, "         in_LSQ: %s, ea_comp: %s, recover_inst: %s\n", rs->in_LSQ ? "t" : "f", rs->ea_comp ? "t" : "f", rs->recover_inst ? "t" : "f");
 myfprintf (stream, "         spec_mode: %s, addr: 0x%08p, tag: 0x%08x\n", rs->spec_mode ? "t" : "f", rs->addr, rs->tag);
 fprintf (stream, "         seq: 0x%08x, ptrace_seq: 0x%08x\n", rs->seq, rs->ptrace_seq);
 fprintf (stream, "         queued: %s, issued: %s, completed: %s\n", rs->queued ? "t" : "f", rs->issued ? "t" : "f", rs->completed ? "t" : "f");
 fprintf (stream, "         operands ready: %s\n", ((rs)->idep_ready[0] && (rs)->idep_ready[1] && (rs)->idep_ready[2]) ? "t" : "f");
}


 static void
ruu_dump (FILE * stream, int threadid)
{
 int num, head;
 struct RUU_station *rs;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "** Thread %d **\n", threadid);
 fprintf (stream, "** RUU state **\n");
 fprintf (stream, "RUU_head: %d, RUU_tail: %d\n", current->RUU_head, current->RUU_tail);
 fprintf (stream, "RUU_num: %d\n", current->RUU_num);

 num = current->RUU_num;
 head = current->RUU_head;
 while (num)
 {
  rs = &(current->RUU[head]);
  ruu_dumpent (rs, rs - current->RUU, stream, 1);
  head = (head + 1) % RUU_size;
  num--;
 }
}


 void
lsq_init (int threadid)
{
 int i = 0;
 context *current;

 current = thecontexts[threadid];

 current->LSQ = calloc (LSQ_size, sizeof (struct RUU_station));
 if (!current->LSQ)
  _fatal("sim-outorder.c", __FUNCTION__, 3741, "out of virtual memory");
 for (i = 0; i < LSQ_size; i++)
 {
  current->LSQ[i].index = i;
  current->LSQ[i].threadid = threadid;
 }
 current->LSQ_num = 0;
 current->LSQ_head = current->LSQ_tail = 0;
 current->LSQ_count = 0;
 current->LSQ_fcount = 0;
 current->m_shLQNum = 0;
 current->m_shSQNum = 0;
 m_totalStall[threadid] = 0;
 m_sqLQFull[threadid] = 0;
 m_sqSQFull[threadid] = 0;
 m_RUUFull[threadid] = 0;
 m_commitStall[threadid] = 0;

}





int non_issue_LSQ_num;
# 3793 "sim-outorder.c"
struct RS_link *rslink_free_list;
struct RS_link *rslink_list[65536];


struct RS_list *rs_cache_list[64][32];

static struct RS_link RSLINK_NULL = { ((void *)0), ((void *)0), 0 };
counter_t rs_link_id = 0;
# 3850 "sim-outorder.c"
 static void
rslink_init (int nlinks)
{
 int i;
 struct RS_link *link;

 rslink_free_list = ((void *)0);
 for (i = 0; i < nlinks; i++)
 {
  link = calloc (1, sizeof (struct RS_link));
  if (!link)
   _fatal("sim-outorder.c", __FUNCTION__, 3861, "out of virtual memory");
  rslink_list[i] = link;
  link->next = rslink_free_list;
  rslink_free_list = link;
 }
}

struct RS_link * findMax_rslink()
{
 int i, max_id;
 struct RS_link *link;
 counter_t max = 0;

 for (i = 0; i < 65536; i++)
 {
  if(rslink_list[i]->last_use > max)
  {
   max = rslink_list[i]->last_use;
   max_id = i;
  }
 }
 return rslink_list[max_id];
}

struct RS_link * findMin_rslink()
{
 int i, min_id;
 struct RS_link *link;
 counter_t min = 800000000;

 for (i = 0; i < 65536; i++)
 {
  if(rslink_list[i]->last_use < min)
  {
   min = rslink_list[i]->last_use;
   min_id = i;
  }
 }
 return rslink_list[min_id];
}

 static void
rs_cache_init()
{
 int i, n;
 for (n = 0; n < 64; n++)
 {
  for(i=0; i<32; i++)
   rs_cache_list[n][i] = ((void *)0);
 }
}




 static void
check_fu_busy (void)
{
 int i;

 for (i = 0; i < numcontexts; i++)
 {
  fu_busy[i] = 0;
 }


 for (i = 0; i < fu_pool->num_resources; i++)
 {
  if (fu_pool->resources[i].busy)
   fu_busy[fu_pool->resources[i].usr_id]++;
 }
}
# 3941 "sim-outorder.c"
 static void
ruu_release_fu (void)
{
 int i;


 for (i = 0; i < fu_pool->num_resources; i++)
 {

  if (fu_pool->resources[i].busy > 0)
  {
   fu_pool->resources[i].busy--;
# 3993 "sim-outorder.c"
  }
 }
}




struct DIRECTORY_EVENT *dir_event_queue;
struct DIRECTORY_EVENT *event_list[48];

 static void
dir_eventq_init(void)
{
 int n = 0;
# 4016 "sim-outorder.c"
 dir_event_queue = ((void *)0);
 for (n = 0; n<48; n++)
  event_list[n] = ((void *)0);
}
# 4060 "sim-outorder.c"
int buffer_full_check(struct DIRECTORY_EVENT *event)
{
 int vc = 0, options = -1, buffer_full = 0;
 if((event->des1*mesh_size+event->des2 != event->src1*mesh_size+event->src2) && (event->input_buffer_full) && (event->operation == 4 || event->operation == 3 || event->operation == 5 || event->operation == 2))
 {
  if (!mystricmp (network_type, "FSOI") || (!mystricmp (network_type, "HYBRID")))
  {
   if(opticalBufferSpace(event->src1, event->src2, event->operation))
    buffer_full = 1;
  }
  else if (!mystricmp (network_type, "MESH"))
  {
   options = OrderCheck(event->src1, event->src2, event->des1, event->des2, event->addr&~(cache_dl1[0]->bsize-1));
   vc = popnetBufferSpace(event->src1, event->src2, options);
   if(vc == -1)
    buffer_full = 1;

  }
  else if ((!mystricmp (network_type, "COMB")))
  {
   buffer_full = CombNetworkBufferSpace(event->src1, event->src2, event->des1, event->des2, event->addr&~(cache_dl1[0]->bsize-1), event->operation, &vc);
  }
  if(buffer_full)
  {

   if(!last_Input_queue_full[event->des1*mesh_size+event->des2])
   {
    Input_queue_full ++;
    last_Input_queue_full[event->des1*mesh_size+event->des2] = sim_cycle;
   }
   return 1;
  }
  else
  {
   event->input_buffer_full = 0;
   event->startCycle = sim_cycle;
   scheduleThroughNetwork(event, sim_cycle, meta_packet_size, vc);
   if(last_Input_queue_full[event->des1*mesh_size+event->des2])
   {
    Stall_input_queue += sim_cycle - last_Input_queue_full[event->des1*mesh_size+event->des2];
    last_Input_queue_full[event->des1*mesh_size+event->des2] = 0;
   }
   return 2;
  }
 }
 else
  return 0;
}
static void dir_eventq_nextevent(void)
{
 struct DIRECTORY_EVENT *event, *ev, *next, *prev;
 int i, insert_flag = 0;
 event = dir_event_queue;
 ev = ((void *)0);
 while (event!=((void *)0))
 {
  next = event->next;

  if (event->when <= sim_cycle)
  {
   insert_flag = buffer_full_check(event);

   if(insert_flag == 0)
   {
    if(event == dir_event_queue)
    {
     dir_event_queue = event->next;
     event->next = ((void *)0);
     if(!(dir_fifo_enqueue(event, 1)))
     {
      event->next = dir_event_queue;
      dir_event_queue = event;
      ev = event;
      event = event->next;
      same_L1_L2_fifo_full ++;
     }
     else
      event = dir_event_queue;
    }
    else
    {
     ev->next = event->next;
     event->next = ((void *)0);
     if(!(dir_fifo_enqueue(event, 1)))
     {
      event->next = dir_event_queue;
      dir_event_queue = event;
      ev = event;
      event = event->next;
      same_L1_L2_fifo_full ++;
     }
     else
      event = ev->next;
    }
   }
   else if(insert_flag == 1)
   {
    ev = event;
    event = event->next;
   }
   else if(insert_flag == 2)
   {
    if(event == dir_event_queue)
    {
     dir_event_queue = event->next;
     event->next = ((void *)0);
     dir_eventq_insert(event);
     event = dir_event_queue;
    }
    else
    {
     ev->next = event->next;
     event->next = ((void *)0);
     dir_eventq_insert(event);
     event = ev->next;
    }
   }

  }
  else
  {
   ev = event;
   event = event->next;
  }

 }
}
# 4198 "sim-outorder.c"
struct RS_link *event_queue;

 static void
eventq_init (void)
{
 event_queue = ((void *)0);
}




 static void
eventq_dump (FILE * stream, int threadid)
{
 struct RS_link *ev;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "** event queue state **\n");

 for (ev = event_queue; ev != ((void *)0); ev = ev->next)
 {

  if (((ev)->tag == (ev)->rs->tag))
  {
   struct RUU_station *rs = ((ev)->rs);

   fprintf (stream, "idx: %2d: @ %.0f\n", rs->index, (double) ev->x.when);
   ruu_dumpent (rs, rs->index, stream, 0);
  }
 }
}





static void
eventq_queue_event (struct RUU_station *rs, tick_t when, int lat)
{
 struct RS_link *prev, *ev, *new_ev;

 if (rs->completed)
  _panic("sim-outorder.c", __FUNCTION__, 4246, "event completed");

 if (when <= sim_cycle)
  _panic("sim-outorder.c", __FUNCTION__, 4249, "event occurred in the past");


 { struct RS_link *n_link; if (!rslink_free_list) _panic("sim-outorder.c", __FUNCTION__, 4252, "out of rs links"); rs_link_num++; n_link = rslink_free_list; rslink_free_list = rslink_free_list->next; n_link->next = ((void *)0); n_link->rs = (rs); n_link->tag = n_link->rs->tag; n_link->last_use = sim_cycle; (new_ev) = n_link; };
 new_ev->x.when = when;

 if(rs == ((void *)0))
  printf("RS problem %lld\n", sim_cycle);

 for (prev = ((void *)0), ev = event_queue; ev && ev->x.when < when; prev = ev, ev = ev->next);

 if (prev)
 {

  new_ev->next = prev->next;
  prev->next = new_ev;
 }
 else
 {

  new_ev->next = event_queue;
  event_queue = new_ev;
 }
}






 static struct RUU_station *
eventq_next_event (void)
{
 struct RS_link *ev;
 struct RS_link *temp_ev, *pred_ev = ((void *)0);

 temp_ev = event_queue;

 while (temp_ev && !thecontexts[temp_ev->rs->threadid]->active_this_cycle)
 {
  pred_ev = temp_ev;
  temp_ev = temp_ev->next;
 }

 if (temp_ev && temp_ev->x.when <= sim_cycle)
 {

  ev = temp_ev;
  if (temp_ev == event_queue)
  {
   event_queue = event_queue->next;
  }
  else
  {
   pred_ev->next = temp_ev->next;
  }


  if (((ev)->tag == (ev)->rs->tag))
  {
   struct RUU_station *rs = ((ev)->rs);


   { struct RS_link *f_link = (ev); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };


   return rs;
  }
  else
  {

   { struct RS_link *f_link = (ev); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };


   return eventq_next_event ();
  }
 }
 else
 {

  return ((void *)0);
 }
}

changeInEventQueue (struct RUU_station * rs, int threadid)
{


 struct RS_link *ev = event_queue;
 struct RS_link *prev = ((void *)0);

 while (ev != ((void *)0))
 {
  if (ev->rs == rs)
   break;
  prev = ev;
  ev = ev->next;
 }

 if (ev == ((void *)0))
  return;
 ev->x.when = sim_cycle;


 if (prev == ((void *)0))
  event_queue = ev->next;
 else
  prev->next = ev->next;

 { struct RS_link *f_link = (ev); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
}
# 4375 "sim-outorder.c"
static struct RS_link *ready_queue;


 static void
readyq_init (void)
{
 ready_queue = ((void *)0);
}



 static void
readyq_dump (FILE * stream, int threadid)
{
 struct RS_link *link;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "** ready queue state **\n");

 for (link = ready_queue; link != ((void *)0); link = link->next)
 {

  if (((link)->tag == (link)->rs->tag))
  {
   struct RUU_station *rs = ((link)->rs);

   ruu_dumpent (rs, rs->index, stream, 1);
  }
 }
}
# 4425 "sim-outorder.c"
 void
readyq_enqueue (struct RUU_station *rs)
{
 struct RS_link *prev, *node, *new_node;


 if (rs->queued)
  _panic("sim-outorder.c", __FUNCTION__, 4432, "node is already queued");

 rs->queued = 1;
# 4457 "sim-outorder.c"
 { struct RS_link *n_link; if (!rslink_free_list) _panic("sim-outorder.c", __FUNCTION__, 4457, "out of rs links"); rs_link_num++; n_link = rslink_free_list; rslink_free_list = rslink_free_list->next; n_link->next = ((void *)0); n_link->rs = (rs); n_link->tag = n_link->rs->tag; n_link->last_use = sim_cycle; (new_node) = n_link; };
 new_node->x.seq = rs->seq;


 for (prev = ((void *)0), node = ready_queue; node && node->x.seq < rs->seq; prev = node, node = node->next);

 if (prev)
 {

  new_node->next = prev->next;
  prev->next = new_node;
 }
 else
 {

  new_node->next = ready_queue;
  ready_queue = new_node;
 }
}
# 4554 "sim-outorder.c"
struct CV_link CVLINK_NULL = { ((void *)0), 0 };
# 4957 "sim-outorder.c"
 void
cv_init (int threadid)
{
 int i;
 context *current;

 current = thecontexts[threadid];



 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  current->create_vector[i] = CVLINK_NULL;
  current->create_vector_rt[i] = 0;
  current->spec_create_vector[i] = CVLINK_NULL;
  current->spec_create_vector_rt[i] = 0;
 }


 { int i; for (i=0; i<(((((( 32 + 32 + 3 + 1 + 1 + 1))+31)/32))); i++) (current->use_spec_cv)[i] = 0; };

}



 static void
cv_dump (FILE * stream, int threadid)
{
 int i;
 struct CV_link ent;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "** create vector state **\n");

 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  ent = ((((current->use_spec_cv)[((i))/32] & (1 << (((i)) % 32))) != 0) ? current->spec_create_vector[i] : current->create_vector[i]);
  if (!ent.rs)
   fprintf (stream, "[cv%02d]: from architected reg file\n", i);
  else
   fprintf (stream, "[cv%02d]: from %s, idx: %d\n", i, (ent.rs->in_LSQ ? "LSQ" : "RUU"), ent.rs->index);
 }
}

static void ruu_recover (int branch_index, int threadid, int mode);


static void tracer_recover (int threadid);
void recFreeRegList (int threadid);


void RS_block_list(struct RUU_station *rs, tick_t when, int entry, int threadid)
{
 if(rs->spec_mode) return;
 if(entry < 1 || entry > 32)
  _panic("sim-outorder.c", __FUNCTION__, 5018, "L1 MSHR: wrong mshr entry");

 entry = entry - 1;

 struct RS_list *rs_list;
 rs_list = calloc( 1, sizeof(struct RS_list));
 rs_list->rs = rs;
 rs_list->next = ((void *)0);
 rs_list->spec_mode = rs->spec_mode;
 rs_list->when = when;
 rs_list->next = rs_cache_list[threadid][entry];
 rs_cache_list[threadid][entry] = rs_list;
}

void RS_block_next(struct RS_list *cur)
{
 if(!cur->rs) return;

 if(cur->spec_mode && !cur->rs->spec_mode)
  return;
 cur->rs->cache_ready = 0;
 if((((md_op2flags[cur->rs->op]) & 0x00000040) && (cur->rs->issued || cur->rs->queued || cur->rs->completed)) || (!((md_op2flags[cur->rs->op]) & 0x00000040) && !(cur->rs->issued && !cur->rs->queued)))
  _panic("sim-outorder.c", __FUNCTION__, 5040, "L1 MSHR: issue, queue, or commit flag is set!!!");

 if(((md_op2flags[cur->rs->op]) & 0x00000040))
 {


  readyq_enqueue (cur->rs);






 }
 else
  cur->rs->writewait = 2;
}





static double commit_idle = 0;
int commit_flag[64] = {0};



 static void
ruu_commit (void)
{

 int i, j, threadid, lat, events, committed;
 int mm;
 context *current;
 int temp_LSQ_index, temp_LSQ_num, LSQ_index;
 struct RUU_station *temp_LSQ_rs;
 int store_op = 0, pcbSearch;
 struct RS_link *olink, *olink_next;
 int readShareDir = 0;




 md_addr_t tempAddr;
 enum md_opcode tempOp;

 thread_commit = 0;
 int isSTLC;



 for (j = 0; j <= numcontexts; j++, thread_commit = (thread_commit + 1) % numcontexts)
 {

  if (j > 0)
  {
   commit_done[j - 1] = committed;
   if(!committed)
    m_commitStall[j-1]++;
  }
  if (j == numcontexts)
   break;

  threadid = thread_commit;
  current = thecontexts[threadid];

  temp_LSQ_num = current->LSQ_num;
  LSQ_index = current->LSQ_head;
  committed = 0;
  int haha = 0;



  while (current->RUU_num > 0 && committed < ruu_commit_width)
  {
# 5124 "sim-outorder.c"
   struct RUU_station *rs = &(current->RUU[current->RUU_head]);


   tempAddr = 0;
   store_op = 0;
   tempOp = 0;
   isSTLC = 0;

   if(rs->writewait == 1)
   {
    break;
   }
   if (!rs->completed)
   {
    break;
   }






   if(((md_op2flags[rs->op]) & 0x00040000) && (m_L1WBufCnt[threadid]))
    break;
# 5158 "sim-outorder.c"
   events = 0;


   if (current->RUU[current->RUU_head].ea_comp)
   {

    while (current->LSQ[LSQ_index].threadid != current->RUU[current->RUU_head].threadid)
    {
     LSQ_index = (LSQ_index + 1) % LSQ_size;
     temp_LSQ_num--;
     if (!temp_LSQ_num)
      _panic("sim-outorder.c", __FUNCTION__, 5169, "RUU and LSQ out of sync");
    }
    if (current->LSQ_num <= 0 || !current->LSQ[LSQ_index].in_LSQ)
     _panic("sim-outorder.c", __FUNCTION__, 5172, "RUU out of sync with LSQ");

    if (!current->LSQ[LSQ_index].completed)
    {
     break;
    }
# 5197 "sim-outorder.c"
    if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080))
    {
     if (current->LSQ[LSQ_index].op == SC)
      isSTLC = 1;

     if (m_L1WBufCnt[threadid] >= 8)
      break;
     if(isSTLC && m_L1WBufCnt[threadid])
      break;
     else
     {
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].PC = current->LSQ[LSQ_index].PC;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].IR = current->LSQ[LSQ_index].IR;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].op = current->LSQ[LSQ_index].op;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].lsqId = LSQ_index;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].robId = rs->index;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].writeValue = current->LSQ[LSQ_index].val_ra;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].addr = current->LSQ[LSQ_index].addr;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].sim_num_insn = current->LSQ[LSQ_index].sim_num_insn;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].writeStarted = 0;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].finishTime = 0;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].isMiss = 0;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].entryTime = sim_cycle;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].STL_C_fail = 0;
      m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].already_check = 0;
      if( isSTLC && !isCacheHit(cache_dl1[threadid], current->LSQ[LSQ_index].addr, threadid))
      {
       completeStore(threadid, current->LSQ[LSQ_index].addr, GetMemAccWidth(current->LSQ[LSQ_index].op), isSTLC);
       m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].commitDone = 1;
       if(isSTLC && storeCondFail == 0)
        _panic("sim-outorder.c", __FUNCTION__, 5227, "Store conditional should fail on a L1 miss");
      }
      else
       m_L1WBuf[threadid][m_L1WBuf_tail[threadid]].commitDone = 0;

      m_L1WBufCnt[threadid]++;
      m_L1WBuf_tail[threadid] = (m_L1WBuf_tail[threadid]+1)%8;
     }
# 5342 "sim-outorder.c"
        }
                   else
    {
     readShareDir = current->LSQ[LSQ_index].ReadShareDir;






    }
    if(rs->writewait != 1)
    {
     freelist_insert (current->LSQ[LSQ_index].oldpreg, threadid);

     current->LSQ[LSQ_index].tag++;


     if (ptrace_active) __ptrace_newstage((current->LSQ[LSQ_index].ptrace_seq),("CT"),(events));
     if (ptrace_active) __ptrace_endinst((current->LSQ[LSQ_index].ptrace_seq));

     if (LSQ_index != current->LSQ_head)
     {
      temp_LSQ_rs = &current->LSQ[LSQ_index];
      temp_LSQ_index = LSQ_index;
      while (temp_LSQ_index != current->LSQ_head)
      {
       current->LSQ[temp_LSQ_index] = current->LSQ[(int) ((temp_LSQ_index + (LSQ_size - 1)) % LSQ_size)];
       current->LSQ[temp_LSQ_index].index = temp_LSQ_index;
       temp_LSQ_index = (temp_LSQ_index + (LSQ_size - 1)) % LSQ_size;
      }

      current->LSQ[temp_LSQ_index] = *temp_LSQ_rs;
      current->LSQ[temp_LSQ_index].index = temp_LSQ_index;
     }
     if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040))
     {
      if (!current->LSQ[LSQ_index].isPrefetch)
       current->m_shLQNum--;
     }
     else if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080))
     {
      if (!current->LSQ[LSQ_index].isPrefetch)
       current->m_shSQNum--;
     }
     if(ruu_inorder_issue)
     {
      for(i=0;i<2;i++)
      {
       if (current->LSQ[LSQ_index].onames[i] != 0)
       {
        for (olink = current->LSQ[LSQ_index].odep_list[i]; olink; olink = olink_next)
        {
         olink_next = olink->next;
         { struct RS_link *f_link = (olink); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
        }
        current->LSQ[LSQ_index].odep_list[i] = ((void *)0);
       }
      }
     }

     current->LSQ_head = (current->LSQ_head + 1) % LSQ_size;
     LSQ_index = (LSQ_index + 1) % LSQ_size;
     current->LSQ_num--;
     temp_LSQ_num--;
    }

   }

   if(rs->writewait != 1)
   {
    if (current->pred && bpred_spec_update == spec_CT && ((md_op2flags[rs->op]) & 0x00000004) && !rs->duplicate
       )
    {
     bpred_access++;
     if (!(rs->duplicate))
     {
      current->bpred_access++;
     }

     bpred_update (current->pred,
                            rs->PC,
                                   rs->next_PC,
                    rs->next_PC != (rs->PC +
        2*sizeof (md_inst_t)),
                         rs->pred_PC != (rs->PC +
        2*sizeof (md_inst_t)),
                           rs->pred_PC == rs->next_PC,
                    rs->op,
                                          &rs->dir_update,
                       rs->threadid,
                               (bpred_btb_use_masterid ? thecontexts[rs->threadid]->masterid : rs->threadid));
    }


    freelist_insert (current->RUU[current->RUU_head].oldpreg, threadid);

    current->RUU[current->RUU_head].tag++;

    if (ptrace_active) __ptrace_newstage((current->RUU[current->RUU_head].ptrace_seq),("CT"),(events));
    if (ptrace_active) __ptrace_endinst((current->RUU[current->RUU_head].ptrace_seq));

    total_slip_cycles += (sim_cycle - rs->disp_time);
    max_slip_cycles = ((((sim_cycle - rs->disp_time))>(max_slip_cycles))?((sim_cycle - rs->disp_time)):(max_slip_cycles));

    if (rs->issue_time)
    {
     total_issue_slip_cycles += (sim_cycle - rs->issue_time);
     max_issue_slip_cycles = ((((sim_cycle - rs->issue_time))>(max_issue_slip_cycles))?((sim_cycle - rs->issue_time)):(max_issue_slip_cycles));
    }

    if(ruu_inorder_issue)
    {
     for(i=0;i<2;i++)
     {
      if (rs->onames[i] != 0)
      {
       for (olink = rs->odep_list[i]; olink; olink = olink_next)
       {
        olink_next = olink->next;
        { struct RS_link *f_link = (olink); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
       }
       rs->odep_list[i] = ((void *)0);
      }
     }
    }

    current->RUU_head = (current->RUU_head + 1) % RUU_size;
    current->RUU_num--;
    commit_flag[threadid] = 0;

    if (rs->duplicate)
    {
     COMPARE_access[threadid]++;
     compare_access++;
    }

    if(!ruu_inorder_issue)
    {
     rob2_access++;
     current->rob2_access++;
    }
    committed++;

    commit_idle = 0;
    for (i = 0; i < 2; i++)
    {
     if (rs->odep_list[i])
      _panic("sim-outorder.c", __FUNCTION__, 5490, "retired instruction has odeps\n");
    }
   }
  }
  stat_add_sample (commit_width_stat, committed);
  }
}
# 5507 "sim-outorder.c"
 static void
ruu_recover (int branch_index, int threadid, int mode)
{

 int mm;
 context *current = thecontexts[threadid];
 int i, RUU_index, LSQ_index, temp_RUU_num;

 struct RUU_station *temp_LSQ_rs;
 int temp_LSQ_index, temp_LSQ_num;


 int shift_right = 0;


 brRecovery[threadid]++;

 disp_delay = 0;


 RUU_index = current->RUU_head;
 temp_RUU_num = current->RUU_num;
 LSQ_index = current->LSQ_head;
 temp_LSQ_num = current->LSQ_num;


 if (!current->RUU_num)
  _panic("sim-outorder.c", __FUNCTION__, 5534, "empty RUU");



 while (RUU_index != branch_index)
 {

  if (!temp_RUU_num)
   _panic("sim-outorder.c", __FUNCTION__, 5542, "empty RUU");


  if (current->RUU[RUU_index].ea_comp)
  {
   while (current->LSQ[LSQ_index].threadid != current->RUU[RUU_index].threadid)
   {

    LSQ_index = (LSQ_index + 1) % LSQ_size;
    temp_LSQ_num--;
    if (!temp_LSQ_num)
    {
     fprintf (stderr, "Thread %d, cycle %lu\n", threadid, (unsigned long) sim_num_insn);
     _panic("sim-outorder.c", __FUNCTION__, 5555, "RUU and LSQ out of sync");
    }
   }
   LSQ_index = (LSQ_index + 1) % LSQ_size;
   temp_LSQ_num--;
  }
  RUU_index = (RUU_index + 1) % RUU_size;
  temp_RUU_num--;
 }

 if (mode == 0)
 {

  RUU_index = (RUU_index + 1) % RUU_size;
  temp_RUU_num--;
 }



 while (temp_RUU_num != 0)
 {
  extraInsn[threadid]++;

  if (!temp_RUU_num)
   _panic("sim-outorder.c", __FUNCTION__, 5579, "empty RUU");

  if (mode == 0 && RUU_index == current->RUU_head)
   _panic("sim-outorder.c", __FUNCTION__, 5582, "RUU head and tail broken");

  if (current->RUU[RUU_index].counted_iissueq)
  {
   current->iissueq_thrd--;
   iissueq--;
   iissueq_cl[current->id]--;
   current->RUU[RUU_index].counted_iissueq = 0;
  }
  if (current->RUU[RUU_index].counted_fissueq)
  {
   current->fissueq_thrd--;
   fissueq--;
   fissueq_cl[current->id]--;
   current->RUU[RUU_index].counted_fissueq = 0;
  }

  if (current->RUU[RUU_index].ea_comp)
  {
   if (!temp_LSQ_num)
    _panic("sim-outorder.c", __FUNCTION__, 5602, "RUU and LSQ out of sync");
   while (current->LSQ[LSQ_index].threadid != current->RUU[RUU_index].threadid)
   {
    LSQ_index = (LSQ_index + 1) % LSQ_size;
    temp_LSQ_num--;
    if (!temp_LSQ_num)
     _panic("sim-outorder.c", __FUNCTION__, 5608, "RUU and LSQ out of sync");
   }

   if (current->LSQ[LSQ_index].counted_iissueq)
   {
    current->iissueq_thrd--;
    iissueq--;
    iissueq_cl[current->id]--;
    current->LSQ[LSQ_index].counted_iissueq = 0;
   }
   if (current->LSQ[LSQ_index].counted_fissueq)
   {
    current->fissueq_thrd--;
    fissueq--;
    fissueq_cl[current->id]--;
    current->LSQ[LSQ_index].counted_fissueq = 0;
   }

   for (i = 0; i < 2; i++)
   {
    { struct RS_link *fl_link, *fl_link_next; for (fl_link=(current->LSQ[LSQ_index].odep_list[i]); fl_link; fl_link=fl_link_next) { fl_link_next = fl_link->next; { struct RS_link *f_link = (fl_link); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; }; } };

    current->LSQ[LSQ_index].odep_list[i] = ((void *)0);
   }

   freelist_insert (current->LSQ[LSQ_index].opreg, threadid);
   changeInEventQueue(&current->LSQ[LSQ_index], threadid);


   current->LSQ[LSQ_index].tag++;


   if (ptrace_active) __ptrace_endinst((current->LSQ[LSQ_index].ptrace_seq));


   if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040))
   {
    if (!current->LSQ[LSQ_index].isPrefetch)
     current->m_shLQNum--;
   }
   else if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080))
   {
    if (!current->LSQ[LSQ_index].isPrefetch)
     current->m_shSQNum--;
   }

   current->LSQ_tail = (current->LSQ_tail + LSQ_size - 1) % LSQ_size;
   LSQ_index = (LSQ_index + 1) % LSQ_size;
   current->LSQ_num--;
   temp_LSQ_num--;
  }


  for (i = 0; i < 2; i++)
  {
   { struct RS_link *fl_link, *fl_link_next; for (fl_link=(current->RUU[RUU_index].odep_list[i]); fl_link; fl_link=fl_link_next) { fl_link_next = fl_link->next; { struct RS_link *f_link = (fl_link); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; }; } };
   current->RUU[RUU_index].odep_list[i] = ((void *)0);
  }

  freelist_insert (current->RUU[RUU_index].opreg, threadid);
  changeInEventQueue(&current->RUU[RUU_index], threadid);
  current->RUU[RUU_index].tag++;
  if (ptrace_active) __ptrace_endinst((current->RUU[RUU_index].ptrace_seq));

  RUU_index = (RUU_index + 1) % RUU_size;
  current->RUU_num--;
  temp_RUU_num--;
 }

 if(!ruu_inorder_issue)
 {
  rob2_access++;
  current->rob2_access++;
 }

 instseqnum = current->RUU[branch_index].instnum;
 lastcluster = current->RUU[branch_index].cluster;
 num_sent = 1;

 if (mode == 0)
 {
  current->RUU_tail = (branch_index + 1) % RUU_size;
  copy_from (threadid);
 }
 else
 {
  if (current->RUU_num != 0)
   _panic("sim-outorder.c", __FUNCTION__, 5695, "ROB must be completely empty");
  current->RUU_tail = current->RUU_head;
 }




 { int i; for (i=0; i<(((((( 32 + 32 + 3 + 1 + 1 + 1))+31)/32))); i++) (current->use_spec_cv)[i] = 0; };




 for (temp_LSQ_index = 0; temp_LSQ_index < LSQ_size; temp_LSQ_index++)
  if (temp_LSQ_index != current->LSQ[temp_LSQ_index].index)
   _panic("sim-outorder.c", __FUNCTION__, 5709, "LSQ index messed up");
}
# 5723 "sim-outorder.c"
 static void
ruu_writeback (void)
{
 int i;
 int sum1, sum2, sum3;
 struct RUU_station *rs;
 int delay;

 context *current;



 int temp;

 for (temp = 0; temp < numcontexts; temp++)
 {
  wb_done[temp] = 0;
 }


 while ((rs = eventq_next_event ()))
 {
  current = thecontexts[rs->threadid];

  if (!((rs)->idep_ready[0] && (rs)->idep_ready[1] && (rs)->idep_ready[2]) || rs->queued || !rs->issued || rs->completed)
     _panic("sim-outorder.c", __FUNCTION__, 5748, "inst completed and !ready, !issued, or completed");

  rs->completed = 1;

  wb_done[rs->threadid]++;


  if (!((md_op2flags[rs->op]) & 0x00000004))
  {
   if ((rs->out1 > 0) && (rs->out1 < 32))
   {
    iresultbus_access++;
    current->iresultbus_access++;
    if(!ruu_inorder_issue)
    {
     rob1_access++;
     current->rob1_access++;
     iwakeup_access++;
     current->iwakeup_access++;
    }
    iregfile_access++;
    current->iregfile_access++;
   }
   if ((rs->out1 > 31) && (rs->out1 < 63))
   {

    fresultbus_access++;
    current->fresultbus_access++;
    if(!ruu_inorder_issue)
    {
     rob1_access++;
     current->rob1_access++;
     fwakeup_access++;
     current->fwakeup_access++;
    }
    fregfile_access++;
    current->fregfile_access++;
   }
  }


  if (rs->recover_inst)
  {
   if (rs->in_LSQ)
    _panic("sim-outorder.c", __FUNCTION__, 5792, "mis-predicted load or store?!?!?");

   ruu_recover (rs - current->RUU, rs->threadid, 0);
   tracer_recover (rs->threadid);
   bpred_recover (current->pred, rs->PC, rs->stack_recover_idx, rs->threadid);
   int threadid = rs->threadid;
   int i = 0;
   for(i=0;i<32;i++)
   {
    struct RS_list *prev, *cur;
    for(prev=((void *)0), cur = rs_cache_list[threadid][i]; cur; cur=cur->next)
    {
     if(cur->rs && cur->rs->spec_mode)
     {
      if(prev == ((void *)0))
      {
       rs_cache_list[threadid][i] = cur->next;
       prev = ((void *)0);
      }
      else
      {
       prev->next = cur->next;
       cur = prev;
       prev = cur;
      }
     }
     else
      prev = cur;

    }
   }
   if(current->ruu_fetch_issue_delay < 800000000/2)
    current->ruu_fetch_issue_delay = ruu_branch_penalty;
  }

  if (current->pred && bpred_spec_update == spec_WB && !rs->in_LSQ && ((md_op2flags[rs->op]) & 0x00000004) && !rs->duplicate
     )
  {
   bpred_access++;
   if (!(rs->duplicate))
   {
    current->bpred_access++;
   }
   bpred_update (current->pred,
                          rs->PC,
                                 rs->next_PC,
                  rs->next_PC != (rs->PC +
      sizeof (md_inst_t)),
                       rs->pred_PC != (rs->PC +
      sizeof (md_inst_t)),
                         rs->pred_PC == rs->next_PC,
                  rs->op,
                                        &rs->dir_update,
                     rs->threadid,
                             (bpred_btb_use_masterid ? thecontexts[rs->threadid]->masterid : rs->threadid));
  }


  if (ptrace_active) __ptrace_newstage((rs->ptrace_seq),("WB"),(rs->recover_inst ? 0x00000008 : 0));

  sum1 = issue_rate;
  sum2 = 0;
  sum3 = 0;

  for (i = 0; i < 2; i++)
  {
   if (rs->onames[i] != 0)
   {
    struct CV_link link;
    struct RS_link *olink, *olink_next;

    if (rs->spec_mode)
    {
     link = current->spec_create_vector[rs->onames[i]];
     if (link.rs && (link.rs == rs && link.odep_num == i))
     {
      current->spec_create_vector[rs->onames[i]] = CVLINK_NULL;
      current->spec_create_vector_rt[rs->onames[i]] = sim_cycle;
     }
    }
    else
    {
     link = current->create_vector[rs->onames[i]];
     if (link.rs && (link.rs == rs && link.odep_num == i))
     {
      current->create_vector[rs->onames[i]] = CVLINK_NULL;
      current->create_vector_rt[rs->onames[i]] = sim_cycle;
     }
    }
    for (olink = rs->odep_list[i]; olink; olink = olink_next)
    {
     if (((olink)->tag == (olink)->rs->tag))
     {
      if (olink->rs->idep_ready[olink->x.opnum])
       _panic("sim-outorder.c", __FUNCTION__, 5886, "output dependence already satisfied");
      olink->rs->idep_ready[olink->x.opnum] = 1;

      olink->rs->when_ready[olink->x.opnum] = sim_cycle;
      olink->rs->when_idep_ready[olink->x.opnum] = sim_cycle;

      sum2++;
      if (((olink->rs)->idep_ready[0] && (olink->rs)->idep_ready[1] && (olink->rs)->idep_ready[2]))
      {
       if (!olink->rs->in_LSQ || (((md_op2flags[olink->rs->op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080)))
        readyq_enqueue (olink->rs);
       sum3++;
      }
     }
     olink_next = olink->next;
     if(!ruu_inorder_issue)
      { struct RS_link *f_link = (olink); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    }
    if(!ruu_inorder_issue)
     rs->odep_list[i] = ((void *)0);
   }
  }
 }
}
# 5923 "sim-outorder.c"
 static void
lsq_refresh (void)
{
 int i, j, index, idx, num_sta_unknown_thread = 0;

 context *current;


 char std_width[1024];


 for (idx = 0; idx < numcontexts; idx++)
 {


  current = thecontexts[idx];

  for (i = 0, index = current->LSQ_head; (i < current->LSQ_num) && (num_sta_unknown_thread < numcontexts); i++, index = (index + 1) % LSQ_size)
  {
   if ((((md_op2flags[current->LSQ[index].op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040)) && !current->LSQ[index].queued
     && !current->LSQ[index].issued
     && !current->LSQ[index].completed
     && !current->LSQ[index].cache_ready &&
                       ((&current->LSQ[index])->idep_ready[0] && (&current->LSQ[index])->idep_ready[1] && (&current->LSQ[index])->idep_ready[2]))
   {
    readyq_enqueue (&current->LSQ[index]);
   }
  }
 }


}
# 6033 "sim-outorder.c"
int md_valid_addr(md_addr_t ADDR, int threadid)
{
  context *current;
  current = thecontexts[threadid];
  int ret = ((ADDR) >= current->ld_text_base && (ADDR) < (current->ld_text_base + current->ld_text_size))
         || ((ADDR) >= current->ld_data_base && (ADDR) < current->ld_brk_point)
    || ((ADDR) >= (current->ld_stack_base - 16*1024*1024) && (ADDR) < current->ld_stack_base)
    || (ADDR >= 0x4000000 && ADDR < (current->ld_stack_base - 16*1024*1024) ) ;

  if (ret == 0)
  {

    return 1;
  }
 return 1;

}



 static void
ruu_issue (void)
{
 int k, i, load_lat, tlb_lat, n_issued;
 struct RS_link *node, *next_node;
 struct res_template *fu;
 int inter = -1;
 int this_cycle_issued[64];
 int mm;
 int delay = 0;
 bool_t bLSQHit = 0;
 bool_t bPartialHit = 0;
 int nW1;


 int use_mshr = 0;


 int parentID;

 context *current;
 int threadid;


 int issueLimit;

 int temp;



 int pullbackDelay[64];

 for (k = 0; k < numcontexts; k++)
 {
  pullbackDoneThisCycle[k] = 0;
  dl1MissThisCycle[k] = dl1HitThisCycle[k] = 0;
  pullbackDelay[k] = 0;

  if (pullbackWaitCycle[k])
  {
   pullbackWaitCycle[k]--;
  }

  if (pullbackBubble[k] && !pullbackWaitCycle[k])
  {
   pullbackCycleCount[k]++;
   pullbackBubble[k]--;
   pullbackDelay[k] = 1;
  }
 }



 for (temp = 0; temp < numcontexts; temp++)
 {
  issue_done[temp] = 0;
  this_cycle_issued[temp] = 0;
  loadRejectCount[temp] = 0;
  replayIndex[temp] = 0;
 }

 node = ready_queue;
 ready_queue = ((void *)0);



 issueLimit = (ruu_issue_width ) * numcontexts;
 int inorder_stall[64] = {0};
 int inorder_stall_ruunum[64] = {0};

 for (n_issued = 0; node && n_issued < issueLimit; node = next_node)
 {

  use_mshr = 0;


  next_node = node->next;



  if (((node)->tag == (node)->rs->tag))
  {
   struct RUU_station *rs = ((node)->rs);

   current = thecontexts[rs->threadid];
   threadid = rs->threadid;
   if (!((rs)->idep_ready[0] && (rs)->idep_ready[1] && (rs)->idep_ready[2]) || !rs->queued || rs->issued || rs->completed)
    _panic("sim-outorder.c", __FUNCTION__, 6140, "issued inst !ready, issued, or completed");

   rs->queued = 0;

   if(ruu_inorder_issue)
   {
    int rs_index = rs->index;
    if(i = rs->in_LSQ)
    {
     if(rs->prod[1] == ((void *)0))
      _panic("sim-outorder.c", __FUNCTION__, 6150, "There is no address producer of load/store\n");
     rs_index = rs->prod[1]->index;
    }
    if(inorder_stall[threadid] && rs_index > inorder_stall_ruunum[threadid])
    {
     readyq_enqueue (rs);
     { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
     continue;
    }
    if (((md_op2fu[rs->op]) > 3) && ((md_op2fu[rs->op]) < 10))
    {
     for(i = thecontexts[threadid]->RUU_head; i < rs_index; i = (i+1)%RUU_size)
     {
      if (((md_op2fu[thecontexts[threadid]->RUU[i].op]) > 3) && ((md_op2fu[thecontexts[threadid]->RUU[i].op]) < 10))
      {
       if(!thecontexts[threadid]->RUU[i].issued)
        break;
       if(thecontexts[threadid]->RUU[i].ea_comp && !current->RUU[i].odep_list[0]->rs->issued)
        break;
      }
     }
    }
    else
    {
     for(i = thecontexts[threadid]->RUU_head; i < rs_index; i = (i+1)%RUU_size)
     {
      if (!(((md_op2fu[thecontexts[threadid]->RUU[i].op]) > 3) && ((md_op2fu[thecontexts[threadid]->RUU[i].op]) < 10)))
      {
       if(!thecontexts[threadid]->RUU[i].issued)
        break;
       if(thecontexts[threadid]->RUU[i].ea_comp && !current->RUU[i].odep_list[0]->rs->issued)
        break;
      }
     }
    }
    if(i != rs_index)
    {
     readyq_enqueue (rs);
     { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
     inorder_stall[threadid] = 1;
     inorder_stall_ruunum[threadid] = rs_index;
     continue;
    }
    if(rs->in_LSQ && thecontexts[threadid]->LSQ_num)
    {
     if(thecontexts[threadid]->LSQ[(thecontexts[threadid]->LSQ_tail+LSQ_size-1)%LSQ_size].miss_flag)
     {
      readyq_enqueue (rs);
      { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
      continue;
     }
    }

   }
   inorder_stall[threadid] = 0;
# 6213 "sim-outorder.c"
   if (pullbackDelay[rs->threadid])
   {
    readyq_enqueue (rs);
    { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    continue;
   }


   if (issue_done[threadid] == (ruu_issue_width ))
   {
    readyq_enqueue (rs);
    { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    continue;
   }

   if (loadRejectCount[threadid])
   {
    readyq_enqueue (rs);
    { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    continue;
   }
   if(rs->cache_ready ==1)
   {
    readyq_enqueue (rs);
    { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    continue;
   }


   if (rs->issue_time > sim_cycle)
   {
    readyq_enqueue (rs);
    { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
    continue;
   }

   if (((rs->when_ready[0] <= sim_cycle) && (rs->when_ready[1] <= sim_cycle) && (rs->when_ready[2] <= sim_cycle) && (rs->when_inq < sim_cycle) && !rs->in_qwait))
   {


    if (!((md_op2flags[rs->op]) & 0x00000004))
    {
     if ((rs->out1 > 0) && (rs->out1 < 32))
     {
      iselection_access++;
      current->iselection_access++;
     }
     if ((rs->out1 > 31) && (rs->out1 < 63))
     {
      fselection_access++;
      current->fselection_access++;
     }
    }

    int ll_sc = 0;

    if (rs->op == SC || rs->op == LL)
    {

     ll_sc++;

    }

    if (rs->in_LSQ && (((md_op2flags[rs->op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080)))
    {



     md_addr_t addr;

      addr = rs->addr;

     int valid_addr = md_valid_addr (addr, current->masterid);
     int i;

     if (!valid_addr)
      sim_invalid_addrs++;



     use_mshr = 1;


     fu = res_get (fu_pool, (md_op2fu[rs->op]), threadid);

     if (!fu)
     {
      readyq_enqueue (rs);
      { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
      continue;
     }


     if (fu->master->busy)
      _panic("sim-outorder.c", __FUNCTION__, 6307, "functional unit already in use");


     if (valid_addr && dtlb[threadid])
     {
      tlb_lat = 0;
      tlb_lat = cache_access (dtlb[threadid], Read, (addr & ~3), ((void *)0), 4, sim_cycle, ((void *)0), ((void *)0), ((void *)0), threadid, ((void *)0));
      if(tlb_lat > dtlb[threadid]->hit_latency)
      {
       rs->issue_time = sim_cycle + tlb_lat;
       readyq_enqueue (rs);
       { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
       continue;
      }
     }


      if (isMSHRFull(cache_dl1[threadid]->mshr, 0, threadid))
      {
       readyq_enqueue (rs);
       { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
       continue;
      }


     fu->master->busy = fu->issuelat;
     rs->issued = 1;
     rs->issue_time = sim_cycle;
     rs->completed = 1;
     rs->finish_time = sim_cycle;


     if (valid_addr && (rs->op != SC) && prefetch_flag)
     {
      int lat = 0;
      rsCacheAccess = rs;
      int matchnum = 0;
      dcache_access++;
      current->dcache_access++;
      matchnum = MSHR_block_check(cache_dl1[threadid]->mshr, addr, cache_dl1[threadid]->set_shift);
      if(!matchnum)
      {
       if (cache_dl1[threadid])
        lat = cache_access (cache_dl1[threadid], Write, (addr & ~3), ((void *)0), 4, sim_cycle, ((void *)0), ((void *)0), rs, rs->threadid, ((void *)0));


       if(lat > cache_dl1_lat)
        MSHRLookup(cache_dl1[threadid]->mshr, addr, lat, 0, rs);

      }
      else
       cache_dl1[threadid]->in_mshr ++;
      if(lat>cache_dl1_lat)
       rs->miss_flag = 1;
      else
       rs->miss_flag = 0;
     }

     rs->issued = 1;
     rs->completed = 1;
     rs->issue_time = sim_cycle;
     rs->finish_time = sim_cycle;

     if (rs->counted_iissueq)
     {
      current->iissueq_thrd--;
      iissueq--;
      iissueq_cl[rs->threadid]--;
      rs->counted_iissueq = 0;
     }
     if (rs->counted_fissueq)
     {
      current->fissueq_thrd--;
      fissueq--;
      fissueq_cl[rs->threadid]--;
      rs->counted_fissueq = 0;
     }


     if (rs->onames[0] || rs->onames[1])
      _panic("sim-outorder.c", __FUNCTION__, 6387, "store creates result");

     if (rs->recover_inst)
      _panic("sim-outorder.c", __FUNCTION__, 6390, "mis-predicted store");

     if (ptrace_active) __ptrace_newstage((rs->ptrace_seq),("WB"),(0));
     n_issued++;


     issue_done[rs->threadid]++;


     current->iqram_access++;

     if (rs->issue_time && rs->issue_time != sim_cycle)
      _warn("sim-outorder.c", __FUNCTION__, 6402, "already issue timed on another cycle");
     else
      rs->issue_time = sim_cycle;

     for (k = 0; k < 3; k++)
     {
      if (rs->when_idep_ready[k] < sim_cycle)
      {
       if ((rs->idep_name[k] > 0) && (rs->idep_name[k] < 32))
       {
        iregfile_access++;
        current->iregfile_access++;
        iregfile_access_cl[rs->cluster]++;
        if (k)
         iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
        else
         iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
        iregfile_num_pop_count_cycle++;
       }
       if ((rs->idep_name[k] > 31) && (rs->idep_name[k] < 63))
       {
        fregfile_access++;
        current->fregfile_access++;
        fregfile_access_cl[rs->cluster]++;
        if (k)
         iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
        else
         iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
        iregfile_num_pop_count_cycle++;
       }
      }
     }

     this_cycle_issued[rs->cluster]++;
     current->lsq_access++;
     lsq_store_data_access++;
     current->lsq_preg_access++;





     i = rs->index;
     bLSQHit = 0;
     nW1 = GetMemAccWidth (rs->op);

     for (;;)
     {
      bLSQHit = 0;
      if (rs->isPrefetch)
       break;

      i = (i + (LSQ_size + 1)) % LSQ_size;

      if (i == current->LSQ_tail)
       break;


      if (((md_op2flags[current->LSQ[i].op]) & 0x00000040)

        && (((&current->LSQ[i])->idep_ready[0] && (&current->LSQ[i])->idep_ready[1] && (&current->LSQ[i])->idep_ready[2])) && (current->LSQ[i].threadid == rs->threadid) && current->LSQ[i].issued




        && !current->LSQ[i].isPrefetch)
      {
       int nW2 = GetMemAccWidth (current->LSQ[i].op);
       int nW = (nW1 >= nW2) ? nW1 : nW2;

       md_addr_t qwAddr1 = addr & ~(nW - 1);
       md_addr_t qwAddr2 = current->LSQ[i].addr & ~(nW - 1);

       if (qwAddr1 == qwAddr2)
       {
        bLSQHit = 1;
        break;




       }
      }
# 6502 "sim-outorder.c"
     }

     if (bLSQHit)
     {
      if (!loadRejectCount[threadid])
      {
       m_sqNumLdReplay[threadid]++;
       loadRejectReplay[threadid] = i;
       replayIndex[threadid] = current->LSQ[i].robEntry;
       loadRejectCount[threadid]++;

      }


      current->LSQ[i].sqStoreForwardT = rs->disp_time;

     }
    }
    else
    {

     if ((md_op2fu[rs->op]) != 0)
     {

      if (rs->in_LSQ && (((md_op2flags[rs->op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040)))
      {
       inter = (rs->addr >> cache_dl1[rs->threadid]->set_shift) & (res_membank - 1);
      }
      else if (!0 || ((md_op2fu[rs->op]) != IntALU))
      {

       inter = 2000 + rs->cluster;
      }
      else
      {
       if (rs->ea_comp)
       {
        inter = RES_CACHEPORTS + 1;
       }
       else
       {
        inter = RES_CACHEPORTS + 2;
       }
      }

      fu = res_get (fu_pool, (md_op2fu[rs->op]), threadid);

      if (fu)
      {
       rs->issued = 1;
       if (rs->counted_iissueq)
       {
        current->iissueq_thrd--;
        iissueq--;
        iissueq_cl[rs->threadid]--;
        rs->counted_iissueq = 0;
       }
       if (rs->counted_fissueq)
       {
        current->fissueq_thrd--;
        fissueq--;
        fissueq_cl[rs->threadid]--;
        rs->counted_fissueq = 0;
       }

       if (fu->master->busy)
        _panic("sim-outorder.c", __FUNCTION__, 6568, "functional unit already in use");

       fu->master->usr_id = threadid;
       fu->master->duplicate = rs->duplicate;
       fu->master->busy = fu->issuelat;


       if (rs->in_LSQ && (((md_op2flags[rs->op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040)))
       {
        int events = 0;
        load_lat = 0;
        md_addr_t addr;
         addr = rs->addr;

        if (dtlb[threadid] && md_valid_addr (addr, current->masterid))
        {
         tlb_lat = 0;
         tlb_lat = cache_access(dtlb[threadid], Read, (addr & ~3), ((void *)0), 4, sim_cycle, ((void *)0), ((void *)0), ((void *)0), rs->threadid, ((void *)0));
         if (tlb_lat > dtlb[threadid]->hit_latency)
         {
          rs->issue_time = sim_cycle + tlb_lat;
          fu->master->busy = 0;
          rs->issued = 0;
          readyq_enqueue (rs);
          { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
          continue;
         }
        }
        int matchnum;
        matchnum = MSHR_block_check(cache_dl1[threadid]->mshr, addr, cache_dl1[threadid]->set_shift);
        if(matchnum && !rs->isPrefetch)
        {
         cache_dl1[threadid]->in_mshr ++;
         rs->cache_ready = 1;
         fu->master->busy = 0;
         rs->issued = 0;
         RS_block_list(rs, sim_cycle, matchnum, threadid);

         { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
         continue;
        }


         if (isMSHRFull(cache_dl1[threadid]->mshr, 0, threadid))
         {
          fu->master->busy = 0;
          rs->issued = 0;
          readyq_enqueue (rs);
          { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
          continue;
         }


        current->lsq_access++;
        current->lsq_wakeup_access++;


        ldIssueCount++;

        i = rs->index;
        nW1 = GetMemAccWidth (rs->op);
        for (;;)
        {
         i = (i + (LSQ_size + 1)) % LSQ_size;

         if (i == current->LSQ_tail)
          break;

         if (((md_op2flags[current->LSQ[i].op]) & 0x00000040)
           && (((&current->LSQ[i])->idep_ready[0] && (&current->LSQ[i])->idep_ready[1] && (&current->LSQ[i])->idep_ready[2])) && (current->LSQ[i].threadid == rs->threadid) && current->LSQ[i].issued
           && !current->LSQ[i].isPrefetch)
         {
          int nW2 = GetMemAccWidth (current->LSQ[i].op);
          int nW = (nW1 >= nW2) ? nW1 : nW2;

          md_addr_t qwAddr1 = addr & ~(nW - 1);
          md_addr_t qwAddr2 = current->LSQ[i].addr & ~(nW - 1);

          if ((qwAddr1 == qwAddr2) && current->LSQ[i].invalidationReceived)
          {
           if (!loadRejectCount[threadid])
           {
            m_sqNumLdReplay[threadid]++;
            loadRejectReplay[threadid] = i;
            replayIndex[threadid] = current->LSQ[i].robEntry;
            loadRejectCount[threadid]++;
            invalidation_replay[threadid]++;
            break;
           }
          }
         }
        }



        int ldstReplay = 1;

        if (!rs->isPrefetch)
         ldstReplay = checkLSQforSt (rs->index, current);

        if (!ldstReplay)
        {
# 6685 "sim-outorder.c"
         rs->issued = 0;
         rs->issue_time = sim_cycle + rejectRetryCycle;
         readyq_enqueue (rs);
         { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
         ldstRejectionCount[threadid]++;
         continue;
        }


        bLSQHit = 0;
        bPartialHit = 0;

        i = rs->index;
        nW1 = GetMemAccWidth (rs->op);


        int lsq_lat = 0;
        if (i != current->LSQ_head && !rs->isPrefetch)
        {

         for (;;)
         {


          i = (i + (LSQ_size - 1)) % LSQ_size;


          if (((md_op2flags[current->LSQ[i].op]) & 0x00000080)


            && (((&current->LSQ[i])->idep_ready[1]))

            && (current->LSQ[i].threadid == rs->threadid) && !current->LSQ[i].isPrefetch)
          {
           int nW2 = GetMemAccWidth (current->LSQ[i].op);
           int nW = (nW1 >= nW2) ? nW1 : nW2;
           md_addr_t qwAddr1 = addr & ~(nW - 1);
           md_addr_t qwAddr2 = current->LSQ[i].addr & ~(nW - 1);

           if (qwAddr1 == qwAddr2)
           {
            bLSQHit = 1;
            if (nW1 > nW2)
            {


             bPartialHit = 1;
             break;
            }
           }
          }

          if (bLSQHit)
          {



           lsq_lat = 4;
           rs->sqStoreForwardT = current->LSQ[i].disp_time;
           break;
          }

          if (i == current->LSQ_head)
           break;
         }
        }


        int valid_addr = md_valid_addr (addr, current->masterid);

        if (!current->spec_mode && !valid_addr)
         sim_invalid_addrs++;

        if (cache_dl1[threadid] && valid_addr && !(matchnum))
        {

         dcache_access++;
         current->dcache_access++;
         rsCacheAccess = rs;
         load_lat = cache_access(cache_dl1[threadid], Read, (addr & ~3), ((void *)0), 4, sim_cycle, ((void *)0), ((void *)0), rs, rs->threadid, ((void *)0));



         if(load_lat >= 800000000 && rs->sqStoreForwardT == -1)
          MSHRLookup(cache_dl1[threadid]->mshr, addr, load_lat, 0, rs);
         else if(load_lat >= 800000000 && rs->sqStoreForwardT != -1)
          MSHRLookup(cache_dl1[threadid]->mshr, addr, load_lat, 0, ((void *)0));

         if (load_lat > cache_dl1_lat)
          events |= 0x00000001;
         if(load_lat>cache_dl1_lat)
          rs->miss_flag = 1;
         else
          rs->miss_flag = 0;
        }
        else
        {
         load_lat = fu->oplat;
        }


        if (load_lat > cache_dl1_lat && !rs->isPrefetch)
        {
         dl1MissThisCycle[rs->threadid] = 1;

         if (rs->op != LDC1 )
         {
          if (!pullbackDoneThisCycle[rs->threadid])
          {
           if (pullbackWaitCycle[rs->threadid])
            pullbackBubble[rs->threadid]++;
           else
            pullbackBubble[rs->threadid] = 2;
           pullbackDoneThisCycle[rs->threadid] = 1;
          }
          if (!pullbackWaitCycle[rs->threadid])
          {
           pullbackWaitCycle[rs->threadid] = 2;
          }
         }

        }
        else if (!rs->isPrefetch)
        {
         dl1HitThisCycle[rs->threadid] = 1;

         if (rs->op == LDC1)
         {
          load_lat = cache_dl1_lat + 1;
         }
        }



        if (0)
        {
         load_lat = 1;
        }

        if (lsq_lat)
        {
         load_lat = lsq_lat;
        }
        if (rs->isPrefetch)
        {
         load_lat = cache_dl1_lat;
         if (!rs->spec_mode)
          m_sqPrefetchCnt++;
        }


        if (bPartialHit)

         eventq_queue_event (rs, sim_cycle + load_lat + 5, load_lat+5);
        else

         eventq_queue_event(rs, sim_cycle + load_lat, load_lat);

        if (!rs->ea_comp)
        {
         rs->finish_time = (sim_cycle + load_lat);
         rs->issue_time = sim_cycle;
        }


        if (ptrace_active) __ptrace_newstage((rs->ptrace_seq),("EX"),(((rs->ea_comp ? 0x00000010 : 0) | events)));
       }
       else
       {


        if (((md_op2fu[rs->op]) > 3) && ((md_op2fu[rs->op]) < 10))
         fqram_access_cl[rs->cluster]++;
        else
         iqram_access_cl[rs->cluster]++;


        if ((md_op2fu[rs->op]) == IntALU)
        {
         ialu1_access++;
         current->ialu1_access++;

         if (rs->ea_comp)
         {
          add_alu++;
         }
         else
         {
          nonadd_alu++;
         }
        }
        else if (((md_op2fu[rs->op]) == IntMULT) || ((md_op2fu[rs->op]) == IntDIV))
        {
         ialu2_access++;
         current->ialu2_access++;
        }
        else if (((md_op2fu[rs->op]) == FloatMULT) || ((md_op2fu[rs->op]) == FloatDIV))
        {
         falu2_access++;
         current->falu2_access++;
        }
        else
        {
         falu1_access++;
         current->falu1_access++;
        }
        eventq_queue_event (rs, sim_cycle + fu->oplat, 0);
        rs->finish_time = (sim_cycle + fu->oplat);
        rs->issue_time = sim_cycle;
        if (ptrace_active) __ptrace_newstage((rs->ptrace_seq),("EX"),(rs->ea_comp ? 0x00000010 : 0));
       }


       n_issued++;
       issue_done[rs->threadid]++;

       if (((md_op2fu[rs->op]) > 3) && ((md_op2fu[rs->op]) < 10))
       {
        fqram_access++;
        current->fqram_access++;
       }
       else
       {
        iqram_access++;
        current->iqram_access++;
       }

       this_cycle_issued[rs->cluster]++;

       for (k = 0; k < 3; k++)
       {
        if (rs->when_idep_ready[k] < sim_cycle)
        {
         if ((rs->idep_name[k] > 0) && (rs->idep_name[k] < 32))
         {
          iregfile_access++;
          current->iregfile_access++;
          iregfile_access_cl[rs->cluster]++;
          if (k)
           iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
          else
           iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
          iregfile_num_pop_count_cycle++;
         }
         if ((rs->idep_name[k] > 31) && (rs->idep_name[k] < 63))
         {
          fregfile_access++;
          current->iregfile_access++;
          fregfile_access_cl[rs->cluster]++;
          if (k)
           iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
          else
           iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
          iregfile_num_pop_count_cycle++;
         }
        }
       }
      }
      else
      {
       readyq_enqueue (rs);
       if (!rs->spec_mode)
        iss_stall++;
       if (inter < RES_CACHEPORTS)
       {
        if (!rs->spec_mode)
         bank_conf++;
       }
      }
     }
     else
     {
      rs->issued = 1;
      if (rs->counted_iissueq)
      {
       current->iissueq_thrd--;
       iissueq--;
       iissueq_cl[rs->threadid]--;
       rs->counted_iissueq = 0;
      }
      if (rs->counted_fissueq)
      {
       current->fissueq_thrd--;
       fissueq--;
       fissueq_cl[rs->threadid]--;
       rs->counted_fissueq = 0;
      }
      eventq_queue_event (rs, sim_cycle + 1, 0);
      if (!rs->ea_comp && rs->out1)
      {
       rs->finish_time = (sim_cycle + 1);
       rs->issue_time = sim_cycle;
      }


      if (ptrace_active) __ptrace_newstage((rs->ptrace_seq),("EX"),(rs->ea_comp ? 0x00000010 : 0));
      n_issued++;
      issue_done[rs->threadid]++;
      if (((md_op2fu[rs->op]) > 3) && ((md_op2fu[rs->op]) < 10))
      {
       fqram_access++;
       current->fqram_access++;
      }
      else
      {
       iqram_access++;
       current->iqram_access++;
      }
      if ((rs->instnum - current->RUU[current->RUU_head].instnum) > 120)
      {
       distilp++;
       if (!rs->spec_mode)
        distilp_valid++;
       rs->distissue = 1;
      }
      this_cycle_issued[rs->cluster]++;

      for (k = 0; k < 3; k++)
      {
       if (rs->when_idep_ready[k] < sim_cycle)
       {
        if ((rs->idep_name[k] > 0) && (rs->idep_name[k] < 32))
        {
         iregfile_access++;
         current->iregfile_access++;
         iregfile_access_cl[rs->cluster]++;
         if (k)
          iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
         else
          iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
         iregfile_num_pop_count_cycle++;
        }
        if ((rs->idep_name[k] > 31) && (rs->idep_name[k] < 63))
        {
         fregfile_access++;
         current->fregfile_access++;

         fregfile_access_cl[rs->cluster]++;
         if (k)
          iregfile_total_pop_count_cycle += pop_count (rs->val_rb);
         else
          iregfile_total_pop_count_cycle += pop_count (rs->val_ra);
         iregfile_num_pop_count_cycle++;
        }
       }
      }
     }
    }
   }
   else
   {
    readyq_enqueue (rs);
   }
  }
  { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
 }

 for (; node; node = next_node)
 {
  next_node = node->next;

  if (((node)->tag == (node)->rs->tag))
  {
   struct RUU_station *rs = ((node)->rs);

   rs->queued = 0;
   readyq_enqueue (rs);
  }
  { struct RS_link *f_link = (node); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; };
 }



 for (temp = 0; temp < numcontexts; temp++)
 {
  if (loadRejectCount[temp] & collect_stats == 1)
  {

   int k = replayIndex[temp];


   if (!thecontexts[temp]->RUU[k].spec_mode)
   {
    fixSpecState (k, temp);
    thecontexts[temp]->regs = thecontexts[temp]->RUU[k].backupReg;
    seqConsistancyReplay (k, temp);
    loadRejectStat[temp]++;
   }
  }
 }

 num_issued = n_issued;
}
# 7090 "sim-outorder.c"
 static void
rspec_dump (FILE * stream, int threadid)
{
 int i;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "Thread %d, ** speculative register contents **\n", threadid);

 fprintf (stream, "spec_mode: %s\n", current->spec_mode ? "t" : "f");


 for (i = 0; i < 32; i++)
 {
  if ((((current->use_spec_R)[(i)/32] & (1 << ((i) % 32))) != 0))
  {
   md_print_ireg (current->spec_regs_R, i, stream);
   fprintf (stream, "\n");
  }
 }


 for (i = 0; i < 32; i++)
 {
  if ((((current->use_spec_F)[(i)/32] & (1 << ((i) % 32))) != 0))
  {
   md_print_fpreg (current->spec_regs_F, i, stream);
   fprintf (stream, "\n");
  }
 }


 for (i = 0; i < 3; i++)
 {



   if ((((current->use_spec_C)[(i)/32] & (1 << ((i) % 32))) != 0))

   {
    md_print_creg (current->spec_regs_C, i, stream);
    fprintf (stream, "\n");
   }
 }
}
# 7150 "sim-outorder.c"
 static void
tracer_recover (int threadid)
{
 int i;
 struct spec_mem_ent *ent, *ent_next;

 context *current;

 current = thecontexts[threadid];



 if (!current->spec_mode)
  _panic("sim-outorder.c", __FUNCTION__, 7163, "Thread %d, cannot recover unless in speculative mode", threadid);
 current->spec_mode = 0;
 current->spec_mode_next = 0;
 if (current->waitForBranchResolve == 1)
  current->waitForBranchResolve = 0;
# 7176 "sim-outorder.c"
 { int i; for (i=0; i<(((((32)+31)/32))); i++) (current->use_spec_R)[i] = 0; };
 { int i; for (i=0; i<(((((32)+31)/32))); i++) (current->use_spec_F)[i] = 0; };
 { int i; for (i=0; i<(((((3)+31)/32))); i++) (current->use_spec_C)[i] = 0; };




 for (i = 0; i < 32; i++)
 {

  for (ent = current->store_htable[i]; ent; ent = ent_next)
  {
   ent_next = ent->next;
   ent->next = current->bucket_free_list;
   current->bucket_free_list = ent;
  }
  current->store_htable[i] = ((void *)0);
 }


 if (ptrace_active)
 {
  while (current->fetch_num != 0)
  {
   if (ptrace_active) __ptrace_endinst((current->fetch_data[current->fetch_head]->ptrace_seq));
   current->fetch_head = (current->fetch_head + 1) & (ruu_ifq_size - 1);
   current->fetch_num--;
  }
 }

 current->fetch_num = 0;
 current->fetch_tail = current->fetch_head = 0;
 current->fetch_pred_PC = current->fetch_regs_PC = current->recover_PC;
}


 static void
tracer_init (int threadid)
{
 int i;

 context *current;

 current = thecontexts[threadid];

 current->spec_mode = 0;
 current->spec_mode_next = 0;
 if (current->waitForBranchResolve == 1)
  current->waitForBranchResolve = 0;







 { int i; for (i=0; i<(((((32)+31)/32))); i++) (current->use_spec_R)[i] = 0; };
 { int i; for (i=0; i<(((((32)+31)/32))); i++) (current->use_spec_F)[i] = 0; };
 { int i; for (i=0; i<(((((3)+31)/32))); i++) (current->use_spec_C)[i] = 0; };

 for (i = 0; i < 32; i++)
  current->store_htable[i] = ((void *)0);
}
# 7256 "sim-outorder.c"
 static enum md_fault_type
spec_mem_access (struct mem_t *mem,
  enum mem_cmd cmd,
  md_addr_t addr,
  void *p,
  int nbytes)
{
 int i, index;
 struct spec_mem_ent *ent, *prev;

 context *current;
 int threadid = mem->threadid;

 current = thecontexts[threadid];





 if ((nbytes & (nbytes - 1)) != 0 || (addr & (nbytes - 1)) != 0)
 {

  for (i = 0; i < nbytes; i++)
   ((char *) p)[i] = 0;

  return md_fault_none;
 }

 if (!((addr >= current->ld_text_base && addr < (current->ld_text_base + current->ld_text_size) && cmd == Read) || md_valid_addr (addr, current->masterid)))
 {

  for (i = 0; i < nbytes; i++)
   ((char *) p)[i] = 0;

  return md_fault_none;
 }


 index = ((((addr) >> 24)^((addr) >> 16)^((addr) >> 8)^(addr)) & (32 -1));
 for (prev = ((void *)0), ent = current->store_htable[index]; ent; prev = ent, ent = ent->next)
 {
  if (ent->addr == addr)
  {

   if (prev != ((void *)0))
   {

    prev->next = ent->next;
    ent->next = current->store_htable[index];
    current->store_htable[index] = ent;
   }
   break;
  }
 }


 if (!ent && cmd == Write)
 {

  if (!current->bucket_free_list)
  {

   current->bucket_free_list = calloc (1, sizeof (struct spec_mem_ent));
   if (!current->bucket_free_list)
    _fatal("sim-outorder.c", __FUNCTION__, 7320, "thread %d , out of virtual memory", threadid);
  }
  ent = current->bucket_free_list;
  current->bucket_free_list = current->bucket_free_list->next;

  if (!bugcompat_mode)
  {

   ent->next = current->store_htable[index];
   current->store_htable[index] = ent;
   ent->addr = addr;
   ent->data[0] = 0;
   ent->data[1] = 0;
  }
 }


 switch (nbytes)
 {
  case 1:
   if (cmd == Read)
   {
    if (ent)
    {

     *((byte_t *) p) = *((byte_t *) (&ent->data[0]));
    }
    else
    {


     *((byte_t *) p) = (( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) ? *((byte_t *)(( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) : 0);
    }
   }
   else
   {

    *((byte_t *) (&ent->data[0])) = *((byte_t *) p);
   }
   break;
  case 2:
   if (cmd == Read)
   {
    if (ent)
    {

     *((half_t *) p) = *((half_t *) (&ent->data[0]));
    }
    else
    {


     *((half_t *) p) = ((( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) ? *((half_t *)(( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) : 0));
    }
   }
   else
   {

    *((half_t *) & ent->data[0]) = *((half_t *) p);
   }
   break;
  case 4:
   if (cmd == Read)
   {
    if (ent)
    {

     *((word_t *) p) = *((word_t *) & ent->data[0]);
    }
    else
    {


     *((word_t *) p) = ((( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) ? *((word_t *)(( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) : 0));
    }
   }
   else
   {

    *((word_t *) & ent->data[0]) = *((word_t *) p);
   }
   break;
  case 8:
   if (cmd == Read)
   {
    if (ent)
    {

     *((word_t *) p) = *((word_t *) & ent->data[0]);
     *(((word_t *) p) + 1) = *((word_t *) & ent->data[1]);
    }
    else
    {


     *((word_t *) p) = ((( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) ? *((word_t *)(( ((mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) : 0));
     *(((word_t *) p) + 1) = ((( ((mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr + sizeof (word_t))) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr + sizeof (word_t)))))) ? *((word_t *)(( ((mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))] && (mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr + sizeof (word_t))) >> (12 + 15))) ? ( (mem)->ptab_accesses++, (mem)->ptab[((((md_addr_t)(addr + sizeof (word_t))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((mem), ((md_addr_t)(addr + sizeof (word_t)))))) + ((addr + sizeof (word_t)) & (4096 - 1)))) : 0));
    }
   }
   else
   {

    *((word_t *) & ent->data[0]) = *((word_t *) p);
    *((word_t *) & ent->data[1]) = *(((word_t *) p) + 1);
   }
   break;
  default:
   _panic("sim-outorder.c", __FUNCTION__, 7427, "access size not supported in mis-speculative mode");
 }

 return md_fault_none;
}


 static void
mspec_dump (FILE * stream, int threadid)
{
 int i, j;
 struct spec_mem_ent *ent;

 context *current;

 current = thecontexts[threadid];

 if (!stream)
  stream = stderr;

 fprintf (stream, "Thread %d,  ** speculative memory contents **\n", threadid);

 fprintf (stream, "spec_mode: %s\n", current->spec_mode ? "t" : "f");

 for (j = 0; j < numcontexts; j++)
 {
  fprintf (stream, "thread %d : \n", j);
  for (i = 0; i < 32; i++)
  {

   for (ent = thecontexts[j]->store_htable[i]; ent; ent = ent->next)
   {
    myfprintf (stream, "[0x%08p]: %12.0f/0x%08x:%08x\n", ent->addr, (double) (*((double *) ent->data)), *((unsigned int *) &ent->data[0]), *(((unsigned int *) &ent->data[0]) + 1));
   }
  }
 }
}


 static char *
simoo_mem_obj (struct mem_t *mem,
  int is_write,
  md_addr_t addr,
  char *p,
  int nbytes)
{
 enum mem_cmd cmd;

 int threadid = mem->threadid;
 context *current;

 current = thecontexts[threadid];

 if (!is_write)
  cmd = Read;
 else
  cmd = Write;
# 7494 "sim-outorder.c"
 if (current->spec_mode)
  spec_mem_access (mem, cmd, addr, p, nbytes);
 else
  mem_access (mem, cmd, addr, p, nbytes, threadid);


 return ((void *)0);
}




 void
flushWriteBuffer (int threadid)
{
 int index;
 struct wb_mem_ent *ent, *prev;
 int nbytes;
 byte_t *p, *q;
 md_addr_t addr;
 int ii;

 context *current = thecontexts[threadid];

 for (ent = current->WBtableTail; ent != ((void *)0); ent = ent->prev)
 {
  p = ent->data;
  nbytes = ent->nbytes;
  addr = ent->addr;


  if (!ent->writeAlreadyDone)
  {
   while (nbytes-- > 0)
   {
    ((!( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) ? ( mem_newpage(current->mem, (md_addr_t)(addr))) : ( (void)0)), *((byte_t *)(( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) = (*((byte_t *) p)));
    p += sizeof (byte_t);
    addr += sizeof (byte_t);
   }
  }

  ent->writeAlreadyDone = 1;
 }
 return;
}


 void
completeStore (int threadid, md_addr_t addr, int width, int isFail)
{

 byte_t *p, *q;
 context *current;
 struct wb_mem_ent *ent = ((void *)0), *prev= ((void *)0);


 int nbytes;
 enum md_opcode op;
 md_addr_t inst;
 int do_write = 1;
 int jj;
 int accessed;

 current = thecontexts[threadid];
 ent = thecontexts[threadid]->WBtableTail;

 if ((width & (width - 1)) != 0 || (addr & (width - 1)) != 0)
  return;

 p = ent->data;
 nbytes = ent->nbytes;
 if (addr != ent->addr)
  printf("PC %x ent->addr %x\n", ent-> PC ,ent->addr);
 if (addr != ent->addr)
  _panic("sim-outorder.c", __FUNCTION__, 7568, "write buffer miss-alignment\n");

 { op = md_mask2op[(((ent->instr) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((ent->instr >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };
 inst = ent->instr;

 p = ent->data;
 nbytes = ent->nbytes;


 if (op != SC)
 {

  if (!ent->writeAlreadyDone)
  {
   while (nbytes-- > 0)
   {
    ((!( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) ? ( mem_newpage(current->mem, (md_addr_t)(addr))) : ( (void)0)), *((byte_t *)(( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) = (*((byte_t *) p)));
    p += sizeof (byte_t);
    addr += sizeof (byte_t);
   }
  }

 }
 else
 {




  if (!isFail && (common_regs_s[current->masterid][current->actualid].regs_lock != 0) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))
  {
   do_write = 1;

   for (jj = 0; jj < 64; jj++)
   {
    if (common_regs_s[current->masterid][jj].address == ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))

    {

     common_regs_s[current->masterid][jj].regs_lock = 0;
     common_regs_s[current->masterid][jj].address = 0;

    }
   }
   if (!ent->writeAlreadyDone)
   {

    while (nbytes-- > 0)
    {
     ((!( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) ? ( mem_newpage(current->mem, (md_addr_t)(addr))) : ( (void)0)), *((byte_t *)(( ((current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))] && (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)(addr)) >> (12 + 15))) ? ( (current->mem)->ptab_accesses++, (current->mem)->ptab[((((md_addr_t)(addr)) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate((current->mem), ((md_addr_t)(addr))))) + ((addr) & (4096 - 1)))) = (*((byte_t *) p)));
     p += sizeof (byte_t);
     addr += sizeof (byte_t);
    }
   }
   storeCondFail = 0;
  }
  else
  {
   current->regs.regs_R[((inst >> 16) & 0x1f)] = 0;
   do_write = 0;
   storeCondFail = 1;
  }
  current->waitForSTLC = 0;

 }
 accessed = ent->accessed;
 current->numOfWBEntry--;
 if ((ent->prev == ((void *)0)) && (ent->next == ((void *)0)))
 {
  current->WBtableTail = ((void *)0);
  current->WBtableHead = ((void *)0);
  ent->next = current->WBbucket_free_list;
  current->WBbucket_free_list = ent;
 }
 else if (ent->next == ((void *)0))
 {
  current->WBtableTail = ent->prev;
  ent->prev->next = ((void *)0);
  ent->next = current->WBbucket_free_list;
  current->WBbucket_free_list = ent;

 }
 else if (ent->prev == ((void *)0))
 {
  current->WBtableHead = ent->next;
  ent->next->prev = ((void *)0);
  ent->next = current->WBbucket_free_list;
  current->WBbucket_free_list = ent;
 }
 else
 {
  ent->prev->next = ent->next;
  ent->next->prev = ent->prev;
  ent->next = current->WBbucket_free_list;
  current->WBbucket_free_list = ent;
 }
}



 void
commitWrite (md_addr_t addr, int threadID, counter_t completeCycle, int needBusAccess, int accessed)
{
 int index;
 struct wb_mem_ent *ent;
 context *current;
 enum md_opcode op;
 int lat = 0;
 int port_lat = 0, now_lat = 0, port_now = 0;


 current = thecontexts[threadID];
 if (!COHERENT_CACHE)
 {
  printf ("This is not TRUE for non-coherent cache\n");
  exit (0);
 }
 index = 0;
 for (ent = current->WBtableHead; ent; ent = ent->next)
 {
  if (ent->addr == addr && !ent->completeCycle)
  {
   { op = md_mask2op[(((ent->instr) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((ent->instr >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };
   if ( op == SC )
   {
    ent->completeCycle = sim_cycle + lat;
    ent->needBusAccess = 1;
    ent->accessed = accessed;
   }
   else
   {
    ent->completeCycle = completeCycle;
    ent->needBusAccess = needBusAccess;
    ent->accessed = accessed;
   }

  }
 }
}
# 7738 "sim-outorder.c"
 enum md_fault_type
WB_access1 (struct mem_t *mem, enum mem_cmd cmd, md_addr_t addr, void *p, int nbytes, int threadID, md_addr_t instr)
{
 enum md_opcode op;
 enum md_fault_type return_type;

 TempInstr = instr;
 { op = md_mask2op[(((TempInstr) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((TempInstr >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };

 if(!thecontexts[threadID]->spec_mode && (addr <= thecontexts[0]->ld_stack_base) && (addr > thecontexts[0]->ld_stack_base-numcontexts*0x90000) && !(addr <= thecontexts[threadID]->ld_stack_base && addr > thecontexts[threadID]->ld_stack_base-0x90000))
  _panic("sim-outorder.c", __FUNCTION__, 7748, "Stack boundaries breached: May be the STACKSIZE parameter defined in context.h file is small for the application");
# 7763 "sim-outorder.c"
 if (COHERENT_CACHE && allForked)
 {
  if ( op == SC )
  {
   thecontexts[threadID]->waitForSTLC = 1;
  }
  return_type = mem_access (mem, cmd, addr, p, nbytes, threadID);




  if (access_mem && access_mem_id == threadID)
  {
   flushWriteBuffer (threadID);
  }
  return return_type;
 }
 else
 {
  return_type = mem_access_drct (mem, cmd, addr, p, nbytes, threadID);
  return return_type;
 }
}



 static inline void
ruu_link_idep (struct RUU_station *rs,
  int idep_num,
  int idep_name)
{
 struct CV_link head;
 struct RS_link *link;

 int threadid = rs->threadid;
 context *current;

 current = thecontexts[threadid];

 rs->prod[idep_num] = ((void *)0);
 rs->idep_name[idep_num] = idep_name;

 if (idep_name == 0)
 {

  rs->idep_ready[idep_num] = 1;
  rs->when_ready[idep_num] = 0;
  rs->when_idep_ready[idep_num] = 800000000;
  return;
 }

 head = ((((current->use_spec_cv)[((idep_name))/32] & (1 << (((idep_name)) % 32))) != 0) ? current->spec_create_vector[idep_name] : current->create_vector[idep_name]);


 if (!head.rs || head.rs->completed)
 {
  rs->idep_ready[idep_num] = 1;
  rs->when_ready[idep_num] = sim_cycle - 1;
  rs->when_idep_ready[idep_num] = sim_cycle - 1;
  return;
 }
 rs->idep_ready[idep_num] = 0;
 rs->prod[idep_num] = head.rs;

 { struct RS_link *n_link; if (!rslink_free_list) _panic("sim-outorder.c", __FUNCTION__, 7827, "out of rs links"); rs_link_num++; n_link = rslink_free_list; rslink_free_list = rslink_free_list->next; n_link->next = ((void *)0); n_link->rs = (rs); n_link->tag = n_link->rs->tag; n_link->last_use = sim_cycle; (link) = n_link; };
 link->x.opnum = idep_num;
 link->next = head.rs->odep_list[head.odep_num];
 head.rs->odep_list[head.odep_num] = link;
}

 int
needsWBflush (context * current, enum md_opcode op, md_addr_t addr)
{
 int nbytes = GetMemAccWidth (op);




 struct wb_mem_ent *ent;

 for (ent = current->WBtableHead; ent; ent = ent->next)
 {
  if (nbytes == 1)
  {
   if (!(ent->nbytes == nbytes))
   {
    if ((ent->addr <= addr) && ((ent->addr + ent->nbytes) > addr))
    {
     return 1;
    }
   }
  }
  else if (nbytes == 2)
  {
   if (ent->nbytes != nbytes)
   {
    if (ent->nbytes < nbytes)
    {
     if ((ent->addr >= addr) && (ent->addr < (addr + nbytes)))
     {
      return 1;
     }
    }
    else
    {
     if ((addr >= ent->addr) && (addr < (ent->addr + ent->nbytes)))
     {
      return 1;
     }
    }
   }
  }
  else if (nbytes == 4)
  {
   if (nbytes != ent->nbytes)
   {
    if (ent->nbytes < nbytes)
    {
     if ((ent->addr >= addr) && (ent->addr < (addr + nbytes)))
     {
      return 1;
     }
    }
   }
  }
  else if (nbytes == 8)
  {
   if (nbytes != ent->nbytes)
   {
    if ((ent->nbytes == 1) || (ent->nbytes == 2) || (ent->nbytes == 4))
    {
     if ((ent->addr >= addr) && (ent->addr < (addr + nbytes)))
     {
      return 1;
     }
    }
   }
  }
 }
 return 0;
}




 static inline void
ruu_install_odep (struct RUU_station *rs,
  int odep_num,
  int odep_name)
{
 struct CV_link cv;

 context *current = thecontexts[rs->threadid];


 if (odep_name == 0)
 {

  rs->onames[odep_num] = 0;
  return;
 }


 rs->onames[odep_num] = odep_name;

 rs->odep_list[odep_num] = ((void *)0);


 ((cv).rs = (rs), (cv).odep_num = (odep_num));
 (current->spec_mode ? ((((current->use_spec_cv)[((odep_name))/32] |= (1 << (((odep_name)) % 32))), (current->use_spec_cv)), current->spec_create_vector[odep_name] = (cv)) : (current->create_vector[odep_name] = (cv)));
}



 static inline void
ruu_install_odep_skip (struct RUU_station *rs,
  int odep_num,
  int odep_name)
{


 if (odep_name == 0)
 {

  rs->onames[odep_num] = 0;
  return;
 }


 rs->onames[odep_num] = odep_name;

 rs->odep_list[odep_num] = ((void *)0);

}




 static char *
simoo_reg_obj (struct regs_t *xregs,
  int is_write,
  enum md_reg_type rt,
  int reg,
  struct eval_value_t *val)
{

 int threadid = 0;
 context *current;

 current = thecontexts[threadid];

 switch (rt)
 {
  case rt_gpr:
   if (reg < 0 || reg >= 32)
    return "register number out of range";

   if (!is_write)
   {
    val->type = et_uint;
    val->value.as_uint = ((((current->use_spec_R)[((reg))/32] & (1 << (((reg)) % 32))) != 0) ? current->spec_regs_R[reg] : current->regs.regs_R[reg]);
   }
   else
    (current->spec_mode ? ((current->spec_regs_R[reg] = (eval_as_uint (*val))), (((current->use_spec_R)[((reg))/32] |= (1 << (((reg)) % 32))), (current->use_spec_R)), current->spec_regs_R[reg]) : (current->regs.regs_R[reg] = (eval_as_uint (*val))));
   break;

  case rt_lpr:
   if (reg < 0 || reg >= 32)
    return "register number out of range";


   abort ();
   break;

  case rt_fpr:

   abort ();
   break;

  case rt_dpr:

   abort ();
   break;



  case rt_PC:
   if (!is_write)
   {
    val->type = et_addr;
    val->value.as_addr = current->regs.regs_PC;
   }
   else
    current->regs.regs_PC = eval_as_addr (*val);
   break;

  case rt_NPC:
   if (!is_write)
   {
    val->type = et_addr;
    val->value.as_addr = current->regs.regs_NPC;
   }
   else
    current->regs.regs_NPC = eval_as_addr (*val);
   break;

  default:
   _panic("sim-outorder.c", __FUNCTION__, 8030, "bogus register bank");
 }


 return ((void *)0);
}


static void ruu_fetch (void);

int stallCause[64] = {0};
counter_t mb_count = 0;







int isLockInst(md_addr_t PC)
{
 if(PC <= LockInitPC && PC >= LockInitPC - 68)
  return 1;
 else
  return 0;
}
int isBarRelInst(md_addr_t PC)
{
 if(PC <= last_last_pc + 112 && PC >= last_last_pc - 844)
  return 1;
 else
  return 0;
}

 int
ruu_dispatch (int threadid)
{
 int i;
 int tempcl;
 long temppc = 0;
 int mm, k;
 int force_bank;
 int slot;

 int n_dispatched;
 md_inst_t inst;
 enum md_opcode op;
 int out1, out2, in1, in2, in3;
 md_addr_t target_PC = 0;
 md_addr_t addr = 0;
 struct RUU_station *rs;
 struct RUU_station *lsq;


 struct RUU_station *rs_dup;
 struct bpred_update_t *dir_update_ptr;
 int stack_recover_idx;
 unsigned int pseq;
 int is_write = 0;
 int made_check;
 int br_taken, br_pred_taken;
 byte_t temp_byte;
 half_t temp_half;
 word_t temp_word;


 qword_t temp_qword = 0;

 qword_t regVal;
 half_t ushLdFlag;
   int delay_slot_ruu = 0, delay_slot_lsq = 0;
  md_inst_t delay_slot_inst;
 struct regs_t tempReg;


 struct regs_t tempRegPrev;

 enum md_fault_type fault;

 int soft_error, temp_fetch_num;


 qword_t val_ra = 0, val_rb = 0, val_rc = 0, val_ra_result = 0;
 void copy_to (int);
 int bank_lookup (md_addr_t, int, int);

 context *current;
 long fetch_time = 0;

 int second_run = 1, no_dsp_cls;

 int in_LSQ = 0;
 int lsq_full = 0;

 int parentID;

 int resource_need[4];

 resource_need[0] = 1;
 resource_need[1] = 1;
 resource_need[2] = 3;
 resource_need[3] = 3;

 current = thecontexts[threadid];

 n_dispatched = 0;
 temp_fetch_num = current->fetch_num;

 current->fetch_redirected = 0;
 stallCause[threadid] = 0;
 int lsq_miss_stall = 0;

  if (temp_fetch_num != 0)
 {
  made_check = 0;
  tempcl = actual_clusters;

  while (
    n_dispatched < (ruu_decode_width * fetch_speed)
    && current->LSQ_num < LSQ_size && current->m_shLQNum < m_shLQSize

    && (current->m_shSQNum + m_L1WBufCnt[threadid]) < m_shSQSize



    && (current->RUU_num < RUU_size)
    && temp_fetch_num != 0 && (ruu_include_spec || !current->spec_mode))
  {

   inst = current->fetch_data[current->fetch_head]->IR;
   { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };

   if ((md_op2flags[op]) & 0x00000020)
    in_LSQ = 1;
   else
    in_LSQ = 0;

   if (((md_op2fu[op]) > 3) && ((md_op2fu[op]) < 10))
   {
    resource_need[0] = 0;
    resource_need[1] = 1;
    resource_need[2] = 0;
    resource_need[3] = 3;
   }
   else
   {
    resource_need[0] = 1;
    resource_need[1] = 0;
    resource_need[2] = 3;
    resource_need[3] = 1;
   }





   if (((md_op2flags[op]) & 0x00000004 )&&
       !((iissueq_cl[threadid] <= (IIQ_size - resource_need[0]-1)) && (fissueq_cl[threadid] <= (FIQ_size - resource_need[1]))))
     {
       break;
     }
   if (!((iissueq_cl[threadid] <= (IIQ_size - resource_need[0])) && (fissueq_cl[threadid] <= (FIQ_size - resource_need[1])) && (iregfile_cl[threadid] <= ((IPREG_size) - resource_need[2])) && (fregfile_cl[threadid] <= ((FPREG_size) - resource_need[3]))))
   {
    if(!((iissueq_cl[threadid] <= (IIQ_size - resource_need[0])) && (fissueq_cl[threadid] <= (FIQ_size - resource_need[1]))))
     stallCause[threadid] = 5;
    if(!((iregfile_cl[threadid] <= ((IPREG_size) - resource_need[2])) && (fregfile_cl[threadid] <= ((FPREG_size) - resource_need[3]))))
     stallCause[threadid] = 4;
    break;
   }

   if ((thecontexts[threadid]->waitForBranchResolve == 1) || (thecontexts[threadid]->waitForSTLC))
   {
    stallCause[threadid] = 8;
    break;
   }
# 8219 "sim-outorder.c"
   if (collectStatStop[current->id])
   {
    break;
   }

   int j, bool = 0, tmp, ll_sc = 0;
   context *tmpCxt;
   md_addr_t mask;

   mask = ~cache_dl1[current->id]->blk_mask;


   inst = current->fetch_data[current->fetch_head]->IR;
   dir_update_ptr = &(current->fetch_data[current->fetch_head]->dir_update);
   stack_recover_idx = current->fetch_data[current->fetch_head]->stack_recover_idx;
   pseq = current->fetch_data[current->fetch_head]->ptrace_seq;
   fetch_time = current->fetch_data[current->fetch_head]->fetch_time;

   current->fetch_data[current->fetch_head]->is_dup = 1;
   if(m_update_miss_flag[threadid])
   {
     m_update_miss_flag[threadid] = 0;
     if(m_update_miss_depend_start[threadid])
      UpdateDependCycle += (sim_cycle - m_update_miss_depend_start[threadid]);
     m_update_miss_depend_start[threadid] = 0;
   }


   if (op == SC)
   {

    ll_sc++;

   }

   if (op == LL)
   {
    ll_sc++;
   }
   if((md_op2flags[op]) & 0x00040000)
    mb_count++;


   if ((md_op2flags[op]) & 0x00000800)
   {





    qword_t syscode = current->regs.regs_R[MD_REG_V0];
    if(current->spec_mode || !(syscode == 500 || syscode == 530 || syscode == 533 ))
    {
     if (current->RUU_num != 0)
     {
      stallCause[threadid] = 10;
      break;
     }
    }

    if (current->spec_mode)
     _panic("sim-outorder.c", __FUNCTION__, 8280, "drained and speculative");
   }


   current->regs.regs_PC = current->fetch_data[current->fetch_head]->regs_PC;
   current->pred_PC = current->fetch_data[current->fetch_head]->pred_PC;
   current->regs.regs_NPC = current->regs.regs_PC + sizeof (md_inst_t);


   if((((md_op2flags[op]) & (0x00000004)) == (0x00000004)) && (current->RUU_num >= RUU_size-1))
      break;

   current->regs.regs_R[MD_REG_ZERO] = 0;
   current->spec_regs_R[MD_REG_ZERO] = 0;






    addr = 0;
    is_write = 0;







    val_ra = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]);
    val_rb = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]);




    fault = md_fault_none;
    soft_error = 0;


    tempRegPrev = current->regs;


    ushLdFlag = 0;

     switch (op)
     {
# 8366 "sim-outorder.c"
# 1 "machine.def" 1
case SPECIAL_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case REGIMM_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;
# 12 "machine.def"
case JUMP: in1 = (0); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 26 "machine.def"
case JAL: in1 = (0); in2 = (0); in3 = (0); out1 = (31); out2 = (0); { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 41 "machine.def"
case BEQ: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 57 "machine.def"
case BNE: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) != ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 73 "machine.def"
case BLEZ: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) <= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 89 "machine.def"
case BGTZ: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) > 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 101 "machine.def"
case ADDI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((int)(( short)(inst & 0xffff))))) { if (!current->spec_mode) fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 110 "machine.def"
case ADDIU: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 122 "machine.def"
case SLTI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 134 "machine.def"
case SLTIU: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 143 "machine.def"
case ANDI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff)))); }; break;
# 152 "machine.def"
case ORI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff)))); }; break;
# 161 "machine.def"
case XORI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff)))); }; break;
# 170 "machine.def"
case LUI: in1 = (0); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16))); }; break;




case COP0_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case COP1_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case COP2_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case SPECIAL2_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;
# 193 "machine.def"
case LB: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { sbyte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 208 "machine.def"
case LH: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { shalf_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 249 "machine.def"
case LWL: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))))))); }; break;
# 265 "machine.def"
case LW: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 289 "machine.def"
case LL: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; if(!current->spec_mode && _result == 0) { common_regs_s[current->masterid][current->actualid].regs_lock = 1; common_regs_s[current->masterid][current->actualid].address = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))); } (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 307 "machine.def"
case LBU: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { byte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 322 "machine.def"
case LHU: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { half_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 362 "machine.def"
case LWR: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))]))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])))))); }; break;
# 377 "machine.def"
case SB: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { byte_t _src; enum md_fault_type _fault; _src = (byte_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_byte = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_byte, sizeof(temp_byte), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 392 "machine.def"
case SH: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { half_t _src; enum md_fault_type _fault; _src = (half_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_half = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_half, sizeof(temp_half), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 432 "machine.def"
case SWL: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (8 * (4 - (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)))) & (md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])) | (_lr_temp & ~(md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])+((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 447 "machine.def"
case SW: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 501 "machine.def"
case SC: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { word_t _src; enum md_fault_type _fault; int ii = 0; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if(COHERENT_CACHE && allForked && collect_stats) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if(_fault != md_fault_none) { { if (!current->spec_mode) fault = (_fault); break; }; } } else { if(!current->spec_mode) { if((common_regs_s[current->masterid][current->actualid].regs_lock == 1) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) + (((int)(( short)(inst & 0xffff)))))) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { { if (!current->spec_mode) fault = (_fault); break; }; } for(ii = 0; ii < 64; ii++) { if(common_regs_s[current->masterid][ii].address == (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))) { common_regs_s[current->masterid][ii].regs_lock = 0; common_regs_s[current->masterid][ii].address = 0; } } } else (current->spec_mode ? ((current->spec_regs_R[((inst >> 21) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] |= (1 << (((((inst >> 21) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 21) & 0x1f)]) : (current->regs.regs_R[((inst >> 21) & 0x1f)] = (0))); } else { current->waitForBranchResolve = 1; } } }; break;
# 547 "machine.def"
case SWR: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (8 * (4 - (4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))))) & ~(md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | (_lr_temp & (md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 568 "machine.def"
case LWC1: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((((inst >> 16) & 0x1f))+32)&~1); out2 = (0); { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result))); }; break;
# 591 "machine.def"
case LDC1: in1 = (0); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((((inst >> 16) & 0x1f))+32)&~1); out2 = (0); { word_t _result_hi, _result_lo; enum md_fault_type _fault; if ((((inst >> 16) & 0x1f)) & 01) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; _result_hi = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; _result_lo = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))) + 4)), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi))); (current->spec_mode ? ((current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo)), (((current->use_spec_F)[((((((inst >> 16) & 0x1f)) + 1)&~1))/32] |= (1 << (((((((inst >> 16) & 0x1f)) + 1)&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)]) : (current->regs.regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo))); }; break;
# 606 "machine.def"
case SWC1: in1 = (((((inst >> 16) & 0x1f))+32)&~1); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { if (!current->spec_mode) fault = (_fault); break; }; }; break;
# 639 "machine.def"
case SDC1: in1 = (((((inst >> 16) & 0x1f))+32)&~1); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { enum md_fault_type _fault; qword_t wxh_q; word_t*wxh_ptr = (word_t*)&wxh_q; if ((((inst >> 16) & 0x1f)) & 01) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; *wxh_ptr = ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]) ; wxh_ptr++; *wxh_ptr = ((((current->use_spec_F)[((((((inst >> 16) & 0x1f))+1)&~1))/32] & (1 << (((((((inst >> 16) & 0x1f))+1)&~1)) % 32))) != 0) ? current->spec_regs_F.l[((((inst >> 16) & 0x1f))+1)] : current->regs.regs_F.l[((((inst >> 16) & 0x1f))+1)]); (temp_qword = ((wxh_q)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_qword, sizeof(temp_qword))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_qword, sizeof(temp_qword), current->id, inst)))); }; break;











case SLL: in1 = (((inst >> 16) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f))))); }; break;




case MOVCI_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;
# 681 "machine.def"
case SRL: in1 = (((inst >> 16) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if (((((inst) >> (6)) & (0x1f))) != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 713 "machine.def"
case SRA: in1 = (((inst >> 16) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { int _i; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < (((inst) >> (6)) & (0x1f)); _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f))))); } }; break;
# 722 "machine.def"
case SLLV: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037)))); }; break;
# 751 "machine.def"
case SRLV: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (_shamt != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 784 "machine.def"
case SRAV: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { int _i; int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < _shamt; _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt))); } }; break;
# 799 "machine.def"
case JR: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 816 "machine.def"
case JALR: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8))); (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 826 "machine.def"
case MOVZ: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 836 "machine.def"
case MOVN: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 845 "machine.def"
case SYSCALL: in1 = (0); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { ( (current->spec_mode ? _panic("machine.def", __FUNCTION__, 848, "speculative syscall") : (void) 0), sys_syscall(&(current->regs), mem_access, current->mem, inst, 1)); }; break;
# 857 "machine.def"
case BREAK: in1 = (0); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { { if (!current->spec_mode) fault = (md_fault_break); break; }; }; break;
# 868 "machine.def"
case MFHI: in1 = (0+32+32); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); }; break;
# 877 "machine.def"
case MTHI: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0+32+32); out2 = (0); { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 886 "machine.def"
case MFLO: in1 = (1+32+32); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); }; break;
# 895 "machine.def"
case MTLO: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (1+32+32); out2 = (0); { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 957 "machine.def"
case MULT: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0+32+32); out2 = (1+32+32); { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } }; break;
# 989 "machine.def"
case MULTU: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0+32+32); out2 = (1+32+32); { int _i; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } } }; break;
# 1003 "machine.def"
case DIV: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0+32+32); out2 = (1+32+32); { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { if (!current->spec_mode) fault = (md_fault_div0); break; }; int quotient = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) / ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); int mod = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) % ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (current->spec_mode ? ((current->spec_regs_C.lo = (quotient)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (quotient))); (current->spec_mode ? ((current->spec_regs_C.hi = (mod)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (mod))); }; break;
# 1015 "machine.def"
case DIVU: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (0+32+32); out2 = (1+32+32); { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { if (!current->spec_mode) fault = (md_fault_div0); break; }; (current->spec_mode ? ((current->spec_regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); (current->spec_mode ? ((current->spec_regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1027 "machine.def"
case ADD: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))) { if (!current->spec_mode) fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1036 "machine.def"
case ADDU: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1048 "machine.def"
case SUB: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if (((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) > 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < 0) && (0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))) || (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) < 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > 0) && (-0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))))) { if (!current->spec_mode) fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1057 "machine.def"
case SUBU: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1066 "machine.def"
case AND: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1075 "machine.def"
case OR: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1084 "machine.def"
case XOR: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1093 "machine.def"
case NOR: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1105 "machine.def"
case SLT: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1117 "machine.def"
case SLTU: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1137 "machine.def"
case TEQ: in1 = (((inst >> 21) & 0x1f)); in2 = (((inst >> 16) & 0x1f)); in3 = (0); out1 = (0); out2 = (0); { if(current->spec_mode) break; if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])==((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) _fatal("machine.def", __FUNCTION__, 1140, "TEQ TRAP!\n"); }; break;








# 1159 "machine.def"
case MOVF: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 1176 "machine.def"
case MOVT: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 1) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;






# 1195 "machine.def"
case BLTZ: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1211 "machine.def"
case BGEZ: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1228 "machine.def"
case BLTZAL: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (31); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1245 "machine.def"
case BGEZAL: in1 = (((inst >> 21) & 0x1f)); in2 = (0); in3 = (0); out1 = (31); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;











case MFC0: in1 = (0); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { _fatal("machine.def", __FUNCTION__, 1260, "MFC0 unimplemented\n"); }; break;
# 1266 "machine.def"
case MTC0: in1 = (((inst >> 16) & 0x1f)); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { _fatal("machine.def", __FUNCTION__, 1269, "MTC0 unimplemented\n"); }; break;











case MFC1: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((inst >> 16) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1287 "machine.def"
case CFC1: in1 = (0); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { }; break;
# 1296 "machine.def"
case MTC1: in1 = (((inst >> 16) & 0x1f)); in2 = (0); in3 = (0); out1 = (((((inst >> 11) & 0x1f))+32)&~1); out2 = (0); { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 11) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1305 "machine.def"
case CTC1: in1 = (0); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { }; break;




case COP1_BC_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case COP1_S_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case COP1_D_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;

case COP1_W_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;


# 1330 "machine.def"
case BC1F: in1 = (2+32+32); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (!((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1345 "machine.def"
case BC1T: in1 = (2+32+32); in2 = (0); in3 = (0); out1 = (0); out2 = (0); { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) +4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;





# 1359 "machine.def"
case FADD_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1371 "machine.def"
case FSUB_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1383 "machine.def"
case FMUL_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1395 "machine.def"
case FDIV_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1407 "machine.def"
case FSQRT_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1419 "machine.def"
case FABS_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1431 "machine.def"
case FMOV_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1443 "machine.def"
case FNEG_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1452 "machine.def"
case TRUNC_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1))); }; break;




case COP1_MOVCF_S_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;
# 1468 "machine.def"
case FMOVZ_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1481 "machine.def"
case FMOVN_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1493 "machine.def"
case CVT_D_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1505 "machine.def"
case CVT_W_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1517 "machine.def"
case C_EQ_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1529 "machine.def"
case C_LT_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1541 "machine.def"
case C_LE_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;











case MOVF_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (2+32+32); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1563 "machine.def"
case MOVT_S: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (2+32+32); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;





# 1577 "machine.def"
case FADD_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1589 "machine.def"
case FSUB_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1601 "machine.def"
case FMUL_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1613 "machine.def"
case FDIV_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1625 "machine.def"
case FSQRT_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1637 "machine.def"
case FABS_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1649 "machine.def"
case FMOV_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1661 "machine.def"
case FNEG_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;




case COP1_MOVCF_D_LINK: op = 0; out1 = 0; out2 = 0; in1 = 0; in2 = 0; in3 = 0; break;
# 1676 "machine.def"
case FMOVZ_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1689 "machine.def"
case FMOVN_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1698 "machine.def"
case TRUNC_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1))); }; break;
# 1712 "machine.def"
case CVT_S_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1724 "machine.def"
case CVT_W_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1736 "machine.def"
case C_EQ_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1748 "machine.def"
case C_LT_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1760 "machine.def"
case C_LE_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (((((inst >> 16) & 0x1f))+32)&~1); in3 = (0); out1 = (2+32+32); out2 = (0); { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;











case MOVF_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (2+32+32); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1782 "machine.def"
case MOVT_D: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (2+32+32); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;





# 1796 "machine.def"
case CVT_S_W: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1808 "machine.def"
case CVT_D_W: in1 = (((((inst >> 11) & 0x1f))+32)&~1); in2 = (0); in3 = (0); out1 = (((((inst >> 6) & 0x1f))+32)&~1); out2 = (0); { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { if (!current->spec_mode) fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;





# 1877 "machine.def"
case MADD: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; sword_t temp1, temp2; temp1 = ((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi); temp2 = ((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo); _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2))); }; break;
# 1886 "machine.def"
case MUL: in1 = (((inst >> 16) & 0x1f)); in2 = (((inst >> 21) & 0x1f)); in3 = (0); out1 = (((inst >> 11) & 0x1f)); out2 = (0); { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 8367 "sim-outorder.c" 2
      default:

       op = 0;

       out1 = 0;
       out2 = 0;
       in1 = 0;
       in2 = 0;
       in3 = 0;

     }




    if (!current->spec_mode)
    {
     if(!(collect_lock_stats[threadid] | collect_barrier_stats[threadid]))
      pure_num_insn++;
     total_num_insn++;
     sim_num_insn++;
     current->sim_num_insn++;
    }

    if (fault != md_fault_none)
    {
     fprintf (stderr, "sim_cycle %ld\n sim_insn  %ld, thrdid  %d, pc %lx, Next_pc %lx\n", (unsigned long) sim_cycle, (unsigned long) current->sim_num_insn, current->id, (unsigned long) current->regs.regs_PC,
       (unsigned long) current->regs.regs_PC);
     fprintf (stderr, "fetch pc  %lx,fetch  Next_pc  %lx\n", (unsigned long) current->fetch_regs_PC, (unsigned long) current->fetch_pred_PC);
     _fatal("sim-outorder.c", __FUNCTION__, 8396, "Thread %d, non-speculative fault (%d) detected @ %lx", threadid, fault, (unsigned long) current->regs.regs_PC);
    }
# 8413 "sim-outorder.c"
    if (out1 < 32)
     val_rc = current->regs.regs_R[ out1];
    else
     val_rc = current->regs.regs_F.f[out1 - 32];
    if (((md_op2flags[op]) & (0x00000040)) && isFPMemAcc (op))
     val_ra_result = ((((current->use_spec_F)[(((((inst >> 21) & 0x1f))&~1))/32] & (1 << ((((((inst >> 21) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 21) & 0x1f))] : current->regs.regs_F.f[(((inst >> 21) & 0x1f))]);
    else
     val_ra_result = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]);


    tempReg = current->regs;


    if (((md_op2flags[op]) & 0x00000020))
    {
     sim_total_refs++;
     if (!current->spec_mode)
      sim_num_refs++;

     if ((md_op2flags[op]) & 0x00000080)
      is_write = 1;
     else
     {
      sim_total_loads++;
      if (!current->spec_mode)
       sim_num_loads++;
     }
    }

    br_taken = (current->regs.regs_NPC != (current->regs.regs_PC + 2*sizeof (md_inst_t)));
    br_pred_taken = (current->pred_PC != (current->regs.regs_PC + 2*sizeof (md_inst_t)));

      if ((current->pred_PC != current->regs.regs_NPC && pred_perfect)
   || (((md_op2flags[op]) & (0x00000004)) == (0x00000004)
       && target_PC != current->pred_PC && br_pred_taken))
 {
# 8457 "sim-outorder.c"
   current->fetch_pred_PC = current->fetch_regs_PC = current->regs.regs_NPC;

   if (pred_perfect)
     current->pred_PC = current->regs.regs_NPC;
# 8469 "sim-outorder.c"
   current->fetch_redirected = 1;
 }

    if ((op != 0)&&(inst != MD_NOP_INST) )
    {
# 8493 "sim-outorder.c"
     DUPLICATION_access[threadid]++;
     duplication_access++;

     rs = &current->RUU[current->RUU_tail];



      if ((md_op2flags[op]) & 0x00000004)
   {

  { (delay_slot_inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t))))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t)))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC + sizeof(md_inst_t))))))) + (((current->regs.regs_PC + sizeof(md_inst_t))) & (4096 - 1)))) : 0)); };
  if(delay_slot_inst != MD_NOP_INST)
  {
   delay_slot_ruu =1;
   rs = &current->RUU[(current->RUU_tail+1)%RUU_size];
  }

   }

      else if(delay_slot_ruu)
      {
   delay_slot_ruu =0;
   delay_slot_lsq =1;
   rs = &current->RUU[(current->RUU_tail+RUU_size-1)%RUU_size];
      }




     if(!ruu_inorder_issue)
     {
      rename_access++;
      current->rename_access++;
     }

     rs->threadid = threadid;
     rs->IR = inst;
     rs->op = op;
     rs->instnum = ++instseqnum;
     rs->isSyncInst = (rs->op == LL || rs->op == SC);
     rs->isSyncInstBar = (collect_barrier_stats[threadid]);
     rs->isSyncInstBarRel = (collect_barrier_release && isBarRelInst(current->regs.regs_PC));




     if(current->regs.regs_PC >= 100000 && threadid == 15)
     {
      last_last_pc = last_pc;
      last_pc = current->regs.regs_PC;
     }

     rs->PC = current->regs.regs_PC;
     rs->next_PC = current->regs.regs_NPC;
     rs->pred_PC = current->pred_PC;
     rs->in_LSQ = 0;
     rs->ea_comp = 0;
     rs->abank = -1;
     rs->pbank = -1;
     rs->recover_inst = 0;
     rs->dir_update = *dir_update_ptr;
     rs->stack_recover_idx = stack_recover_idx;
     rs->spec_mode = current->spec_mode;
     rs->fetch_time = fetch_time;
     rs->disp_time = sim_cycle;
     rs->finish_time = 0;
     rs->cache_ready = 0;
     rs->in_qwait = 0;
     rs->issue_time = 0;
     rs->addr = 0;
     rs->distissue = 0;
     rs->lsqEntry = 0;
     rs->miss_flag = 0;

     rs->seq = ++(current->inst_seq);
     rs->queued = rs->issued = rs->completed = 0;
     rs->ptrace_seq = pseq;
     rs->counted_iissueq = 0;
     rs->counted_fissueq = 0;
     rs->invalidationReceived = 0;
     rs->duplicate = (1 - second_run);

     rs->prevRegVal = regVal;

     rs->backupReg = tempRegPrev;
     rs->writewait = 0;
     rs->ReadShareDir = 0;
     rs->writemiss = 0;
     rs->STL_C_fail = 0;
     if (!second_run)
      rs->spec_mode = 0;
     rs->faulting_instr = 0;


     rs->counted_iready = 0;
     rs->counted_fready = 0;
     rs->counted_lsqready = 0;


     rs->freed = 0;
     rs->val_ra = val_ra;
     rs->val_rb = val_rb;
     rs->val_rc = val_rc;
     rs->val_ra_result = val_ra_result;
     rs->when_ready[0] = 800000000;
     rs->when_ready[1] = 800000000;
     rs->when_ready[2] = 800000000;
     rs->when_idep_ready[0] = 800000000;
     rs->when_idep_ready[1] = 800000000;
     rs->when_idep_ready[2] = 800000000;
     rs->idep_name[0] = 0;
     rs->idep_name[1] = 0;
     rs->idep_name[2] = 0;
     rs->isL1Miss = 0;

      rs->sim_num_insn = current->sim_num_insn;
     rs->outReg = out1;

     rs->prevReg = tempReg;

     if (((md_op2flags[op]) & 0x00000020) && !second_run)
      rs->op = ADD;


     if (((md_op2flags[op]) & 0x00000020) )

     {
      lsq = &current->LSQ[current->LSQ_tail];



      rs->op = ADD;
      rs->ea_comp = 1;




      lsq->sqStoreForwardT = -1;



      lsq->ushFlag = ushLdFlag;



      lsq->threadid = threadid;
      lsq->IR = inst;
      lsq->op = op;
      lsq->instnum = instseqnum;
      lsq->isSyncInst = (lsq->op == LL || lsq->op == SC);
      lsq->isSyncInstBar = (collect_barrier_stats[threadid]);
      lsq->isSyncInstBarRel = (collect_barrier_release && isBarRelInst(current->regs.regs_PC));
      lsq->STL_C_fail = 0;

      lsq->PC = current->regs.regs_PC;
      lsq->next_PC = current->regs.regs_NPC;
      lsq->pred_PC = current->pred_PC;
      lsq->in_LSQ = 1;
      lsq->ea_comp = 0;
      lsq->in_qwait = 0;
      lsq->distissue = 0;
      lsq->freed = 0;
      lsq->abank = -1;
      lsq->pbank = -1;

      lsq->recover_inst = 0;
      lsq->dir_update.pdir1 = lsq->dir_update.pdir2 = ((void *)0);
      lsq->dir_update.pmeta = ((void *)0);
      lsq->stack_recover_idx = 0;
      lsq->spec_mode = current->spec_mode;
      lsq->fetch_time = fetch_time;
      lsq->disp_time = sim_cycle;
      lsq->finish_time = 0;
      lsq->cache_ready = 0;
      lsq->issue_time = 0;
      lsq->counted_iissueq = 0;
      lsq->counted_fissueq = 0;
      lsq->miss_flag = 0;

      lsq->invalidationReceived = 0;

      lsq->counted_iready = 0;
      lsq->counted_fready = 0;
      lsq->counted_lsqready = 0;

      for (mm = 0; mm < 64; mm++)
      {
       lsq->st_reach[mm] = 0;
      }

      lsq->backupReg = tempRegPrev;
      lsq->addr = addr;
      rs->addr = addr;

      rs->abank = lsq->abank;
      if (!1)
      {
       rs->pbank = rs->abank;
       lsq->pbank = lsq->abank;
      }
      rs->abank = rs->abank % 64;
      lsq->abank = rs->abank;
      rs->pbank = rs->pbank % 64;
      lsq->pbank = rs->pbank;
      if (!lsq->spec_mode)
      {
       if (lsq->abank == lsq->pbank)
        ac_bank_pred_corr++;
       else
        ac_bank_pred_wrong++;
      }
      lsq->seq = ++(current->inst_seq);
      lsq->ptrace_seq = ptrace_seq++;
      lsq->val_ra = val_ra;
      lsq->val_rb = val_rb;
      lsq->val_rc = val_rc;
      lsq->val_ra_result = val_ra_result;
      if (ptrace_active) __ptrace_newuop((lsq->ptrace_seq),("internal ld/st"),(lsq->PC),(0));
      if (ptrace_active) __ptrace_newstage((lsq->ptrace_seq),("DA"),(0));
      lsq->queued = lsq->issued = lsq->completed = 0;

      lsq->when_ready[0] = 800000000;
      lsq->when_ready[1] = 800000000;
      lsq->when_ready[2] = 800000000;
      lsq->when_idep_ready[0] = 800000000;
      lsq->when_idep_ready[1] = 800000000;
      lsq->when_idep_ready[2] = 800000000;
      lsq->idep_name[0] = 0;
      lsq->idep_name[1] = 0;
      lsq->idep_name[2] = 0;


       lsq->sim_num_insn = current->sim_num_insn;
      lsq->outReg = out1;


      lsq->robEntry = rs->index;
      rs->lsqEntry = lsq->index;
      lsq->isPrefetch = 0;
      lsq->isL1Miss = 0;

      rs->ipreg[0] = 0;
      rs->ipreg[1] = current->ltopmap[in2];
      rs->ipreg[2] = current->ltopmap[in3];

      rs->cluster = lsq->cluster = threadid;
      current->iissueq_thrd++;
      iissueq++;
      iissueq_cl[rs->threadid]++;


      iqram_access_cl[rs->cluster]++;


      lsq->counted_iissueq = 1;

      lsq->pbank = lsq->cluster;
      rs->pbank = rs->cluster;

      rs->when_inq = sim_cycle;
      lsq->when_inq = rs->when_inq;

      lsq->ipreg[0] = current->ltopmap[in1];
      lsq->ipreg[1] = 0;
      lsq->ipreg[2] = 0;

      lsq->oldpreg = current->ltopmap[out1];
      lsq->opreg = get_free_reg (out1, threadid);




      ruu_link_idep (rs, 0, 0);
      ruu_link_idep (rs, 1, in2);
      ruu_link_idep (rs, 2, in3);

      ruu_install_odep (rs, 0, (3+32+32));
      ruu_install_odep (rs, 1, 0);

      rs->out1 = (3+32+32);
      rs->opreg = 0;
      rs->oldpreg = 0;

      ruu_link_idep (lsq, 0, in1);
      ruu_link_idep (lsq, 1, (3+32+32));
      ruu_link_idep (lsq, 2, 0);

      ruu_install_odep (lsq, 0, out1);
      ruu_install_odep (lsq, 1, out2);
      lsq->out1 = out1;

      n_dispatched++;

      current->RUU_tail = (current->RUU_tail + 1) % RUU_size;
      current->RUU_num++;
      current->LSQ_tail = (current->LSQ_tail + 1) % LSQ_size;
      current->LSQ_num++;

      if (((md_op2flags[op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040))
      {
       {
        if (out1 != 0 && out1 != 63)
         current->m_shLQNum++;
        else
         lsq->isPrefetch = 1;
       }
      }
      else if (((md_op2flags[op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080))
      {
        current->m_shSQNum++;
      }

      lsq_access++;
      current->lsq_access++;
      lsq_preg_access++;
      current->lsq_preg_access++;



      if(!ruu_inorder_issue)
      {
       rob2_access++;
       current->rob2_access++;
      }

      if (((rs)->idep_ready[0] && (rs)->idep_ready[1] && (rs)->idep_ready[2]))
      {
       n_ready++;
       readyq_enqueue (rs);
      }
      ((current->last_op).next = ((void *)0), (current->last_op).rs = (lsq), (current->last_op).tag = (lsq)->tag);

      if ((((md_op2flags[op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080)) && ((lsq)->idep_ready[0] && (lsq)->idep_ready[1] && (lsq)->idep_ready[2]))
      {
       lsq_store_data_access++;
       readyq_enqueue (lsq);
      }

      if (op == SC || op == LL)
      {


      }

     }
     else
     {
      rs->ipreg[0] = current->ltopmap[in1];
      rs->ipreg[1] = current->ltopmap[in2];
      rs->ipreg[2] = current->ltopmap[in3];

      rs->oldpreg = current->ltopmap[out1];
      rs->opreg = get_free_reg (out1, threadid);
      rs->out1 = out1;

      rs->cluster = rs->threadid;

      if (((md_op2fu[op]) > 3) && ((md_op2fu[op]) < 10))
      {
       current->fissueq_thrd++;
       fissueq++;
       fissueq_cl[rs->threadid]++;

       fqram_access_cl[rs->cluster]++;

       rs->counted_fissueq = 1;
       fqram_access++;
       current->fqram_access++;
      }
      else
      {
       current->iissueq_thrd++;
       iissueq++;
       iissueq_cl[rs->threadid]++;

       iqram_access_cl[rs->cluster]++;

       rs->counted_iissueq = 1;
       iqram_access++;
       current->iqram_access++;
      }

      rs->when_inq = sim_cycle;

      if (0 )
      {
       ruu_link_idep (rs, 0, in1);
       ruu_link_idep (rs, 1, in2);
       ruu_link_idep (rs, 2, in3);
       if (out1)
       {
        ruu_install_odep_skip (rs, 0, out1);
        ruu_install_odep_skip (rs, 1, out2);
        rs->out1 = out1;
       }
       else
       {
        ruu_install_odep_skip (rs, 0, (3+32+32));
        ruu_install_odep_skip (rs, 1, 0);
        rs->out1 = (3+32+32);
       }
      }
      else
      {
       ruu_link_idep (rs, 0, in1);
       ruu_link_idep (rs, 1, in2);
       ruu_link_idep (rs, 2, in3);

       ruu_install_odep (rs, 0, out1);
       ruu_install_odep (rs, 1, out2);
       rs->out1 = out1;
      }


      n_dispatched++;

      current->RUU_tail = (current->RUU_tail + 1) % RUU_size;
      current->RUU_num++;
      if(!ruu_inorder_issue)
      {
       rob2_access++;
       current->rob2_access++;
      }


      if (((rs)->idep_ready[0] && (rs)->idep_ready[1] && (rs)->idep_ready[2]))
      {
       n_ready++;
       readyq_enqueue (rs);
       current->last_op = RSLINK_NULL;
      }
      else
      {
       ((current->last_op).next = ((void *)0), (current->last_op).rs = (rs), (current->last_op).tag = (rs)->tag);
      }
     }
    }
    else
    {

     rs = ((void *)0);
    }


    sim_total_insn++;
    if ((md_op2flags[op]) & 0x00000004)
     sim_total_branches++;

    if (!current->spec_mode && second_run)
    {


     if ((md_op2flags[op]) & 0x00000004)
     {
      sim_num_branches++;

      if (!(rs->duplicate))
      {
       current->bpred_access++;
       bpred_access++;
      }

      if (current->pred && bpred_spec_update == spec_ID)
      {
       bpred_update (current->pred,
                              current->regs.regs_PC,
                                     current->regs.regs_NPC,
                      current->regs.regs_NPC != (current->regs.regs_PC +
          sizeof (md_inst_t)),
                           current->pred_PC != (current->regs.regs_PC +
          sizeof (md_inst_t)),
                             current->pred_PC == current->regs.regs_NPC,
                      op,
                                    &rs->dir_update,
         rs->threadid, (bpred_btb_use_masterid ? thecontexts[rs->threadid]->masterid : rs->threadid));
      }
     }
     if(current->spec_mode_next)
     {
      current->spec_mode = 1;
     }
     if (current->pred_PC != current->regs.regs_NPC && !current->fetch_redirected)
     {
      current->spec_mode_next = 1;
      rs->recover_inst = 1;
      current->recover_PC = current->regs.regs_NPC;
      copy_to (threadid);
     }
    }


   if (ptrace_active) __ptrace_newstage((pseq),("DA"),((current->pred_PC != current->regs.regs_NPC) ? 0x00000004 : 0));
   if ((op == 0)||(inst == MD_NOP_INST))
   {
    if (ptrace_active) __ptrace_endinst((pseq));
   }

   for (i = 0; i < pcstat_nelt; i++)
   {
    counter_t newval;
    int delta;


    newval = ((pcstat_stats[i])->sc == sc_int ? (counter_t)*((pcstat_stats[i])->variant.for_int.var) : ((pcstat_stats[i])->sc == sc_uint ? (counter_t)*((pcstat_stats[i])->variant.for_uint.var) : ((pcstat_stats[i])->sc == sc_sqword ? *((pcstat_stats[i])->variant.for_sqword.var) : (_panic("sim-outorder.c", __FUNCTION__, 8996, "bad stat class"), 0))));
    delta = newval - pcstat_lastvals[i];
    if (delta != 0)
    {
     stat_add_samples (pcstat_sdists[i], current->regs.regs_PC, delta);
     pcstat_lastvals[i] = newval;
    }
   }

   current->fetch_head = (current->fetch_head + 1) & (ruu_ifq_size - 1);
   current->fetch_num--;
   temp_fetch_num--;


   if (!made_check)
   {
    if (((dlite_check || dlite_active) ? __check_break((0), (is_write ? 0x02 : 0x01), (addr), (sim_num_insn), (sim_cycle)) : 0))
     dlite_main (current->regs.regs_PC, 0, sim_cycle, &(current->regs), current->mem);
   }
  }
 }
 else
  stallCause[threadid] = 6;
 if (!n_dispatched)
 {
  m_totalStall[threadid]++;
  if(stallCause[threadid])
  {
   switch (stallCause[threadid])
   {
    case 4 :
     m_regFull[threadid]++;
     break;
    case 5 :
     m_issueFull[threadid]++;
     break;
    case 6 :
     if(thecontexts[threadid]->ruu_fetch_issue_delay)
      m_il1Miss[threadid]++;
     else
      m_fetchEmpty[threadid]++;
     break;
    case 8 :
     m_STLC[threadid]++;
     break;
    case 10 :
     m_trap[threadid]++;
     break;
    default : _panic("sim-outorder.c", __FUNCTION__, 9044, "No stall cause found");
   }
  }
  else if (current->m_shLQNum == m_shLQSize)
  {
   stallCause[threadid] = 2;
   m_sqLQFull[threadid]++;
   if(current->LSQ[current->LSQ_head].miss_flag)
    m_LoadRealMiss[threadid]++;
   else
    m_LoadRealHit[threadid]++;
  }
  else if (m_shSQSize == (current->m_shSQNum

     +m_L1WBufCnt[threadid]

           ))
  {
   stallCause[threadid] = 3;
   m_sqSQFull[threadid]++;
   if(current->LSQ[current->LSQ_head].miss_flag)
    m_StoreRealMiss[threadid]++;
   else
    m_StoreRealHit[threadid]++;
  }
  else if(current->RUU_num == RUU_size)
  {
   stallCause[threadid] = 1;
   m_RUUFull[threadid]++;
  }

  if((stallCause[threadid] == 1 || stallCause[threadid] == 2 || stallCause[threadid] == 3 || stallCause[threadid] == 4 || stallCause[threadid] == 5 || stallCause[threadid] == 8 || stallCause[threadid] == 10))
  {
   if(current->LSQ_num)
   {
    if((md_op2flags[current->LSQ[current->LSQ_head].op]) & 0x00000040)
    {
     if(current->LSQ[current->LSQ_head].miss_flag)
      m_LoadStallMiss[threadid]++;
     else
      m_LoadStallHit[threadid]++;
     m_LoadMiss[threadid]++;
    }
    else
    {
     m_StoreMiss[threadid]++;
     if(current->LSQ[current->LSQ_head].miss_flag)
      m_StoreStallMiss[threadid]++;
     else
      m_StoreStallHit[threadid]++;
     if(m_update_miss[threadid])
      m_StoreUpdateMiss[threadid]++;
     if(m_update_miss[threadid] && !m_update_miss_flag[threadid])
     {
      m_update_miss_flag[threadid] = 1;
      m_update_miss_depend_start[threadid] = sim_cycle;
     }
    }
   }
   else if((md_op2flags[current->RUU[current->RUU_head].op]) & 0x00040000)
   {
    m_StoreMiss[threadid]++;
    if(current->LSQ[current->LSQ_head].miss_flag)
     m_StoreStallMiss[threadid]++;
    else
     m_StoreStallHit[threadid]++;
    if(m_update_miss[threadid])
     m_StoreUpdateMiss[threadid]++;
    if(m_update_miss[threadid] && !m_update_miss_flag[threadid])
    {
     m_update_miss_flag[threadid] = 1;
     m_update_miss_depend_start[threadid] = sim_cycle;
    }
   }
  }
 }
 return n_dispatched;
}






 void
fetch_init (int threadid)
{

 int i = 0;
 context *current;

 current = thecontexts[threadid];

 for (i = 0; i < ruu_ifq_size; i++)
 {
  current->fetch_data[i] = (struct fetch_rec *) calloc (1, sizeof (struct fetch_rec));
  if (!current->fetch_data[i])
   _fatal("sim-outorder.c", __FUNCTION__, 9141, "out of virtual memory");
  current->fetch_data[i]->index = i;
  current->fetch_data[i]->threadid = threadid;
 }
 current->fetch_num = 0;
 current->fetch_tail = current->fetch_head = 0;
 IFQ_count = 0;
 IFQ_fcount = 0;

}

static int last_inst_missed = 0;
static int last_inst_tmissed = 0;
static unsigned int
cache_miss(md_addr_t taddr, int threadid)
{
        int lat, tlb_lat;

          lat = cache_il1_lat;
          if (cache_il1)
            {

              lat =
                cache_access(cache_il1[threadid], Read, (taddr),
                             ((void *)0), (sizeof(md_inst_t)), sim_cycle,
                             ((void *)0), ((void *)0),((void *)0),threadid, ((void *)0) );
              if (lat > cache_il1_lat)
                last_inst_missed = 1;
            }

          if (itlb)
            {


              tlb_lat =
                cache_access(itlb[threadid], Read, (taddr),
                             ((void *)0), (sizeof(md_inst_t)), sim_cycle,
                             ((void *)0), ((void *)0),((void *)0),threadid, ((void *)0));
              if (tlb_lat > 1)
                last_inst_tmissed = 1;


              lat = (((tlb_lat)>(lat))?(tlb_lat):(lat));
            }


          if (lat != cache_il1_lat)
            {


                        return (lat - 1);
            }
                return 0;
}


void delay_slot_ff(int threadid)
{
 md_inst_t inst;
 register md_addr_t addr;
 enum md_opcode op;
 register int is_write;
 enum md_fault_type fault;
 context * current = thecontexts[threadid];
 md_addr_t target_PC;
 byte_t temp_byte;
 half_t temp_half;
 word_t temp_word;
 qword_t temp_qword;
 current->regs.regs_PC += sizeof(md_inst_t);

 { (inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) + (((current->regs.regs_PC)) & (4096 - 1)))) : 0)); };

 { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };

 switch (op)
 {
# 9228 "sim-outorder.c"
# 1 "machine.def" 1
case SPECIAL_LINK: _panic("machine.def", __FUNCTION__, 1, "attempted to execute a linking opcode");

case REGIMM_LINK: _panic("machine.def", __FUNCTION__, 3, "attempted to execute a linking opcode");
# 12 "machine.def"
case JUMP: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 26 "machine.def"
case JAL: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 41 "machine.def"
case BEQ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 57 "machine.def"
case BNE: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) != ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 73 "machine.def"
case BLEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) <= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 89 "machine.def"
case BGTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) > 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 101 "machine.def"
case ADDI: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((int)(( short)(inst & 0xffff))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 110 "machine.def"
case ADDIU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 122 "machine.def"
case SLTI: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 134 "machine.def"
case SLTIU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 143 "machine.def"
case ANDI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff)))); }; break;
# 152 "machine.def"
case ORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff)))); }; break;
# 161 "machine.def"
case XORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff)))); }; break;
# 170 "machine.def"
case LUI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16))); }; break;




case COP0_LINK: _panic("machine.def", __FUNCTION__, 175, "attempted to execute a linking opcode");

case COP1_LINK: _panic("machine.def", __FUNCTION__, 177, "attempted to execute a linking opcode");

case COP2_LINK: _panic("machine.def", __FUNCTION__, 179, "attempted to execute a linking opcode");

case SPECIAL2_LINK: _panic("machine.def", __FUNCTION__, 181, "attempted to execute a linking opcode");
# 193 "machine.def"
case LB: { sbyte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 208 "machine.def"
case LH: { shalf_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 249 "machine.def"
case LWL: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))))))); }; break;
# 265 "machine.def"
case LW: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 289 "machine.def"
case LL: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; if(!current->spec_mode && _result == 0) { common_regs_s[current->masterid][current->actualid].regs_lock = 1; common_regs_s[current->masterid][current->actualid].address = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))); } (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 307 "machine.def"
case LBU: { byte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 322 "machine.def"
case LHU: { half_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 362 "machine.def"
case LWR: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))]))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])))))); }; break;
# 377 "machine.def"
case SB: { byte_t _src; enum md_fault_type _fault; _src = (byte_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_byte = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_byte, sizeof(temp_byte), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 392 "machine.def"
case SH: { half_t _src; enum md_fault_type _fault; _src = (half_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_half = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_half, sizeof(temp_half), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 432 "machine.def"
case SWL: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (8 * (4 - (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)))) & (md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])) | (_lr_temp & ~(md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])+((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 447 "machine.def"
case SW: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 501 "machine.def"
case SC: { word_t _src; enum md_fault_type _fault; int ii = 0; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if(COHERENT_CACHE && allForked && collect_stats) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if(_fault != md_fault_none) { { fault = (_fault); break; }; } } else { if(!current->spec_mode) { if((common_regs_s[current->masterid][current->actualid].regs_lock == 1) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) + (((int)(( short)(inst & 0xffff)))))) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { { fault = (_fault); break; }; } for(ii = 0; ii < 64; ii++) { if(common_regs_s[current->masterid][ii].address == (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))) { common_regs_s[current->masterid][ii].regs_lock = 0; common_regs_s[current->masterid][ii].address = 0; } } } else (current->spec_mode ? ((current->spec_regs_R[((inst >> 21) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] |= (1 << (((((inst >> 21) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 21) & 0x1f)]) : (current->regs.regs_R[((inst >> 21) & 0x1f)] = (0))); } else { current->waitForBranchResolve = 1; } } }; break;
# 547 "machine.def"
case SWR: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (8 * (4 - (4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))))) & ~(md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | (_lr_temp & (md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 568 "machine.def"
case LWC1: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result))); }; break;
# 591 "machine.def"
case LDC1: { word_t _result_hi, _result_lo; enum md_fault_type _fault; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; _result_hi = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _result_lo = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))) + 4)), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi))); (current->spec_mode ? ((current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo)), (((current->use_spec_F)[((((((inst >> 16) & 0x1f)) + 1)&~1))/32] |= (1 << (((((((inst >> 16) & 0x1f)) + 1)&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)]) : (current->regs.regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo))); }; break;
# 606 "machine.def"
case SWC1: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 639 "machine.def"
case SDC1: { enum md_fault_type _fault; qword_t wxh_q; word_t*wxh_ptr = (word_t*)&wxh_q; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; *wxh_ptr = ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]) ; wxh_ptr++; *wxh_ptr = ((((current->use_spec_F)[((((((inst >> 16) & 0x1f))+1)&~1))/32] & (1 << (((((((inst >> 16) & 0x1f))+1)&~1)) % 32))) != 0) ? current->spec_regs_F.l[((((inst >> 16) & 0x1f))+1)] : current->regs.regs_F.l[((((inst >> 16) & 0x1f))+1)]); (temp_qword = ((wxh_q)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_qword, sizeof(temp_qword))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_qword, sizeof(temp_qword), current->id, inst)))); }; break;











case SLL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f))))); }; break;




case MOVCI_LINK: _panic("machine.def", __FUNCTION__, 656, "attempted to execute a linking opcode");
# 681 "machine.def"
case SRL: { if (((((inst) >> (6)) & (0x1f))) != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 713 "machine.def"
case SRA: { int _i; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < (((inst) >> (6)) & (0x1f)); _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f))))); } }; break;
# 722 "machine.def"
case SLLV: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037)))); }; break;
# 751 "machine.def"
case SRLV: { int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (_shamt != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 784 "machine.def"
case SRAV: { int _i; int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < _shamt; _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt))); } }; break;
# 799 "machine.def"
case JR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 816 "machine.def"
case JALR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8))); (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 826 "machine.def"
case MOVZ: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 836 "machine.def"
case MOVN: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 845 "machine.def"
case SYSCALL: { ( (current->spec_mode ? _panic("machine.def", __FUNCTION__, 848, "speculative syscall") : (void) 0), sys_syscall(&(current->regs), mem_access, current->mem, inst, 1)); }; break;
# 857 "machine.def"
case BREAK: { { fault = (md_fault_break); break; }; }; break;
# 868 "machine.def"
case MFHI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); }; break;
# 877 "machine.def"
case MTHI: { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 886 "machine.def"
case MFLO: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); }; break;
# 895 "machine.def"
case MTLO: { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 957 "machine.def"
case MULT: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } }; break;
# 989 "machine.def"
case MULTU: { int _i; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } } }; break;
# 1003 "machine.def"
case DIV: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; int quotient = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) / ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); int mod = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) % ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (current->spec_mode ? ((current->spec_regs_C.lo = (quotient)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (quotient))); (current->spec_mode ? ((current->spec_regs_C.hi = (mod)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (mod))); }; break;
# 1015 "machine.def"
case DIVU: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; (current->spec_mode ? ((current->spec_regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); (current->spec_mode ? ((current->spec_regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1027 "machine.def"
case ADD: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1036 "machine.def"
case ADDU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1048 "machine.def"
case SUB: { if (((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) > 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < 0) && (0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))) || (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) < 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > 0) && (-0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1057 "machine.def"
case SUBU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1066 "machine.def"
case AND: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1075 "machine.def"
case OR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1084 "machine.def"
case XOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1093 "machine.def"
case NOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1105 "machine.def"
case SLT: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1117 "machine.def"
case SLTU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1137 "machine.def"
case TEQ: { if(current->spec_mode) break; if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])==((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) _fatal("machine.def", __FUNCTION__, 1140, "TEQ TRAP!\n"); }; break;








# 1159 "machine.def"
case MOVF: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 1176 "machine.def"
case MOVT: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 1) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;






# 1195 "machine.def"
case BLTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1211 "machine.def"
case BGEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1228 "machine.def"
case BLTZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1245 "machine.def"
case BGEZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;











case MFC0: { _fatal("machine.def", __FUNCTION__, 1260, "MFC0 unimplemented\n"); }; break;
# 1266 "machine.def"
case MTC0: { _fatal("machine.def", __FUNCTION__, 1269, "MTC0 unimplemented\n"); }; break;











case MFC1: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1287 "machine.def"
case CFC1: { }; break;
# 1296 "machine.def"
case MTC1: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 11) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1305 "machine.def"
case CTC1: { }; break;




case COP1_BC_LINK: _panic("machine.def", __FUNCTION__, 1310, "attempted to execute a linking opcode");

case COP1_S_LINK: _panic("machine.def", __FUNCTION__, 1312, "attempted to execute a linking opcode");

case COP1_D_LINK: _panic("machine.def", __FUNCTION__, 1314, "attempted to execute a linking opcode");

case COP1_W_LINK: _panic("machine.def", __FUNCTION__, 1316, "attempted to execute a linking opcode");


# 1330 "machine.def"
case BC1F: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (!((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1345 "machine.def"
case BC1T: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) +4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;





# 1359 "machine.def"
case FADD_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1371 "machine.def"
case FSUB_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1383 "machine.def"
case FMUL_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1395 "machine.def"
case FDIV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1407 "machine.def"
case FSQRT_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1419 "machine.def"
case FABS_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1431 "machine.def"
case FMOV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1443 "machine.def"
case FNEG_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1452 "machine.def"
case TRUNC_S: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1))); }; break;




case COP1_MOVCF_S_LINK: _panic("machine.def", __FUNCTION__, 1457, "attempted to execute a linking opcode");
# 1468 "machine.def"
case FMOVZ_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1481 "machine.def"
case FMOVN_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1493 "machine.def"
case CVT_D_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1505 "machine.def"
case CVT_W_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1517 "machine.def"
case C_EQ_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1529 "machine.def"
case C_LT_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1541 "machine.def"
case C_LE_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;











case MOVF_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1563 "machine.def"
case MOVT_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;





# 1577 "machine.def"
case FADD_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1589 "machine.def"
case FSUB_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1601 "machine.def"
case FMUL_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1613 "machine.def"
case FDIV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1625 "machine.def"
case FSQRT_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1637 "machine.def"
case FABS_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1649 "machine.def"
case FMOV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1661 "machine.def"
case FNEG_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;




case COP1_MOVCF_D_LINK: _panic("machine.def", __FUNCTION__, 1666, "attempted to execute a linking opcode");
# 1676 "machine.def"
case FMOVZ_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1689 "machine.def"
case FMOVN_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1698 "machine.def"
case TRUNC_D: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1))); }; break;
# 1712 "machine.def"
case CVT_S_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1724 "machine.def"
case CVT_W_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1736 "machine.def"
case C_EQ_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1748 "machine.def"
case C_LT_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1760 "machine.def"
case C_LE_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;











case MOVF_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1782 "machine.def"
case MOVT_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;





# 1796 "machine.def"
case CVT_S_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1808 "machine.def"
case CVT_D_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;





# 1877 "machine.def"
case MADD: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; sword_t temp1, temp2; temp1 = ((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi); temp2 = ((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo); _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2))); }; break;
# 1886 "machine.def"
case MUL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 9229 "sim-outorder.c" 2
 default:
   _panic("sim-outorder.c", __FUNCTION__, 9230, "attempted to execute a bogus opcode 0x%x",current->regs.regs_PC);
      }
# 9248 "sim-outorder.c"
}


void delay_slot(int threadid)
{

 context * current = thecontexts[threadid];
 (current->regs.regs_NPC = ((current->regs.regs_PC) + 8));
}

md_addr_t DelaySlot_L1miss_wxh[64] = { 0 };



 static void
ruu_fetch (void)
{
  int i = 0, j = 0, k = 0, lat, tlb_lat, done = 0, break_mark = 0;
 md_inst_t inst;
 int stack_recover_idx;
 int branch_cnt, ray_mult;
 md_addr_t fetch_set = 0, inst_set;
 int index;
 enum md_opcode op, op_test;

 int threadid, tID = 0;
 context *current = 0;
 int threadsfetched = 0;
 int temp;

 if (disable_ray)
  ray_mult = 1;
 else
  ray_mult = 2;


 while (tID < numcontexts)
 {
  current = thecontexts[tID];
  tID++;

  threadid = current->id;

  if (current->wait_for_fetch == 2)
   current->wait_for_fetch = 1;
  fetch_done[threadid] = 0;

  for (j = 0, done = 0, branch_cnt = 0;
    (current->fetch_num < ruu_ifq_size-1) && !done && current->running &&
         !current->ruu_fetch_issue_delay &&
         j < (ruu_decode_width * fetch_speed) && current->active_this_cycle ; j++)
  {
   if (!j)
   {
    icache_access++;
    current->icache_access++;
   }



  if(current->delay_slot_mark)
 {
  current->fetch_regs_PC = current->delay_slot_pc;
 }
 else
 {
      current->fetch_regs_PC = current->fetch_pred_PC;
   for(i=current->fetch_head; i!=current->fetch_tail; i=(i+1)%ruu_ifq_size)
  {
    { op_test = md_mask2op[(((current->fetch_data[i]->IR) >> 26) & 0x3f)]; while (md_opmask[op_test]){ op_test = md_mask2op[((current->fetch_data[i]->IR >> md_opshift[op_test]) & md_opmask[op_test]) + md_opoffset[op_test]]; } };
    if ((md_op2flags[op_test]) & 0x00000004)
     break_mark = 1;
  }
 }

   if (current->ld_text_base <= current->fetch_regs_PC && current->fetch_regs_PC < (current->ld_text_base + current->ld_text_size) && !(current->fetch_regs_PC & (sizeof (md_inst_t) - 1)))
   {

    {
     { (inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->fetch_regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->fetch_regs_PC)))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->fetch_regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->fetch_regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->fetch_regs_PC)))))) + (((current->fetch_regs_PC)) & (4096 - 1)))) : 0)); };
    }
    { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };
  if ((md_op2flags[op]) & 0x00000004)
  {

   if(current->fetch_num >= ruu_ifq_size-2)
    break_mark = 1;

   if (!current->wait_for_fetch)
   {
    int lat_wxh = cache_miss(current->fetch_regs_PC + sizeof(md_inst_t), current->id);
    if(lat_wxh)
     {
         current->ruu_fetch_issue_delay += (lat_wxh - 1);

      current->wait_for_fetch = 2;
      break;
      }
   }
  }


  if(break_mark == 1)
   break;
    lat = cache_il1_lat;
# 9362 "sim-outorder.c"
    if (!current->wait_for_fetch)
    {

     if (cache_il1[threadid])
     {


      rsCacheAccess = ((void *)0);
      if((sizeof(md_inst_t)) == 32)
       printf("debug 1\n");
      lat = cache_access (cache_il1[threadid], Read, (current->fetch_regs_PC),
        ((void *)0), (sizeof(md_inst_t)), sim_cycle,
        ((void *)0), ((void *)0), ((void *)0),threadid, ((void *)0));
      if (lat > (cache_il1_lat))
       last_inst_missed = 1;
     }

     if (itlb[threadid])
     {
      if((sizeof(md_inst_t)) == 32)
       printf("debug 2\n");
      tlb_lat = cache_access(itlb[threadid], Read, (current->fetch_regs_PC),
        ((void *)0), (sizeof(md_inst_t)), sim_cycle,
        ((void *)0), ((void *)0), ((void *)0), threadid, ((void *)0));

      if (tlb_lat > 1)
       last_inst_tmissed = 1;

      lat = (((tlb_lat) < (lat)) ? (lat) : (tlb_lat));
     }

     if (lat != (cache_il1_lat))
     {
      current->ruu_fetch_issue_delay += (lat - 1);

      current->wait_for_fetch = 2;

      break;
     }


    }

   }
   else
   {
    inst = MD_NOP_INST;
   }
   if(current->delay_slot_mark)
   {
    current->delay_slot_mark = 0;
    done = 1;
    current->fetch_data[current->fetch_tail]->pred_PC = current->delay_slot_pc + sizeof(md_inst_t);
   }
   else {
   if (current->pred && inst!=MD_NOP_INST)
   {

    branchInst *branchInfo = ((void *)0);
    enum md_opcode op;


    { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };




    if ((md_op2flags[op]) & 0x00000004)
    {
     md_addr_t btarget;
     current->delay_slot_mark = 1;
     current->delay_slot_pc = current->fetch_regs_PC + sizeof(md_inst_t);







     current->fetch_pred_PC = bpred_lookup (current->pred,
                            current->fetch_regs_PC,
                            0,
                    op,
                   (((md_op2flags[op]) & (0x00000004|0x00008000)) == (0x00000004|0x00008000)),
                     ((op) == JR && (((inst >> 21) & 0x1f)) == 31),
                  &(current->fetch_data[current->fetch_tail]->dir_update),
                       &stack_recover_idx,
                       current->id,
                               (bpred_btb_use_masterid ? current->masterid : current->id));
     if (!current->fetch_pred_PC)
     {
      current->fetch_pred_PC = current->fetch_regs_PC + 2*sizeof(md_inst_t);
      branch_cnt++;
     }
    }
    else
     current->fetch_pred_PC = 0;


    if (!current->fetch_pred_PC)
    {
     current->fetch_pred_PC = current->fetch_regs_PC + sizeof (md_inst_t);
    }







   }
   else
   {
    current->fetch_pred_PC = current->fetch_regs_PC + sizeof (md_inst_t);
   }
   current->fetch_data[current->fetch_tail]->pred_PC = current->fetch_pred_PC;
 }
   current->fetch_total_insn++;
   current->fetch_data[current->fetch_tail]->threadid = threadid;
   current->fetch_data[current->fetch_tail]->IR = inst;
   current->fetch_data[current->fetch_tail]->regs_PC = current->fetch_regs_PC;

   current->fetch_data[current->fetch_tail]->stack_recover_idx = stack_recover_idx;
   current->fetch_data[current->fetch_tail]->ptrace_seq = ptrace_seq++;
   current->fetch_data[current->fetch_tail]->fetch_time = (long) sim_cycle;

   if (ptrace_active) __ptrace_newinst((current->fetch_data[current->fetch_tail]->ptrace_seq),(inst),(current->fetch_data[current->fetch_tail]->regs_PC),(0));
   if (ptrace_active) __ptrace_newstage((current->fetch_data[current->fetch_tail]->ptrace_seq),("IF"),(((last_inst_missed ? 0x00000001 : 0) | (last_inst_tmissed ? 0x00000002 : 0))));
      last_inst_missed = 0;
      last_inst_tmissed = 0;

   current->fetch_tail = (current->fetch_tail + 1) & (ruu_ifq_size - 1);
   current->fetch_num++;
   fetch_done[threadid]++;
  }



  if (current->wait_for_fetch == 1)
  {
   if (!j && current->ruu_fetch_issue_delay)
    current->wait_for_fetch = 2;
   else
    current->wait_for_fetch = 0;
  }

 }
}




 static char *
simoo_mstate_obj (FILE * stream,
  char *cmd,
  struct regs_t *regs,
  struct mem_t *mem)
{

 int threadid = mem->threadid;
 context *current;

 current = thecontexts[threadid];

 if (!cmd || !strcmp (cmd, "help"))
  fprintf (stream,
    "mstate commands:\n"
    "\n"
    "    mstate help   - show all machine-specific commands (this list)\n"
    "    mstate stats  - dump all statistical variables\n"
    "    mstate res    - dump current functional unit resource states\n"
    "    mstate ruu    - dump contents of the register update unit\n"
    "    mstate lsq    - dump contents of the load/store queue\n"
    "    mstate eventq - dump contents of event queue\n"
    "    mstate readyq - dump contents of ready instruction queue\n"
    "    mstate cv     - dump contents of the register create vector\n"
    "    mstate rspec  - dump contents of speculative regs\n" "    mstate mspec  - dump contents of speculative memory\n" "    mstate fetch  - dump contents of fetch stage registers and fetch queue\n" "\n");
 else if (!strcmp (cmd, "stats"))
 {

  sim_print_stats (stream);
 }
 else if (!strcmp (cmd, "res"))
 {

  res_dump (fu_pool, stream);
 }
 else if (!strcmp (cmd, "ruu"))
 {

  ruu_dump (stream, threadid);
 }





 else if (!strcmp (cmd, "eventq"))
 {

  eventq_dump (stream, threadid);
 }
 else if (!strcmp (cmd, "readyq"))
 {

  readyq_dump (stream, threadid);
 }
 else if (!strcmp (cmd, "cv"))
 {

  cv_dump (stream, threadid);
 }
 else if (!strcmp (cmd, "rspec"))
 {

  rspec_dump (stream, threadid);
 }
 else if (!strcmp (cmd, "mspec"))
 {

  mspec_dump (stream, threadid);
 }





 else
  return "unknown mstate command";


 return ((void *)0);
}
# 9603 "sim-outorder.c"
int changeConfig = 0;
int currentPhase = 4;




void regenerate_fetch_queue ();
void copy_fetch_queue ();

void regenerate_f_queue ();
void copy_f_queue ();
void branch_address_copy (int masterid, long long int chunkExecuted);




static time_t print_time, now_time;
void ruu_release_writebuffer ();
void ruu_write_from_Writebuffer ();

void fstfwd_fineAdjust ();
void fstfwd_collectStats();

 void
sim_main (void)
{
 int unPrintLimit = 1;
 int i, j, k, l;
 int tempcl, maxguy, maxval, ref_mis, ref_imis, ref_br, ref_refs, ref_cyc, mm, nn;
 int got_ref_point = 0;
 int minguy, minval;
 float cyc_count = 0;
 int num_picks[64 + 1];
 unsigned long sim_elapsed_sec;
 int dispatched = 0;

 int threadid = 0, thread_stop = 0;
 context *current;
 int killall = 0;
 int fetch_blocked = 1;
 int cnt;

 FILE *fp, *fp1;
 int brNum, ldNum;







 signal (8, ((__sighandler_t) 1));


 nack_counter = 0;
 flip_counter = 0;
 store_conditional_failed = 0;
 L1_flip_counter = 0;
 e_to_m = 0;
 int f;
 for(f=0;f<16;f++)
  mem_port_lat[f] = 0;
 totaleventcountnum = 0;
 totalWriteIndicate = 0;
 total_exclusive_modified = 0;
 total_exclusive_conf = 0;
 total_exclusive_cross = 0;
 totalSyncEvent = 0;
 totalNormalEvent = 0;
 totalSyncWriteup = 0;
 totalSyncWriteM = 0;
 totalSyncReadM = 0;
 totalmisstimeforSync = 0;
 totalmisstimeforNormal = 0;
 total_L1_prefetch = 0;
 write_back_early = 0;
 total_L1_first_prefetch = 0;
 total_L1_sec_prefetch = 0;
 totalreqcountnum = 0;
 totalmisscountnum = 0;
 involve_4_hops = 0;
 involve_4_hops_upgrade = 0;
 involve_4_hops_miss = 0;
 involve_2_hops = 0;
 involve_2_hop_touch = 0;
 involve_2_hop_wb = 0;
 involve_4_hops_wm = 0;
 totalSplitWM = 0;
 totalSplitNo = 0;
 involve_2_hops_wm = 0;
 involve_2_hops_upgrade = 0;
 involve_2_hops_miss = 0;
 data_shared_read = 0;
 data_private_read = 0;
 data_shared_write = 0;
 data_private_write = 0;
 total_all_close = 0;
 total_all_almostclose = 0;
 total_not_all_close = 0;
 total_p_c_events = 0;
 total_consumers = 0;
 total_data_consumers = 0;
 total_data_far = 0;
 total_data_at_corner = 0;
 total_data_close = 0;
 total_packets_in_neighbor = 0;
 total_packets_at_corners = 0;
 average_outside_percent = 0;
 average_outside_abs_percent = 0;
 average_inside_percent = 0;
 average_corner_percent = 0;





 for(i = 0; i< numcontexts; i++)
  sharer_num[i] = 0;
# 9731 "sim-outorder.c"
 initClusterInfo ();





 char fnm[256];
 char nm[256];

 strcpy (nm, thecontexts[0]->fname);

 for (l = 0; l < 64; l++)
 {
  numThreads[l] = mta_maxthreads;
 }



 n_limit_thrd[0] = n_limit_thrd[1] = n_limit_thrd[2] = n_limit_thrd[3] = 1;



 fprintf (stderr, "Issueq size   - int %d fp %d\n", IIQ_size, FIQ_size);

 fprintf (stderr, "rename Pregfile size - int %d fp %d\n", IPREG_size, FPREG_size);



 fprintf (stderr, "CLUSTERS %d\n", 64);
 fprintf (stderr, "ROWCOUNT %d\n", 4);
 fprintf (stderr, "CENTRAL_CACHE %d\n", 0);
 fprintf (stderr, "CENTRALCACHELAT %d\n", 0);
 fprintf (stderr, "CACHELOC %d\n", 0);
 fprintf (stderr, "PRED_BR_CHANGES %d\n", 0);
 fprintf (stderr, "PRED_JR_CHANGES %d\n", 0);
 fprintf (stderr, "DYNAMIC_CHANGE %d\n", 0);
 fprintf (stderr, "METRIC_CHANGE %d\n", 0);
 fprintf (stderr, "LINEAR_PHASE %d\n", 0);
 fprintf (stderr, "SMALLEST_CONFIG %d\n", 64);
 fprintf (stderr, "GRID %d\n", 0);
 fprintf (stderr, "CACHEPORTS %d\n", CACHEPORTS);
 fprintf (stderr, "RES_CACHEPORTS %d\n", RES_CACHEPORTS);
 fprintf (stderr, "READY_COMM %d\n", 1);
 fprintf (stderr, "HOLY_REGS %d\n", 0);
 fprintf (stderr, "NUM_H_REGS %d\n", 3);
 fprintf (stderr, "COPY_THRESH %d\n", 50);
 fprintf (stderr, "FIRST_FIT %d\n", 0);
 fprintf (stderr, "FIRST_FIT_ENFORCE %d\n", 0);
 fprintf (stderr, "FIRST_VAL %d\n", 10000);
 fprintf (stderr, "STEER_ENFORCE %d\n", 0);
 fprintf (stderr, "MOD_N %d\n", 0);
 fprintf (stderr, "MOD_N_N %d\n", 8);
 fprintf (stderr, "FIRST_MOD %d\n", 0);
 fprintf (stderr, "GROUPSIZE %d\n", 4);
 fprintf (stderr, "MOD_N_T %d\n", 2);
 fprintf (stderr, "ANYWILLDO %d\n", 1);
 fprintf (stderr, "NEIGHBOR_SEEK %d\n", (64/2));
 fprintf (stderr, "PICKMIDDLE %d\n", 0);
 fprintf (stderr, "MIDTHRESH %d\n", 16);
 fprintf (stderr, "HOPTIME %d\n", 1);
 fprintf (stderr, "COMM_LATENCY %d\n", ((64*1)/2));



 fprintf (stderr, "CACHE_REFILL_LAT %d\n", 0);
 fprintf (stderr, "MPRED_COMM_LAT %d\n", 0);
 fprintf (stderr, "LD_PROXIMITY %d\n", 0);
 fprintf (stderr, "LDPROX_FACTOR %d\n", 256);
 fprintf (stderr, "STEER_2NONREADY %d\n", 0);
 fprintf (stderr, "STEER_CRITICAL %d\n", 0);
 fprintf (stderr, "ILOAD_MIN %d\n", 1);
 fprintf (stderr, "IFACTOR %d\n", 4);
 fprintf (stderr, "RLOAD_MIN %d\n", 1);
 fprintf (stderr, "RFACTOR %d\n", 1);
 fprintf (stderr, "DEP_FACTOR %d\n", 64);
 fprintf (stderr, "LD_FACTOR %d\n", 0);
 fprintf (stderr, "IQBUF %d\n", 0);
 fprintf (stderr, "REGFREE %d\n", 0);
 fprintf (stderr, "FREE_CURR_REGS %d\n", 0);
 fprintf (stderr, "FREE_INTERVAL %d\n", 1);
 fprintf (stderr, "DISPDELAY %d\n", 0);
 fprintf (stderr, "RING_BW %d\n", 1);
 fprintf (stderr, "TIMEWINDOW %d\n", 5000);
 fprintf (stderr, "ST_ADDR_COMM %d\n", 1);
 fprintf (stderr, "ST_RING_BW %d\n", 1);
 fprintf (stderr, "RING_IC %d\n", 1);
 fprintf (stderr, "IGNORE_COMM_LATENCY %d\n", 1);
 fprintf (stderr, "TOL_COUNT %d\n", 0);
 fprintf (stderr, "STOREDELAY %d\n", 1);
 fprintf (stderr, "BANKPRED %d\n", 1);
 fprintf (stderr, "BANKMISPREDLAT %d\n", 1);
 fprintf (stderr, "BANKP_SPEC %d\n", 0);
 fprintf (stderr, "LEV1SIZE %d\n", 1024);
 fprintf (stderr, "LEV2SIZE %d\n", 4096);
 fprintf (stderr, "XORSIZE %d\n", 12);
 fprintf (stderr, "WORD_INTERLEAVED %d\n", 0);
 fprintf (stderr, "WORDSIZE %d\n", 8);
 fprintf (stderr, "SORT %d\n", 0);
 fprintf (stderr, "NUMPHASES %d\n", 64);
 fprintf (stderr, "MIN_INSN_INT %d\n", 10000);
 fprintf (stderr, "STOP_EXPL_THRESH %d\n", -5);
 fprintf (stderr, "ILPTAGCHECK %d\n", 1);
 fprintf (stderr, "DISTILP %d\n", 120);
 fprintf (stderr, "DISTILPTHRESH %d\n", 30);
 fprintf (stderr, "SAMPLETHRESH %d\n", 10);
 fprintf (stderr, "BR_INT %d\n", 8);
 fprintf (stderr, "ITABLESIZE %d\n", 16384);
 fprintf (stderr, "OWINDOWSIZE %d\n", 360);
 fprintf (stderr, "ILPCLEARINT %d\n", 10000000);
 fprintf (stderr, "STATPRINT %d\n", 0);
 fprintf (stderr, "CYCNOISE %d\n", 10);
 fprintf (stderr, "NUMCYCTHRESH %d\n", 5);
 fprintf (stderr, "STATINT %d\n", 10000);
 fprintf (stderr, "FREE_REG_THRESH %d\n", (4000));
 fprintf (stderr, "TABLE2SIZE %d\n", 4096);
 fprintf (stderr, "TABLESIZE %d\n", 4096);


 {
  thrdPerJobCnt = 1;
  current = thecontexts[threadid];
  current->regs.regs_PC = current->ld_prog_entry;
  current->regs.regs_NPC = current->regs.regs_PC + sizeof (md_inst_t);



  if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_PC), (0), (0), (0), (0)) : 0))
   dlite_main (current->regs.regs_PC, current->regs.regs_PC + sizeof (md_inst_t), sim_cycle, &(current->regs), current->mem);



  if (!current->fastfwd_done)
  {
   counter_t icount;
   md_inst_t inst;
   enum md_opcode op;
   md_addr_t target_PC;
   md_addr_t addr;
   int is_write;
   byte_t temp_byte;
   half_t temp_half;
   word_t temp_word;
            int fl_flag_0;
            fl_flag_0 = 0;




   qword_t temp_qword = 0;


   enum md_fault_type fault;

   fprintf (stderr, "Thread %d, sim: ** fast forwarding %ld insts **\n", threadid, current->fastfwd_count);

   while (!current->fastfwd_done)
   {

    current->regs.regs_R[MD_REG_ZERO] = 0;





    { (inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) + (((current->regs.regs_PC)) & (4096 - 1)))) : 0)); };
    cache_warmup (cache_il1[threadid], Read, (current->fetch_regs_PC), (sizeof(md_inst_t)), threadid);



    addr = 0;
    is_write = 0;


    fault = md_fault_none;


    { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };


    switch (op)
    {
# 9924 "sim-outorder.c"
# 1 "machine.def" 1
case SPECIAL_LINK: _panic("machine.def", __FUNCTION__, 1, "attempted to execute a linking opcode");

case REGIMM_LINK: _panic("machine.def", __FUNCTION__, 3, "attempted to execute a linking opcode");
# 12 "machine.def"
case JUMP: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 26 "machine.def"
case JAL: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 41 "machine.def"
case BEQ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 57 "machine.def"
case BNE: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) != ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 73 "machine.def"
case BLEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) <= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 89 "machine.def"
case BGTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) > 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 101 "machine.def"
case ADDI: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((int)(( short)(inst & 0xffff))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 110 "machine.def"
case ADDIU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 122 "machine.def"
case SLTI: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 134 "machine.def"
case SLTIU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 143 "machine.def"
case ANDI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff)))); }; break;
# 152 "machine.def"
case ORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff)))); }; break;
# 161 "machine.def"
case XORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff)))); }; break;
# 170 "machine.def"
case LUI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16))); }; break;




case COP0_LINK: _panic("machine.def", __FUNCTION__, 175, "attempted to execute a linking opcode");

case COP1_LINK: _panic("machine.def", __FUNCTION__, 177, "attempted to execute a linking opcode");

case COP2_LINK: _panic("machine.def", __FUNCTION__, 179, "attempted to execute a linking opcode");

case SPECIAL2_LINK: _panic("machine.def", __FUNCTION__, 181, "attempted to execute a linking opcode");
# 193 "machine.def"
case LB: { sbyte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 208 "machine.def"
case LH: { shalf_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 249 "machine.def"
case LWL: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))))))); }; break;
# 265 "machine.def"
case LW: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 289 "machine.def"
case LL: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; if(!current->spec_mode && _result == 0) { common_regs_s[current->masterid][current->actualid].regs_lock = 1; common_regs_s[current->masterid][current->actualid].address = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))); } (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 307 "machine.def"
case LBU: { byte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 322 "machine.def"
case LHU: { half_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 362 "machine.def"
case LWR: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))]))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])))))); }; break;
# 377 "machine.def"
case SB: { byte_t _src; enum md_fault_type _fault; _src = (byte_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_byte = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_byte, sizeof(temp_byte), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 392 "machine.def"
case SH: { half_t _src; enum md_fault_type _fault; _src = (half_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_half = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_half, sizeof(temp_half), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 432 "machine.def"
case SWL: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (8 * (4 - (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)))) & (md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])) | (_lr_temp & ~(md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])+((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 447 "machine.def"
case SW: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 501 "machine.def"
case SC: { word_t _src; enum md_fault_type _fault; int ii = 0; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if(COHERENT_CACHE && allForked && collect_stats) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if(_fault != md_fault_none) { { fault = (_fault); break; }; } } else { if(!current->spec_mode) { if((common_regs_s[current->masterid][current->actualid].regs_lock == 1) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) + (((int)(( short)(inst & 0xffff)))))) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { { fault = (_fault); break; }; } for(ii = 0; ii < 64; ii++) { if(common_regs_s[current->masterid][ii].address == (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))) { common_regs_s[current->masterid][ii].regs_lock = 0; common_regs_s[current->masterid][ii].address = 0; } } } else (current->spec_mode ? ((current->spec_regs_R[((inst >> 21) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] |= (1 << (((((inst >> 21) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 21) & 0x1f)]) : (current->regs.regs_R[((inst >> 21) & 0x1f)] = (0))); } else { current->waitForBranchResolve = 1; } } }; break;
# 547 "machine.def"
case SWR: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (8 * (4 - (4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))))) & ~(md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | (_lr_temp & (md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 568 "machine.def"
case LWC1: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result))); }; break;
# 591 "machine.def"
case LDC1: { word_t _result_hi, _result_lo; enum md_fault_type _fault; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; _result_hi = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _result_lo = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))) + 4)), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi))); (current->spec_mode ? ((current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo)), (((current->use_spec_F)[((((((inst >> 16) & 0x1f)) + 1)&~1))/32] |= (1 << (((((((inst >> 16) & 0x1f)) + 1)&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)]) : (current->regs.regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo))); }; break;
# 606 "machine.def"
case SWC1: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 639 "machine.def"
case SDC1: { enum md_fault_type _fault; qword_t wxh_q; word_t*wxh_ptr = (word_t*)&wxh_q; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; *wxh_ptr = ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]) ; wxh_ptr++; *wxh_ptr = ((((current->use_spec_F)[((((((inst >> 16) & 0x1f))+1)&~1))/32] & (1 << (((((((inst >> 16) & 0x1f))+1)&~1)) % 32))) != 0) ? current->spec_regs_F.l[((((inst >> 16) & 0x1f))+1)] : current->regs.regs_F.l[((((inst >> 16) & 0x1f))+1)]); (temp_qword = ((wxh_q)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_qword, sizeof(temp_qword))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_qword, sizeof(temp_qword), current->id, inst)))); }; break;











case SLL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f))))); }; break;




case MOVCI_LINK: _panic("machine.def", __FUNCTION__, 656, "attempted to execute a linking opcode");
# 681 "machine.def"
case SRL: { if (((((inst) >> (6)) & (0x1f))) != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 713 "machine.def"
case SRA: { int _i; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < (((inst) >> (6)) & (0x1f)); _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f))))); } }; break;
# 722 "machine.def"
case SLLV: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037)))); }; break;
# 751 "machine.def"
case SRLV: { int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (_shamt != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 784 "machine.def"
case SRAV: { int _i; int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < _shamt; _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt))); } }; break;
# 799 "machine.def"
case JR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 816 "machine.def"
case JALR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8))); (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 826 "machine.def"
case MOVZ: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 836 "machine.def"
case MOVN: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 845 "machine.def"
case SYSCALL: { ( (current->spec_mode ? _panic("machine.def", __FUNCTION__, 848, "speculative syscall") : (void) 0), sys_syscall(&(current->regs), mem_access, current->mem, inst, 1)); }; break;
# 857 "machine.def"
case BREAK: { { fault = (md_fault_break); break; }; }; break;
# 868 "machine.def"
case MFHI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); }; break;
# 877 "machine.def"
case MTHI: { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 886 "machine.def"
case MFLO: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); }; break;
# 895 "machine.def"
case MTLO: { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 957 "machine.def"
case MULT: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } }; break;
# 989 "machine.def"
case MULTU: { int _i; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } } }; break;
# 1003 "machine.def"
case DIV: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; int quotient = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) / ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); int mod = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) % ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (current->spec_mode ? ((current->spec_regs_C.lo = (quotient)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (quotient))); (current->spec_mode ? ((current->spec_regs_C.hi = (mod)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (mod))); }; break;
# 1015 "machine.def"
case DIVU: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; (current->spec_mode ? ((current->spec_regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); (current->spec_mode ? ((current->spec_regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1027 "machine.def"
case ADD: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1036 "machine.def"
case ADDU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1048 "machine.def"
case SUB: { if (((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) > 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < 0) && (0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))) || (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) < 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > 0) && (-0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1057 "machine.def"
case SUBU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1066 "machine.def"
case AND: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1075 "machine.def"
case OR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1084 "machine.def"
case XOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1093 "machine.def"
case NOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1105 "machine.def"
case SLT: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1117 "machine.def"
case SLTU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1137 "machine.def"
case TEQ: { if(current->spec_mode) break; if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])==((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) _fatal("machine.def", __FUNCTION__, 1140, "TEQ TRAP!\n"); }; break;








# 1159 "machine.def"
case MOVF: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 1176 "machine.def"
case MOVT: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 1) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;






# 1195 "machine.def"
case BLTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1211 "machine.def"
case BGEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1228 "machine.def"
case BLTZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1245 "machine.def"
case BGEZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;











case MFC0: { _fatal("machine.def", __FUNCTION__, 1260, "MFC0 unimplemented\n"); }; break;
# 1266 "machine.def"
case MTC0: { _fatal("machine.def", __FUNCTION__, 1269, "MTC0 unimplemented\n"); }; break;











case MFC1: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1287 "machine.def"
case CFC1: { }; break;
# 1296 "machine.def"
case MTC1: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 11) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1305 "machine.def"
case CTC1: { }; break;




case COP1_BC_LINK: _panic("machine.def", __FUNCTION__, 1310, "attempted to execute a linking opcode");

case COP1_S_LINK: _panic("machine.def", __FUNCTION__, 1312, "attempted to execute a linking opcode");

case COP1_D_LINK: _panic("machine.def", __FUNCTION__, 1314, "attempted to execute a linking opcode");

case COP1_W_LINK: _panic("machine.def", __FUNCTION__, 1316, "attempted to execute a linking opcode");


# 1330 "machine.def"
case BC1F: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (!((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1345 "machine.def"
case BC1T: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) +4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;





# 1359 "machine.def"
case FADD_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1371 "machine.def"
case FSUB_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1383 "machine.def"
case FMUL_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1395 "machine.def"
case FDIV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1407 "machine.def"
case FSQRT_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1419 "machine.def"
case FABS_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1431 "machine.def"
case FMOV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1443 "machine.def"
case FNEG_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1452 "machine.def"
case TRUNC_S: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1))); }; break;




case COP1_MOVCF_S_LINK: _panic("machine.def", __FUNCTION__, 1457, "attempted to execute a linking opcode");
# 1468 "machine.def"
case FMOVZ_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1481 "machine.def"
case FMOVN_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1493 "machine.def"
case CVT_D_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1505 "machine.def"
case CVT_W_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1517 "machine.def"
case C_EQ_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1529 "machine.def"
case C_LT_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1541 "machine.def"
case C_LE_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;











case MOVF_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1563 "machine.def"
case MOVT_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;





# 1577 "machine.def"
case FADD_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1589 "machine.def"
case FSUB_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1601 "machine.def"
case FMUL_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1613 "machine.def"
case FDIV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1625 "machine.def"
case FSQRT_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1637 "machine.def"
case FABS_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1649 "machine.def"
case FMOV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1661 "machine.def"
case FNEG_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;




case COP1_MOVCF_D_LINK: _panic("machine.def", __FUNCTION__, 1666, "attempted to execute a linking opcode");
# 1676 "machine.def"
case FMOVZ_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1689 "machine.def"
case FMOVN_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1698 "machine.def"
case TRUNC_D: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1))); }; break;
# 1712 "machine.def"
case CVT_S_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1724 "machine.def"
case CVT_W_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1736 "machine.def"
case C_EQ_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1748 "machine.def"
case C_LT_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1760 "machine.def"
case C_LE_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;











case MOVF_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1782 "machine.def"
case MOVT_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;





# 1796 "machine.def"
case CVT_S_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1808 "machine.def"
case CVT_D_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;





# 1877 "machine.def"
case MADD: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; sword_t temp1, temp2; temp1 = ((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi); temp2 = ((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo); _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2))); }; break;
# 1886 "machine.def"
case MUL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 9925 "sim-outorder.c" 2
     default:
       _panic("sim-outorder.c", __FUNCTION__, 9926, "attempted to execute a bogus opcode 0x%x",current->regs.regs_PC);
    }

    if (fault != md_fault_none)
     _fatal("sim-outorder.c", __FUNCTION__, 9930, "fault (%d) detected @ 0x%08p", fault, current->regs.regs_PC);


    if ((md_op2flags[op]) & 0x00000020)
    {
     if ((md_op2flags[op]) & 0x00000080)
     {
      is_write = 1;


      cache_warmup(cache_dl1[threadid], Write, addr & ~7, 8, threadid);

     }

     else
      cache_warmup(cache_dl1[threadid], Read, addr & ~7, 8, threadid);

    }


    if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_NPC), (is_write ? 0x02 : 0x01), (addr), (sim_num_insn), (sim_num_insn)) : 0))
     dlite_main (current->regs.regs_PC, current->regs.regs_NPC, sim_num_insn, &(current->regs), current->mem);




                if( fl_count == 19090609 )
                    fl_flag_0 = 1;
                fl_count = fl_count +1;
    current->regs.regs_PC = current->regs.regs_NPC;
    current->regs.regs_NPC += sizeof (md_inst_t);
   }
  }
 }

 for(i = 0; i < numcontexts; i++)
 {
  thecontexts[i]->jobThdId = i;
  thecontexts[i]->helpThdId = -1;
  thecontexts[i]->oracleId = -1;
 }

 printf ("ff Stage 0 done\n");


 fstfwd_collectStats();

 WXH_HERE:
 printf ("ff stage 1 done\n");
 fflush (stdout);

 fprintf (stderr, "sim: ** starting performance simulation **\n");
# 10010 "sim-outorder.c"
 fprintf (stderr, " THRD_WAY_CACHE\n");


 fprintf (stderr, " N_WAY_CACHE: default only,  %d\n", n_way_cache);





 fprintf (stderr, "PARTITIONED_LSQ\n");







 fprintf (stderr, "DE_CENTRALIZED_LSQ\n");

 fprintf (stderr, " DE_CENTRALIZED_POWER_BUG\n");


 fprintf (stderr, "SPLIT_LSQ\n");





 fprintf (stderr, " PWR_DE_CENTRALIZED_LSQ\n");



 fprintf (stderr, "ALLOW_ANY_CLUSTER\n");
# 10066 "sim-outorder.c"
 fprintf (stderr, "N_WAY_STEER ,N_WAY:default %d \n", n_way);
# 10159 "sim-outorder.c"
 fprintf (stderr, "SELECTIVE_DISPATCH\n");
# 10192 "sim-outorder.c"
 fprintf (stderr, "INST_TRANS_RATE\n");

 fprintf (stderr, " TRACE_REG\n");



 fprintf (stderr, "IGNORE_ALL_COMM_LATENCY\n");


 fprintf (stderr, "IGNORE_MEM_COMM_LATENCY\n");
# 10210 "sim-outorder.c"
 fprintf (stderr, "FETCH_ONE_BLOCK \n");


 fprintf (stderr, "MSHR , MSHRSIZE %d\n", 10000000);





 fprintf (stderr, "NO_EXTRA_REG\n");
# 10243 "sim-outorder.c"
 fprintf (stderr, "PORT_PER_BANK\n");


 fprintf (stderr, "LINE_INTERLEAVED\n");


 fprintf (stderr, "PWR_CLUSTER,ISSUE_PER_CLUSTER \n");





 fprintf (stderr, "PWR__SMT_RR\n");

 fprintf (stderr, "REMOVE_ILP = %d\n", (unsigned int) 1);
 fprintf (stderr, "HOPTIME = %d\n", (unsigned int) 1);

 fprintf (stderr, "CENTRALIZED_CACHE_BANK\n");


 fprintf (stderr, "IGNORE_MEM_COMM_LATENCY\n");

 fprintf (stderr, "DO_DYNAMIC_ADAPTATION = %d\n", (unsigned int) 0);
 fprintf (stderr, "N_WAY = %d\n", n_way);
 fprintf (stderr, "n_way_cache = %d\n", n_way_cache);
# 10279 "sim-outorder.c"
 {
  extern char *sim_str_dump;
  char *sim_dump = sim_str_dump;
  char strFileName[256];
  if (!sim_dump)
  {
   fprintf (stderr, "No name for dump file\n");
   exit (1);
  }

  strcpy (strFileName, sim_dump);
  strcat (strFileName, ".trc");
  fp_trace = fopen (strFileName, "w");
  if(!fp_trace) _panic("sim-outorder.c", __FUNCTION__, 10292, "Could not open trace file");
 }

 allocate_free_event_list();


 for (threadid = 0; threadid < numcontexts; threadid++)
 {
  current = thecontexts[threadid];
  current->fetch_pred_PC = current->regs.regs_PC;
  current->regs.regs_NPC = current->regs.regs_PC;

  current->fetch_regs_PC = current->regs.regs_PC - sizeof (md_inst_t);
  current->regs.regs_PC = current->regs.regs_PC - sizeof (md_inst_t);



 }


 bin_init ();
 cache_init ();

 init_sp ();


 l1init_sp ();


 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  disp_time[i] = 0;
 }

 for (i = 0; i < numcontexts; i++)
 {
  reg_init (i);
  bpred_init (i);
 }


 fprintf (stderr, "Total Pregfile size - int %d fp %d\n", IPREG_size, FPREG_size);


 for (i = 0; i < 64; i++)
 {
  num_storeq[i] = 0;
  max_storeq[i] = 0;
 }

 for (mm = 0; mm <= 64; mm++)
 {
  num_picks[mm] = 0;
 }

 if (0)
 {
  actual_cacheports = CACHEPORTS;
  actual_clusters = 64;
 }
 else
 {
  cache_change_config (64);
  actual_clusters = 64;
  actual_cacheports = (CACHEPORTS * actual_clusters) / 64;
 }

 rthresh = insn_interval / 100;
 brthresh = insn_interval / 100;
 msthresh = insn_interval / 1000;
 imsthresh = insn_interval / 1000;
 cycthresh = insn_interval / 100;
 rnoise = insn_interval / 20;
 brnoise = insn_interval / 50;
 msnoise = insn_interval / 100;
 imsnoise = insn_interval / 200;


 actualProcess = 1;



 executeMaxInsn = max_insts;





 for (threadid = 0; threadid < numcontexts; threadid++)
 {
  current = thecontexts[threadid];
  current->active_this_cycle = 1;
 }



 for (threadid = 0; threadid < 64; threadid++)
 {
  for (i = 0; i < 8; i++)
  {
   m_L1WBuf[threadid][i].PC = 0;
   m_L1WBuf[threadid][i].lsqId = 0;
   m_L1WBuf[threadid][i].robId = 0;
   m_L1WBuf[threadid][i].robExId = 0;
   m_L1WBuf[threadid][i].addr = 0;
   m_L1WBuf[threadid][i].op = 0;
   m_L1WBuf[threadid][i].lat = 0;
   m_L1WBuf[threadid][i].sim_num_insn = 0;
   m_L1WBuf[threadid][i].commitDone = 0;
   m_L1WBuf[threadid][i].writeStarted = 0;
   m_L1WBuf[threadid][i].finishTime = 0;
   m_L1WBuf[threadid][i].entryTime = 0;
   m_L1WBuf[threadid][i].writeValue = 0;
   m_L1WBuf[threadid][i].isMiss = 0;
   m_L1WBuf[threadid][i].STL_C_fail = 0;
   m_L1WBuf[threadid][i].already_check = 0;
  }
  m_L1WBufCnt[threadid] = 0;
  m_L1WBuf_head[threadid] = 0;
  m_L1WBuf_tail[threadid] = 0;
 }

 if (!mystricmp (network_type, "FSOI") || !mystricmp (network_type, "HYBRID"))
  maindirectsim(network_receiver, network_conflict);
 else if (!mystricmp (network_type, "MESH"))
  mainPopnet(mesh_size+3);
 else if ((!mystricmp (network_type, "COMB")))
 {
  maindirectsim(network_receiver, network_conflict);
  mainPopnet(mesh_size+3);
 }

 for (;;)
 {


  for(i = 0; i < numcontexts; i++)
   freeMSHR(cache_dl1[i]->mshr);
  freeL2MSHR(cache_dl2->mshr);
# 10441 "sim-outorder.c"
  ((ptrace_outfd != ((void *)0) && !range_cmp_range1(&ptrace_range, (thecontexts[0]->regs.regs_PC), (sim_num_insn), (sim_cycle))) ? (!ptrace_oneshot ? (ptrace_active = ptrace_oneshot = 1) : 0) : (ptrace_active = 0));

  if (ptrace_active) __ptrace_newcycle((sim_cycle));

  for (i = 0; i<numcontexts; i++)
  {


   commit_flag[i] ++;
  }

  ruu_commit ();


  ruu_release_writebuffer ();
  ruu_write_from_Writebuffer ();



  ruu_release_fu ();

  ruu_writeback ();


  if (!bugcompat_mode)
  {
   lsq_refresh ();
   ruu_issue ();
  }

  int ggg;

  for (ggg = 0; ggg < numcontexts; ggg++)
  {
   dispatch_done[ggg] = 0;
   if (thecontexts[ggg]->active_this_cycle)
   {
    dispatch_done[ggg] = dispatched = ruu_dispatch (ggg);
   }
  }

  if (!allForked)
  {

   for (ggg = 0; ggg < numcontexts; ggg++)
   {
    collectStatStop[ggg] = 0;

   }
   collectStatBarrier = 0;
   allForked = 1;




  }


  if (flushImpStats)
  {
   flushImpStats = 0;
   collect_stats = 1;
   sim_num_insn = 0;
   realSimCycle = 0;

   for (i = 0; i < 64; i++)
   {
    m_sqLQFull[i] = 0;
    m_sqSQFull[i] = 0;
    m_sqNumLdReplay[i] = 0;
    ldstRejectionCount[i] = 0;
    seqConsReplay[i] = 0;
    seqConsInsnReplay[i] = 0;


    invalidation_replay[i] = 0;

    totalRUUsize[i] = totalLQsize[i] = totalSQsize[i] = 0;


    loadLoadReplayCount[i] = 0;

   }
   m_sqPrefetchCnt = 0;
  }

  if (timeToReturn)
  {
   fclose (fp_trace);

   for (i = 0; i < numcontexts; i++)
    simInsn[i] = thecontexts[i]->sim_num_insn;
   fprintf(stderr,"[INFO 0]: sim_num_insn=%llu", pure_num_insn);
   return;
  }

  for (i = 0; i < numcontexts; i++)
  {
   simInsn[i] = thecontexts[i]->sim_num_insn;

   totalRUUsize[i] += thecontexts[i]->RUU_num;
   avgRUUsize[i] = (1.0 * totalRUUsize[i]) / realSimCycle;

   totalLQsize[i] += thecontexts[i]->m_shLQNum;
   avgLQsize[i] = (1.0 * totalLQsize[i]) / realSimCycle;


   totalSQsize[i] += thecontexts[i]->m_shSQNum + m_L1WBufCnt[i];



   avgSQsize[i] = (1.0 * totalSQsize[i]) / realSimCycle;
  }







  if (bugcompat_mode)
  {


   lsq_refresh ();



   ruu_issue ();
  }

  ruu_fetch ();

  dir_fifo_dequeue();
  dir_eventq_nextevent();



  if (!mystricmp (network_type, "FSOI") || !mystricmp (network_type, "HYBRID"))
   directRunSim(sim_cycle);
  else if (!mystricmp (network_type, "MESH"))
   popnetRunSim(sim_cycle);
  else if ((!mystricmp (network_type, "COMB")))
  {
   directRunSim(sim_cycle);
   popnetRunSim(sim_cycle);
  }

  int f, j;
  for(f=0; f<16; f++)
  {
   if(mem_port_lat[f] != 0)
    mem_port_lat[f] --;
  }
  if(!mystricmp(network_type, "HYBRID"))
  {
   for(f = 0; f< 100; f++)
    for(j = 0; j< 100; j++)
     if(link_ser_lat[f][j] > 0)
      link_ser_lat[f][j] --;
  }

  for (threadid = 0; threadid < numcontexts; threadid++)
  {
   update_power_stats(thecontexts[0]->power, threadid, thecontexts[threadid]);

   current = thecontexts[threadid];
   if (current->ruu_fetch_issue_delay)
    current->ruu_fetch_issue_delay--;
  }
  clear_access_stats();
# 10621 "sim-outorder.c"
  if (hotspot_active && sim_cycle >= last_hotspot_cycle + hotspot_cycle_sampling_intvl)
  {
   update_hotspot_stats (sim_cycle - last_hotspot_cycle);
   last_hotspot_cycle = sim_cycle;
  }

  check_fu_busy ();
  int tt;

  if (!spec_benchmarks && max_insts && !max_barrier)
  {
   for (threadid = 0; threadid < numcontexts; threadid++)
   {
    current = thecontexts[threadid];
     if (((unsigned long) (current->sim_num_insn - 0) >= (unsigned long) max_insts) && current->running)
     {
      fprintf (stderr, "Thread %d has exceeded max_insts; killing all threads.\n", threadid);
      killall = 1;
     }
   }
  }

  for (threadid = 0, thread_stop = 0; threadid < numcontexts; threadid++)
  {
   int tmp = 0, tid;

   current = thecontexts[threadid];

    if (((killall || tmp || (spec_benchmarks && max_insts && !max_barrier && ((unsigned long) (current->sim_num_insn - 0) >= (unsigned long) max_insts))) && current->running))
    {
     current->finish_cycle = (unsigned long) (sim_cycle - cyclecheck);
     current->running = 0;
     stopped_num_threads++;

     activecontexts = numcontexts - stopped_num_threads;

     thread_stop = 1;
     fprintf (stderr, "********Thread %d finish at %lu**********\n", threadid, (unsigned long) current->finish_cycle);
     fprintf (stderr, "IPC_patial%d,per thread %4.3f,    ", stopped_num_threads, (double) (sim_num_insn - 0) / (double) (sim_cycle - cyclecheck));

     if (hotspot_active && sim_hotspotout_fd != stderr)
     {
      fprintf (sim_hotspotout_fd, "********Thread %d finish at %lu**********\n", threadid, (unsigned long) current->finish_cycle);
     }

     for (threadid = 0; threadid < numcontexts; threadid++)
     {
      current = thecontexts[threadid];
      if (current->finish_cycle)
       fprintf (stderr, "%4.3f, ", (double) (current->sim_num_insn - 0) / (double) (current->finish_cycle - cyclecheck));
      else
       fprintf (stderr, "%4.3f, ", (double) (current->sim_num_insn - 0) / (double) (sim_cycle - cyclecheck));
     }
     fprintf (stderr, "\n");
     fprintf (stderr, "num_insn_patial%d,per thread %lu,    ", stopped_num_threads, (unsigned long) (sim_num_insn - 0));

     for (threadid = 0; threadid < numcontexts; threadid++)
     {
      current = thecontexts[threadid];
      if (current->finish_cycle)
       fprintf (stderr, "%lu, ", (unsigned long) (current->sim_num_insn - 0));
      else
       fprintf (stderr, "%lu, ", (unsigned long) (current->sim_num_insn - 0));
     }
     fprintf (stderr, "\n");
     if (stopped_num_threads == numcontexts)
     {
      fprintf (stderr, "********All finish  simulation done**********\n");
      fprintf (stderr, "finish_cycle %lu, per thread ,  ", (unsigned long) sim_cycle);
      for (threadid = 0; threadid < numcontexts; threadid++)
      {
       current = thecontexts[threadid];
       fprintf (stderr, "%lu, ", (unsigned long) (current->finish_cycle - 0));
      }
      fprintf (stderr, "\n");
     }
    }
  }
  now_time = time ((time_t *) ((void *)0));

  if (!sim_cycle)
   print_time = now_time;
  sim_elapsed_sec = 0;

  if ((unsigned long) sim_num_insn && ((stopped_num_threads == numcontexts) || thread_stop))
  {
   if (stopped_num_threads == numcontexts)
   {
    sim_cycle -= warmupEndCycle;
    fprintf(stderr,"[INFO 1]: sim_num_insn=%llu", pure_num_insn);
    return;
   }
  }
# 10764 "sim-outorder.c"
  sim_cycle++;

  reset_ports();
# 10785 "sim-outorder.c"
  realSimCycle++;
  int no_ideal = 1;
  for (i = 0; i < numcontexts; i++)
  {
   int lat = 1000;
   if (!allForked)
   {
    if ((thecontexts[i]->freeze == 1) && (thecontexts[i]->running == 0) && ((thecontexts[i]->sleptAt + 1000) < sim_cycle) && (!spec_benchmarks))
    {
     thecontexts[i]->freeze = 0;
     thecontexts[i]->running = 1;
    }
   }
   else
   {
    if ((thecontexts[i]->freeze == 1) && (thecontexts[i]->running == 0) && (thecontexts[i]->sleptAt + lat + (random () % 20) < sim_cycle) && (!spec_benchmarks) && no_ideal)
    {
     thecontexts[i]->freeze = 0;
     thecontexts[i]->running = 1;
     if (collect_stats)
      quienseWakeup[i]++;
    }
   }
  }

  if (((!max_barrier && (pure_num_insn > executeMaxInsn)) || (max_barrier && TotalBarriers >= max_barrier)) && collect_stats)
  {
   for (i = 0; i < numcontexts; i++)
    simInsn[i] = thecontexts[i]->sim_num_insn;
   for (i = 0; i < numcontexts; i++)
   {
    struct cache_t *cp = cache_dl1[i];
    int j = 0, set = 0, m = 0;
    struct cache_blk_t *blk;
    for(j=0;j<cp->nsets;j++)
    {
     for (blk = cp->sets[j].way_head; blk; blk = blk->way_next)
     {
      for(m=0;m<8;m++)
       if(blk->WordUseFlag[m])
        blk->WordCount ++;
      stats_do(blk->addr, blk->ReadCount, blk->WriteCount, blk->WordCount, blk->Type, i);
     }
    }
   }
   stats_collect();
   fprintf(stderr,"[INFO 2]: sim_num_insn=%llu, barriers=%d", pure_num_insn, TotalBarriers);
   return;
  }
  if (unPrintLimit < 50 && (pure_num_insn >= (unPrintLimit * (max_insts / 50))))
  {
   if (!mystricmp (network_type, "FSOI") || !mystricmp (network_type, "HYBRID"))
   {
    printf ("[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d\%\tdata_packets_generate=%d\t", sim_cycle, pure_num_insn, (int)((unPrintLimit * 100) / 50), global_data_packets_generation);
    fprintf (stderr, "[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d\%\tdata_packets_generate=%d\t", sim_cycle, pure_num_insn, (int)((unPrintLimit * 100) / 50), global_data_packets_generation);
   }
   else if (!mystricmp (network_type, "MESH"))
   {
    printf ("[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d%\tdata_packets_generate=%d\t", sim_cycle, pure_num_insn, (unPrintLimit * 100) / 50, DataPackets_1);
    fprintf (stderr, "[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d%\tdata_packets_generate=%d\tmeta_packets%d\t", sim_cycle, pure_num_insn, (unPrintLimit * 100) / 50, DataPackets_1, MetaPackets_1);
   }
   else if ((!mystricmp (network_type, "COMB")))
   {
    printf ("[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d%\t", sim_cycle, pure_num_insn, (unPrintLimit * 100) / 50);
    fprintf (stderr, "[INFO]: sim_cycle= %lld\tsim_num_insn=%lld\tProgress=%d%\t", sim_cycle, pure_num_insn, (unPrintLimit * 100) / 50);
   }
   fflush (stderr);
   fflush (stdout);
   printf("barriers=%lld\tlocks=%lld\n", TotalBarriers, TotalLocks);
   fprintf(stderr, "barriers=%lld\tlocks=%lld\n", TotalBarriers, TotalLocks);
   fflush (stderr);
   fflush (stdout);
   unPrintLimit++;
   global_data_packets_generation = 0;
   DataPackets_1 = 0;
   MetaPackets_1 = 0;
  }
 }
}


 int
get_free_reg (int lregnum, int threadid)
{
 int tempval;
 struct listelt *temp;

 context *current;

 current = thecontexts[threadid];

 if ((lregnum < 1) || (lregnum > 62))
  return 0;
 if (lregnum < 32)
 {
  if (!ifreelist_head[threadid])
  {
   printf ("Num of IREG=%d\n", iregfile);
   fprintf (stderr, "Num of IREG=%d\n", iregfile);
   _panic("sim-outorder.c", __FUNCTION__, 10884, "Out of registers?!");
  }

  temp = ifreelist_head[threadid];
  tempval = temp->preg;
  ifreelist_head[threadid] = ifreelist_head[threadid]->next;
  if (!ifreelist_head[threadid])
   ifreelist_tail[threadid] = ((void *)0);
  if (ifreelist_head[threadid])
   ifreelist_head[threadid]->prev = ((void *)0);
  free (temp);
  current->ltopmap[lregnum] = tempval;
  current->ptolmap[tempval].lreg = lregnum;
  current->ptolmap[tempval].threadid = threadid;



  iregfile_cl[threadid]++;
  return tempval;
 }
 else
 {
  if (!ffreelist_head[threadid])
  {
   printf ("Num of FREG=%d\n", fregfile);
   fprintf (stderr, "Num of FREG=%d\n", fregfile);
   _panic("sim-outorder.c", __FUNCTION__, 10910, "Out of registers?!");
  }

  temp = ffreelist_head[threadid];
  tempval = temp->preg;
  ffreelist_head[threadid] = ffreelist_head[threadid]->next;
  if (!ffreelist_head[threadid])
   ffreelist_tail[threadid] = ((void *)0);
  if (ffreelist_head[threadid])
   ffreelist_head[threadid]->prev = ((void *)0);
  free (temp);
  current->ltopmap[lregnum] = tempval;
  current->ptolmap[tempval].lreg = lregnum;
  current->ptolmap[tempval].threadid = threadid;



  fregfile_cl[threadid]++;
  return tempval;
 }
}


 void
freelist_insert (int pregnum, int threadid)
{
 struct listelt *elt;
 struct listelt *p;
 struct listelt *q;

 context *current = thecontexts[threadid];


 if (threadid == 0)
 {
  p = ifreelist_head[threadid];
  while (p)
  {
   q = p;
   p = p->next;
  }
 }


 if (!pregnum)
  return;
 if (pregnum <= IPREG_size)
 {



  elt = (struct listelt *) malloc (sizeof (struct listelt));
  elt->preg = pregnum;
  if (ifreelist_tail[threadid])
  {
   p = ifreelist_head[threadid];
   q = ((void *)0);
   while (p && (p->preg < pregnum))
   {
    q = p;
    p = p->next;
   }
   if (!p || !0)
   {
    ifreelist_tail[threadid]->next = elt;
    elt->prev = ifreelist_tail[threadid];
    elt->next = ((void *)0);
    ifreelist_tail[threadid] = elt;
   }
   else if (q)
   {
    q->next = elt;
    elt->prev = q;
    elt->next = p;
    p->prev = elt;
   }
   else
   {
    elt->next = ifreelist_head[threadid];
    ifreelist_head[threadid]->prev = elt;
    elt->prev = ((void *)0);
    ifreelist_head[threadid] = elt;
   }
  }
  else
  {
   elt->next = ((void *)0);
   elt->prev = ((void *)0);
   ifreelist_tail[threadid] = elt;
   ifreelist_head[threadid] = elt;
  }
  current->ptolmap[pregnum].lreg = 0;
  current->ptolmap[pregnum].threadid = -1;
  iregfile_cl[threadid]--;
 }
 else
 {



  elt = (struct listelt *) malloc (sizeof (struct listelt));
  elt->preg = pregnum;
  if (ffreelist_tail[threadid])
  {
   p = ffreelist_head[threadid];
   q = ((void *)0);
   while (p && (p->preg < pregnum))
   {
    q = p;
    p = p->next;
   }
   if (!p || !0)
   {
    ffreelist_tail[threadid]->next = elt;
    elt->prev = ffreelist_tail[threadid];
    elt->next = ((void *)0);
    ffreelist_tail[threadid] = elt;
   }
   else if (q)
   {
    q->next = elt;
    elt->prev = q;
    elt->next = p;
    p->prev = elt;
   }
   else
   {
    elt->next = ffreelist_head[threadid];
    ffreelist_head[threadid]->prev = elt;
    elt->prev = ((void *)0);
    ffreelist_head[threadid] = elt;
   }
  }
  else
  {
   elt->next = ((void *)0);
   elt->prev = ((void *)0);
   ffreelist_tail[threadid] = elt;
   ffreelist_head[threadid] = elt;
  }
  fregfile_cl[threadid]--;
  current->ptolmap[pregnum].lreg = 0;
  current->ptolmap[pregnum].threadid = -1;
 }
}

 void
recFreeRegList (int threadid)
{
 struct listelt *p;
 struct listelt *temp;
 int count = 0;
 int i;

 p = ifreelist_head[threadid];
 if (p)
 {
  count++;
  while ((p != ifreelist_tail[threadid]) && p)
  {
   count++;
   temp = p;
   p = p->next;
   free (temp);
  }
 }

 p = ffreelist_head[threadid];
 if (p)
 {
  count++;
  while ((p != ffreelist_tail[threadid]) && p)
  {
   count++;
   temp = p;
   p = p->next;
   free (temp);
  }
 }

 reg_init (threadid);
}

 int
numFreeReg (int threadid)
{
 struct listelt *p;
 int count = 0;

 p = ifreelist_head[threadid];
 if (p)
 {
  count++;
  while ((p != ifreelist_tail[threadid]) && p)
  {
   count++;
   p = p->next;
  }
 }

 p = ffreelist_head[threadid];
 if (p)
 {
  count++;
  while ((p != ffreelist_tail[threadid]) && p)
  {
   count++;
   p = p->next;
  }
 }
 return count;
}


 void
copy_to (int threadid)
{
 int i;

 context *current;

 current = thecontexts[threadid];

 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  current->ltopmap_chk[i] = current->ltopmap[i];
 }
 for (i = 0; i < p_total_regs; i++)
 {
  if (current->ptolmap[i].threadid == threadid)
  {
   current->ptolmap_chk[i].lreg = current->ptolmap[i].lreg;
   current->ptolmap_chk[i].threadid = current->ptolmap[i].threadid;
  }
 }
}


 void
copy_from (int threadid)
{
 int i;

 context *current;

 current = thecontexts[threadid];

 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  current->ltopmap[i] = current->ltopmap_chk[i];
 }
}


 void
bpred_init (int i)
{

 if (ruu_branch_penalty < 1)
  _fatal("sim-outorder.c", __FUNCTION__, 11169, "mis-prediction penalty must be at least 1 cycle");

 if (fetch_speed != 1)
  _fatal("sim-outorder.c", __FUNCTION__, 11172, "front-end speed must be 1 for SMT version of simulator");

 if (!mystricmp (pred_type, "bimod"))
 {
  if (bimod_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 11177, "bad bimod predictor config (<table_size>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 11179, "bad btb config (<num_sets> <associativity>)");
  thecontexts[i]->pred = bpred_create (BPred2bit,
                           bimod_config[0],
                       0,
                       0,
                          0,
                           0,
                              0,
                   btb_config[0],
                    btb_config[1],
                              ras_size);
 }
 else if (!mystricmp (pred_type, "2lev"))
 {

  if (twolev_nelt != 4)
   _fatal("sim-outorder.c", __FUNCTION__, 11195, "bad 2-level pred config (<l1size> <l2size> <hist_size> <xor>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 11197, "bad btb config (<num_sets> <associativity>)");

  thecontexts[i]->pred = bpred_create (BPred2Level,
                           0,
                       twolev_config[0],
                       twolev_config[1],
                          0,
                           twolev_config[2],
                              twolev_config[3],
                   btb_config[0],
                    btb_config[1],
                              ras_size);
 }
 else if (!mystricmp (pred_type, "comb"))
 {

  if (twolev_nelt != 4)
   _fatal("sim-outorder.c", __FUNCTION__, 11214, "bad 2-level pred config (<l1size> <l2size> <hist_size> <xor>)");
  if (bimod_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 11216, "bad bimod predictor config (<table_size>)");
  if (comb_nelt != 1)
   _fatal("sim-outorder.c", __FUNCTION__, 11218, "bad combining predictor config (<meta_table_size>)");
  if (btb_nelt != 2)
   _fatal("sim-outorder.c", __FUNCTION__, 11220, "bad btb config (<num_sets> <associativity>)");

  thecontexts[i]->pred = bpred_create (BPredComb,
                           bimod_config[0],
                  twolev_config[0],
                  twolev_config[1],
                          comb_config[0],
                           twolev_config[2],
                              twolev_config[3],
                   btb_config[0],
                    btb_config[1],
                              ras_size);
 }

 if (!bpred_spec_opt)
  bpred_spec_update = spec_CT;
 else if (!mystricmp (bpred_spec_opt, "ID"))
  bpred_spec_update = spec_ID;
 else if (!mystricmp (bpred_spec_opt, "WB"))
  bpred_spec_update = spec_WB;
 else
  _fatal("sim-outorder.c", __FUNCTION__, 11241, "bad speculative update stage specifier, use {ID|WB}");

 bpred_reg_stats (thecontexts[i]->pred, sim_sdb, i);
}


 void
reg_init (int threadid)
{
 int i;

 context *current;

 current = thecontexts[threadid];

 ifreelist_head[threadid] = ((void *)0);
 ifreelist_tail[threadid] = ((void *)0);
 ffreelist_head[threadid] = ((void *)0);
 ffreelist_tail[threadid] = ((void *)0);







 for (i = 0; i < p_total_regs; i++)
 {
  freelist_insert (i, threadid);
  current->ptolmap[i].lreg = 0;
  current->ptolmap[i].threadid = -1;
 }
 iregfile_cl[threadid] = 0;
 fregfile_cl[threadid] = 0;


 current = thecontexts[threadid];
 for (i = 0; i < 63; i++)
 {
  current->ltopmap[i] = get_free_reg (i, threadid);
 }
 for (i = 63; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
  current->ltopmap[i] = 0;



}

 void
reg_count ()
{

 iregfile = 0;
 fregfile = 0;
 int i, j;
 context *current;

 for (j = 0; j < numcontexts; j++)
 {
  current = thecontexts[j];
  for (i = 1; i < p_total_regs; i++)
  {
   if ((current->ptolmap[i].lreg > 0) && (current->ptolmap[i].lreg < 32) && current->ptolmap[i].threadid != -1)
   {
    iregfile++;
   }
   if ((current->ptolmap[i].lreg > 31) && (current->ptolmap[i].lreg < 63) && current->ptolmap[i].threadid != -1)
   {
    fregfile++;
   }
  }
 }
 if (iregfile < 31)
  _panic("sim-outorder.c", __FUNCTION__, 11314, "phys iregfile less than 31");
 if (fregfile < 31)
  _panic("sim-outorder.c", __FUNCTION__, 11316, "phys fregfile less than 31");
}


 void
initParallelSimulation ()
{
 int cnt, cx, j;
 long long int x, y, z, max;

 for (cnt = 0; cnt < numcontexts; cnt++)
  thecontexts[cnt]->start_cycle = sim_cycle;

 for (cx = 0; cx < numcontexts; cx++)
 {
  thecontexts[cx]->fetch_num = 0;
  thecontexts[cx]->fetch_tail = thecontexts[cx]->fetch_head = 0;
  thecontexts[cx]->fetch_pred_PC = thecontexts[cx]->fetch_regs_PC = thecontexts[cx]->regs.regs_NPC;
  collectStatStop[cx] = 0;
  thecontexts[cx]->sim_num_insn = 0;
 }
 collectStatBarrier = 0;
 allForked = 1;
}
# 11384 "sim-outorder.c"
 int
checkLSQforSt (int i, context * current)
{

 struct RUU_station *rs = &current->LSQ[i];
 int nW1 = GetMemAccWidth (rs->op);

 if (i != current->LSQ_head)
 {
  for (;;)
  {
   i = (i + (LSQ_size - 1)) % LSQ_size;

   if (((md_op2flags[current->LSQ[i].op]) & 0x00000080) && (((&current->LSQ[i])->idep_ready[1])) && (current->LSQ[i].threadid == rs->threadid))
   {
    int nW2 = GetMemAccWidth (current->LSQ[i].op);
    int nW = (nW1 >= nW2) ? nW1 : nW2;
    md_addr_t qwAddr1 = rs->addr & ~(nW - 1);
    md_addr_t qwAddr2 = current->LSQ[i].addr & ~(nW - 1);

    if (qwAddr1 == qwAddr2)
    {
     if (current->LSQ[i].issued)
      return 1;
     else
      return 0;
    }
   }
   if (i == current->LSQ_head)
    break;
  }

 }
 return 1;
}


 void
seqConsistancyReplay (int replay_index, int threadid)
{
 context *current = thecontexts[threadid];
 int i, RUU_index, LSQ_index, temp_RUU_num, j, storeCount = m_L1WBufCnt[threadid];
 struct wb_mem_ent *link;

 struct RUU_station *temp_LSQ_rs;
 int temp_LSQ_index, temp_LSQ_num;
 int shift_right = 0;


 seqConsReplay[current->actualid]++;

 RUU_index = current->RUU_head;
 temp_RUU_num = current->RUU_num;
 LSQ_index = current->LSQ_head;
 temp_LSQ_num = current->LSQ_num;

 if (!current->RUU_num)
  _panic("sim-outorder.c", __FUNCTION__, 11441, "empty RUU");

 while (RUU_index != replay_index)
 {

  if (!temp_RUU_num)
   _panic("sim-outorder.c", __FUNCTION__, 11447, "empty RUU");


  if (current->RUU[RUU_index].ea_comp)
  {
   if ((md_op2flags[current->LSQ[LSQ_index].op]) & 0x00000080)
   {
    int width = GetMemAccWidth(current->LSQ[LSQ_index].op);

    if ((width & (width - 1)) == 0 && (current->LSQ[LSQ_index].addr & (width - 1)) == 0 && !current->LSQ[LSQ_index].isPrefetch)
     storeCount++;
   }
   LSQ_index = (LSQ_index + 1) % LSQ_size;
   temp_LSQ_num--;
  }
  RUU_index = (RUU_index + 1) % RUU_size;
  temp_RUU_num--;
 }

 while (RUU_index != current->RUU_tail)
 {

  if (current->RUU[RUU_index].counted_iissueq)
  {
   current->iissueq_thrd--;
   iissueq--;
   iissueq_cl[current->id]--;
   current->RUU[RUU_index].counted_iissueq = 0;
  }
  if (current->RUU[RUU_index].counted_fissueq)
  {
   current->fissueq_thrd--;
   fissueq--;
   fissueq_cl[current->id]--;
   current->RUU[RUU_index].counted_fissueq = 0;
  }

  current->sim_num_insn--;
  sim_num_insn--;
  seqConsInsnReplay[current->actualid]++;

  if (current->RUU[RUU_index].ea_comp)
  {
   if (!temp_LSQ_num)
    _panic("sim-outorder.c", __FUNCTION__, 11491, "RUU and LSQ out of sync");

   if (current->LSQ[LSQ_index].counted_iissueq)
   {
    current->iissueq_thrd--;
    iissueq--;
    iissueq_cl[current->id]--;
    current->LSQ[LSQ_index].counted_iissueq = 0;
   }
   if (current->LSQ[LSQ_index].counted_fissueq)
   {
    current->fissueq_thrd--;
    fissueq--;
    fissueq_cl[current->id]--;
    current->LSQ[LSQ_index].counted_fissueq = 0;
   }

   for (i = 0; i < 2; i++)
   {
    { struct RS_link *fl_link, *fl_link_next; for (fl_link=(current->LSQ[LSQ_index].odep_list[i]); fl_link; fl_link=fl_link_next) { fl_link_next = fl_link->next; { struct RS_link *f_link = (fl_link); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; }; } };
    current->LSQ[LSQ_index].odep_list[i] = ((void *)0);
   }


   if (current->LSQ[LSQ_index].op == SC)
   {
    current->waitForSTLC = 0;
   }
   int matchnum = MSHR_block_check(cache_dl1[threadid]->mshr, current->LSQ[LSQ_index].addr, cache_dl1[threadid]->set_shift);
   if(matchnum)
   {
    matchnum = matchnum-1;
    struct RUU_station *rs_rob = &current->RUU[RUU_index];
    struct RUU_station *rs_lsq = &current->LSQ[LSQ_index];

    if(cache_dl1[threadid]->mshr->mshrEntry[matchnum].rs == rs_rob || cache_dl1[threadid]->mshr->mshrEntry[matchnum].rs == rs_lsq)
     cache_dl1[threadid]->mshr->mshrEntry[matchnum].event->rs = ((void *)0);

    struct RS_list *cur = rs_cache_list[threadid][matchnum];

    while(cur)
    {
     if(cur->rs == rs_rob || cur->rs == rs_lsq)
      cur->rs = ((void *)0);
     cur = cur->next;
    }
   }
   freelist_insert (current->LSQ[LSQ_index].opreg, threadid);
   changeInEventQueue(&current->LSQ[LSQ_index], threadid);
   current->LSQ[LSQ_index].tag++;
   if (ptrace_active) __ptrace_endinst((current->LSQ[LSQ_index].ptrace_seq));
   if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000040)) == (0x00000020 | 0x00000040))
   {
    if (!current->LSQ[LSQ_index].isPrefetch)
     current->m_shLQNum--;
   }
   else if (((md_op2flags[current->LSQ[LSQ_index].op]) & (0x00000020 | 0x00000080)) == (0x00000020 | 0x00000080))
   {
    if (!current->LSQ[LSQ_index].isPrefetch)
     current->m_shSQNum--;
   }

   current->LSQ_tail = (current->LSQ_tail + LSQ_size - 1) % LSQ_size;
   LSQ_index = (LSQ_index + 1) % LSQ_size;
   current->LSQ_num--;
   temp_LSQ_num--;
  }



  for (i = 0; i < 2; i++)
  {
   { struct RS_link *fl_link, *fl_link_next; for (fl_link=(current->RUU[RUU_index].odep_list[i]); fl_link; fl_link=fl_link_next) { fl_link_next = fl_link->next; { struct RS_link *f_link = (fl_link); f_link->rs = ((void *)0); f_link->tag = 0; f_link->next = rslink_free_list; rslink_free_list = f_link; rs_link_num--; }; } };
   current->RUU[RUU_index].odep_list[i] = ((void *)0);
  }
  freelist_insert (current->RUU[RUU_index].opreg, threadid);
  changeInEventQueue(&current->RUU[RUU_index], threadid);
  current->RUU[RUU_index].tag++;
  if (ptrace_active) __ptrace_endinst((current->RUU[RUU_index].ptrace_seq));
  RUU_index = (RUU_index + 1) % RUU_size;
  current->RUU_num--;
 }
 current->RUU_tail = replay_index;


 link = current->WBtableTail;

 if (link == ((void *)0) || storeCount == 0)
 {
  current->WBtableHead = current->WBtableTail = ((void *)0);
  if (link != ((void *)0))
  {
   while (link != ((void *)0))
   {
    current->numOfWBEntry--;
    link->next = current->WBbucket_free_list;
    current->WBbucket_free_list = link;
    link = link->prev;
    current->WBbucket_free_list->prev = ((void *)0);
   }
  }
 }
 else
 {
  current->WBtableHead = current->WBtableTail;
  storeCount--;
  while (storeCount)
  {
   current->WBtableHead = current->WBtableHead->prev;
   storeCount--;
  }
  link = current->WBtableHead->prev;
  current->WBtableHead->prev = ((void *)0);

  while (link != ((void *)0))
  {
   current->numOfWBEntry--;
   link->next = current->WBbucket_free_list;
   current->WBbucket_free_list = link;
   link = link->prev;
   current->WBbucket_free_list->prev = ((void *)0);
  }
 }

 for (i = 0; i < ( 32 + 32 + 3 + 1 + 1 + 1); i++)
 {
  current->create_vector[i] = CVLINK_NULL;
  current->create_vector_rt[i] = sim_cycle;
 }

 if(current->ruu_fetch_issue_delay < 800000000/2)
  current->ruu_fetch_issue_delay = ruu_branch_penalty;


 enum md_opcode op;

 j = current->fetch_num;
 for (i = current->fetch_head; j > 0;)
 {
  { op = md_mask2op[(((current->fetch_data[i]->IR) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((current->fetch_data[i]->IR >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };
  i = (i + 1) & (ruu_ifq_size - 1);
  j--;
 }
 current->fetch_num = 0;
 current->fetch_tail = current->fetch_head = 0;
 current->fetch_pred_PC = current->fetch_regs_PC = current->regs.regs_NPC = current->regs.regs_PC;



}


 void
fixSpecState (int replay_index, int threadid)
{

 context *current = thecontexts[threadid];
 struct RUU_station *rs;
 int i, RUU_index;

 RUU_index = current->RUU_head;

 while (RUU_index != replay_index)
 {
  RUU_index = (RUU_index + 1) % RUU_size;
 }

 while (RUU_index != current->RUU_tail)
 {
  if (current->RUU[RUU_index].recover_inst && !current->RUU[RUU_index].completed)
  {
   rs = &current->RUU[RUU_index];
   ruu_recover (rs - current->RUU, rs->threadid, 0);
   tracer_recover (rs->threadid);
   bpred_recover (current->pred, rs->PC, rs->stack_recover_idx, rs->threadid);
   return;
  }
  RUU_index = (RUU_index + 1) % RUU_size;
 }
}



void
ruu_release_writebuffer ()
{
 int threadid, i, cnt, j;

 for (threadid = 0; threadid < numcontexts; threadid++)
 {
  j = m_L1WBufCnt[threadid];
  cnt = 0;
  i = m_L1WBuf_head[threadid];

  if ((m_L1WBufCnt[threadid] == 0 || m_L1WBufCnt[threadid] == 8) && (m_L1WBuf_tail[threadid] != m_L1WBuf_head[threadid]))
   _panic("sim-outorder.c", __FUNCTION__, 11686, "Head and tail pointer messed up\n");

  while (cnt != j)
  {
   if (sim_cycle >= m_L1WBuf[threadid][i].finishTime && m_L1WBuf[threadid][i].writeStarted)
   {
    if(m_L1WBuf[threadid][i].isMiss && MSHR_block_check(cache_dl1[threadid]->mshr, m_L1WBuf[threadid][i].addr, cache_dl1[threadid]->set_shift))
     break;
    if(!m_L1WBuf[threadid][i].commitDone)

    {
     completeStore(threadid, m_L1WBuf[threadid][i].addr, GetMemAccWidth(m_L1WBuf[threadid][i].op), m_L1WBuf[threadid][i].STL_C_fail);






     m_L1WBuf[threadid][i].STL_C_fail = 0;
    }

    m_L1WBufCnt[threadid]--;
    m_L1WBuf_head[threadid] = (m_L1WBuf_head[threadid] + 1) % 8;
    i = (i + 1) % 8;
    cnt++;
   }
   else
    break;
  }

  if ((m_L1WBufCnt[threadid] == 0 || m_L1WBufCnt[threadid] == 8) && (m_L1WBuf_tail[threadid] != m_L1WBuf_head[threadid]))
   _panic("sim-outorder.c", __FUNCTION__, 11717, "Head and tail pointer messed up\n");
 }
}

void
ruu_write_from_Writebuffer ()
{
 int threadid, i, cnt;
 struct res_template *fu;
 int lat = 0;
 context *current;

 for (threadid = 0; threadid < numcontexts; threadid++)
 {
  current = thecontexts[threadid];

  if ((m_L1WBufCnt[threadid] == 0 || m_L1WBufCnt[threadid] == 8) && (m_L1WBuf_tail[threadid] != m_L1WBuf_head[threadid]))
   _panic("sim-outorder.c", __FUNCTION__, 11734, "Head and tail pointer messed up\n");

  for(cnt = 0, i = m_L1WBuf_head[threadid]; cnt < m_L1WBufCnt[threadid]; cnt++, i = (i + 1) % 8)
  {
   lat = 0;

   if (!m_L1WBuf[threadid][i].writeStarted)
   {

    int matchnum;
    matchnum = MSHR_block_check(cache_dl1[threadid]->mshr, m_L1WBuf[threadid][i].addr, cache_dl1[threadid]->set_shift);
    if(matchnum)
    {
     if(m_L1WBuf[threadid][i].already_check)
     {
      cache_dl1[threadid]->in_mshr ++;
      m_L1WBuf[threadid][i].already_check = 1;
     }
     continue;
    }
    else
     m_L1WBuf[threadid][i].already_check = 0;


    fu = res_get (fu_pool, (md_op2fu[m_L1WBuf[threadid][i].op]), threadid);

    if (fu

      && !isMSHRFull(cache_dl1[threadid]->mshr, 0, threadid)

       )
    {
     if (fu->master->busy)
      _panic("sim-outorder.c", __FUNCTION__, 11767, "functional unit already in use");

     fu->master->busy = fu->issuelat;
     fu->master->usr_id = threadid;
     fu->master->duplicate = 0;

     if (cache_dl1[threadid])
     {
      dcache_access++;
      current->dcache_access++;

      invalidateOtherCache = 0;

      if (COHERENT_CACHE && allForked)
      {
       if(m_L1WBuf[threadid][i].op == SC && m_L1WBuf[threadid][i].commitDone)
       {
        lat = cache_dl1_lat;
       }
       else
       {
        if(md_valid_addr (m_L1WBuf[threadid][i].addr, current->masterid))
         lat = cache_access(cache_dl1[threadid], Write, (m_L1WBuf[threadid][i].addr&~3), ((void *)0), 4, sim_cycle, ((void *)0), ((void *)0), ((void *)0), threadid, &m_L1WBuf[threadid][i]);
       }
      }

      if(lat > cache_dl1_lat)
      {
       MSHRLookup(cache_dl1[threadid]->mshr, m_L1WBuf[threadid][i].addr, lat, 0, ((void *)0));
       m_L1WBuf[threadid][i].isMiss = 1;
      }
      m_L1WBuf[threadid][i].finishTime = sim_cycle;

     }
     m_L1WBuf[threadid][i].writeStarted = 1;
    }
    else
     break;
   }
  }
 }
}






void fstfwd_collectStats()
{
 int barrierCount = 0;
 int threadid;

 printf("Fast-forwarding till the collect stats system call\n");
 for (threadid = 0; threadid < numcontexts; threadid++)
 {

  if (thecontexts[threadid]->jobThdId != 0)
  {
   thecontexts[threadid]->regs.regs_PC = thecontexts[threadid]->regs.regs_NPC;
   thecontexts[threadid]->regs.regs_NPC += sizeof (md_inst_t);
  }

  if (thecontexts[threadid]->barrierReached == 1)
   _panic("sim-outorder.c", __FUNCTION__, 11831, "Fast forward error\n");

  if (thecontexts[threadid]->startReached == 1)
   _panic("sim-outorder.c", __FUNCTION__, 11834, "Fast forward error\n");
 }

 while(1)
 {

  for(threadid = 0; threadid < numcontexts; threadid++)
  {
   context *current = thecontexts[threadid];


   if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_PC), (0), (0), (0), (0)) : 0))
    dlite_main (current->regs.regs_PC, current->regs.regs_PC + sizeof (md_inst_t), sim_cycle, &(current->regs), current->mem);

   md_inst_t inst;
   enum md_opcode op;
   md_addr_t target_PC;
   md_addr_t addr;
   int is_write;
   byte_t temp_byte;
   half_t temp_half;
   word_t temp_word;
   if(current->running == 0 && barrier_waiting[threadid])
    continue;


   qword_t temp_qword = 0;


   enum md_fault_type fault;



   while (1)

   {




    current->regs.regs_R[MD_REG_ZERO] = 0;





    { (inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) + (((current->regs.regs_PC)) & (4096 - 1)))) : 0)); };
    cache_warmup (cache_il1[threadid], Read, (current->fetch_regs_PC), (sizeof(md_inst_t)), threadid);
    if(current->running == 0 && barrier_waiting[threadid])
     break;

    addr = 0;
    is_write = 0;


    fault = md_fault_none;


    { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };



    switch (op)
    {
# 11910 "sim-outorder.c"
# 1 "machine.def" 1
case SPECIAL_LINK: _panic("machine.def", __FUNCTION__, 1, "attempted to execute a linking opcode");

case REGIMM_LINK: _panic("machine.def", __FUNCTION__, 3, "attempted to execute a linking opcode");
# 12 "machine.def"
case JUMP: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 26 "machine.def"
case JAL: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 41 "machine.def"
case BEQ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 57 "machine.def"
case BNE: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) != ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 73 "machine.def"
case BLEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) <= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 89 "machine.def"
case BGTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) > 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 101 "machine.def"
case ADDI: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((int)(( short)(inst & 0xffff))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 110 "machine.def"
case ADDIU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 122 "machine.def"
case SLTI: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 134 "machine.def"
case SLTIU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 143 "machine.def"
case ANDI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff)))); }; break;
# 152 "machine.def"
case ORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff)))); }; break;
# 161 "machine.def"
case XORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff)))); }; break;
# 170 "machine.def"
case LUI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16))); }; break;




case COP0_LINK: _panic("machine.def", __FUNCTION__, 175, "attempted to execute a linking opcode");

case COP1_LINK: _panic("machine.def", __FUNCTION__, 177, "attempted to execute a linking opcode");

case COP2_LINK: _panic("machine.def", __FUNCTION__, 179, "attempted to execute a linking opcode");

case SPECIAL2_LINK: _panic("machine.def", __FUNCTION__, 181, "attempted to execute a linking opcode");
# 193 "machine.def"
case LB: { sbyte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 208 "machine.def"
case LH: { shalf_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 249 "machine.def"
case LWL: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))))))); }; break;
# 265 "machine.def"
case LW: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 289 "machine.def"
case LL: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; if(!current->spec_mode && _result == 0) { common_regs_s[current->masterid][current->actualid].regs_lock = 1; common_regs_s[current->masterid][current->actualid].address = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))); } (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 307 "machine.def"
case LBU: { byte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 322 "machine.def"
case LHU: { half_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 362 "machine.def"
case LWR: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))]))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])))))); }; break;
# 377 "machine.def"
case SB: { byte_t _src; enum md_fault_type _fault; _src = (byte_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_byte = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_byte, sizeof(temp_byte), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 392 "machine.def"
case SH: { half_t _src; enum md_fault_type _fault; _src = (half_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_half = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_half, sizeof(temp_half), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 432 "machine.def"
case SWL: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (8 * (4 - (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)))) & (md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])) | (_lr_temp & ~(md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])+((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 447 "machine.def"
case SW: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 501 "machine.def"
case SC: { word_t _src; enum md_fault_type _fault; int ii = 0; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if(COHERENT_CACHE && allForked && collect_stats) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if(_fault != md_fault_none) { { fault = (_fault); break; }; } } else { if(!current->spec_mode) { if((common_regs_s[current->masterid][current->actualid].regs_lock == 1) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) + (((int)(( short)(inst & 0xffff)))))) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { { fault = (_fault); break; }; } for(ii = 0; ii < 64; ii++) { if(common_regs_s[current->masterid][ii].address == (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))) { common_regs_s[current->masterid][ii].regs_lock = 0; common_regs_s[current->masterid][ii].address = 0; } } } else (current->spec_mode ? ((current->spec_regs_R[((inst >> 21) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] |= (1 << (((((inst >> 21) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 21) & 0x1f)]) : (current->regs.regs_R[((inst >> 21) & 0x1f)] = (0))); } else { current->waitForBranchResolve = 1; } } }; break;
# 547 "machine.def"
case SWR: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (8 * (4 - (4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))))) & ~(md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | (_lr_temp & (md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 568 "machine.def"
case LWC1: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result))); }; break;
# 591 "machine.def"
case LDC1: { word_t _result_hi, _result_lo; enum md_fault_type _fault; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; _result_hi = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _result_lo = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))) + 4)), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi))); (current->spec_mode ? ((current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo)), (((current->use_spec_F)[((((((inst >> 16) & 0x1f)) + 1)&~1))/32] |= (1 << (((((((inst >> 16) & 0x1f)) + 1)&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)]) : (current->regs.regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo))); }; break;
# 606 "machine.def"
case SWC1: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 639 "machine.def"
case SDC1: { enum md_fault_type _fault; qword_t wxh_q; word_t*wxh_ptr = (word_t*)&wxh_q; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; *wxh_ptr = ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]) ; wxh_ptr++; *wxh_ptr = ((((current->use_spec_F)[((((((inst >> 16) & 0x1f))+1)&~1))/32] & (1 << (((((((inst >> 16) & 0x1f))+1)&~1)) % 32))) != 0) ? current->spec_regs_F.l[((((inst >> 16) & 0x1f))+1)] : current->regs.regs_F.l[((((inst >> 16) & 0x1f))+1)]); (temp_qword = ((wxh_q)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_qword, sizeof(temp_qword))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_qword, sizeof(temp_qword), current->id, inst)))); }; break;











case SLL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f))))); }; break;




case MOVCI_LINK: _panic("machine.def", __FUNCTION__, 656, "attempted to execute a linking opcode");
# 681 "machine.def"
case SRL: { if (((((inst) >> (6)) & (0x1f))) != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 713 "machine.def"
case SRA: { int _i; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < (((inst) >> (6)) & (0x1f)); _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f))))); } }; break;
# 722 "machine.def"
case SLLV: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037)))); }; break;
# 751 "machine.def"
case SRLV: { int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (_shamt != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 784 "machine.def"
case SRAV: { int _i; int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < _shamt; _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt))); } }; break;
# 799 "machine.def"
case JR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 816 "machine.def"
case JALR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8))); (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 826 "machine.def"
case MOVZ: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 836 "machine.def"
case MOVN: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 845 "machine.def"
case SYSCALL: { ( (current->spec_mode ? _panic("machine.def", __FUNCTION__, 848, "speculative syscall") : (void) 0), sys_syscall(&(current->regs), mem_access, current->mem, inst, 1)); }; break;
# 857 "machine.def"
case BREAK: { { fault = (md_fault_break); break; }; }; break;
# 868 "machine.def"
case MFHI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); }; break;
# 877 "machine.def"
case MTHI: { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 886 "machine.def"
case MFLO: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); }; break;
# 895 "machine.def"
case MTLO: { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 957 "machine.def"
case MULT: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } }; break;
# 989 "machine.def"
case MULTU: { int _i; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } } }; break;
# 1003 "machine.def"
case DIV: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; int quotient = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) / ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); int mod = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) % ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (current->spec_mode ? ((current->spec_regs_C.lo = (quotient)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (quotient))); (current->spec_mode ? ((current->spec_regs_C.hi = (mod)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (mod))); }; break;
# 1015 "machine.def"
case DIVU: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; (current->spec_mode ? ((current->spec_regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); (current->spec_mode ? ((current->spec_regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1027 "machine.def"
case ADD: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1036 "machine.def"
case ADDU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1048 "machine.def"
case SUB: { if (((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) > 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < 0) && (0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))) || (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) < 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > 0) && (-0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1057 "machine.def"
case SUBU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1066 "machine.def"
case AND: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1075 "machine.def"
case OR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1084 "machine.def"
case XOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1093 "machine.def"
case NOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1105 "machine.def"
case SLT: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1117 "machine.def"
case SLTU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1137 "machine.def"
case TEQ: { if(current->spec_mode) break; if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])==((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) _fatal("machine.def", __FUNCTION__, 1140, "TEQ TRAP!\n"); }; break;








# 1159 "machine.def"
case MOVF: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 1176 "machine.def"
case MOVT: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 1) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;






# 1195 "machine.def"
case BLTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1211 "machine.def"
case BGEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1228 "machine.def"
case BLTZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1245 "machine.def"
case BGEZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;











case MFC0: { _fatal("machine.def", __FUNCTION__, 1260, "MFC0 unimplemented\n"); }; break;
# 1266 "machine.def"
case MTC0: { _fatal("machine.def", __FUNCTION__, 1269, "MTC0 unimplemented\n"); }; break;











case MFC1: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1287 "machine.def"
case CFC1: { }; break;
# 1296 "machine.def"
case MTC1: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 11) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1305 "machine.def"
case CTC1: { }; break;




case COP1_BC_LINK: _panic("machine.def", __FUNCTION__, 1310, "attempted to execute a linking opcode");

case COP1_S_LINK: _panic("machine.def", __FUNCTION__, 1312, "attempted to execute a linking opcode");

case COP1_D_LINK: _panic("machine.def", __FUNCTION__, 1314, "attempted to execute a linking opcode");

case COP1_W_LINK: _panic("machine.def", __FUNCTION__, 1316, "attempted to execute a linking opcode");


# 1330 "machine.def"
case BC1F: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (!((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1345 "machine.def"
case BC1T: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) +4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;





# 1359 "machine.def"
case FADD_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1371 "machine.def"
case FSUB_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1383 "machine.def"
case FMUL_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1395 "machine.def"
case FDIV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1407 "machine.def"
case FSQRT_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1419 "machine.def"
case FABS_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1431 "machine.def"
case FMOV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1443 "machine.def"
case FNEG_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1452 "machine.def"
case TRUNC_S: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1))); }; break;




case COP1_MOVCF_S_LINK: _panic("machine.def", __FUNCTION__, 1457, "attempted to execute a linking opcode");
# 1468 "machine.def"
case FMOVZ_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1481 "machine.def"
case FMOVN_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1493 "machine.def"
case CVT_D_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1505 "machine.def"
case CVT_W_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1517 "machine.def"
case C_EQ_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1529 "machine.def"
case C_LT_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1541 "machine.def"
case C_LE_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;











case MOVF_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1563 "machine.def"
case MOVT_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;





# 1577 "machine.def"
case FADD_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1589 "machine.def"
case FSUB_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1601 "machine.def"
case FMUL_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1613 "machine.def"
case FDIV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1625 "machine.def"
case FSQRT_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1637 "machine.def"
case FABS_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1649 "machine.def"
case FMOV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1661 "machine.def"
case FNEG_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;




case COP1_MOVCF_D_LINK: _panic("machine.def", __FUNCTION__, 1666, "attempted to execute a linking opcode");
# 1676 "machine.def"
case FMOVZ_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1689 "machine.def"
case FMOVN_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1698 "machine.def"
case TRUNC_D: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1))); }; break;
# 1712 "machine.def"
case CVT_S_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1724 "machine.def"
case CVT_W_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1736 "machine.def"
case C_EQ_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1748 "machine.def"
case C_LT_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1760 "machine.def"
case C_LE_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;











case MOVF_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1782 "machine.def"
case MOVT_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;





# 1796 "machine.def"
case CVT_S_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1808 "machine.def"
case CVT_D_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;





# 1877 "machine.def"
case MADD: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; sword_t temp1, temp2; temp1 = ((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi); temp2 = ((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo); _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2))); }; break;
# 1886 "machine.def"
case MUL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 11911 "sim-outorder.c" 2
     default:
       _panic("sim-outorder.c", __FUNCTION__, 11912, "attempted to execute a bogus opcode 0x%x",current->regs.regs_PC);
    }

    if (fault != md_fault_none)
     _fatal("sim-outorder.c", __FUNCTION__, 11916, "fault (%d) detected @ 0x%08p", fault, current->regs.regs_PC);


    if ((md_op2flags[op]) & 0x00000020)
    {
     if ((md_op2flags[op]) & 0x00000080)
     {
      is_write = 1;

      cache_warmup(cache_dl1[threadid], Write, addr & ~7, 8, threadid);

     }

     else
      cache_warmup(cache_dl1[threadid], Read, addr & ~7, 8, threadid);

    }


    if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_NPC), (is_write ? 0x02 : 0x01), (addr), (sim_num_insn), (sim_num_insn)) : 0))
     dlite_main (current->regs.regs_PC, current->regs.regs_NPC, sim_num_insn, &(current->regs), current->mem);


    current->regs.regs_PC = current->regs.regs_NPC;
    current->regs.regs_NPC += sizeof (md_inst_t);


    if ((current->barrierReached == 1 || current->barrierReached == 2))
    {
     if(current->barrierReached == 2)
     {
      barrierCount++;
      printf("Crossed the barrier number: %d with threadid: %d\n", barrierCount, threadid);
     }
     current->barrierReached = 0;
     break;
    }

    if(collect_stats)
    {
     printf("Finished fast-forwarding at barrier number: %d with threadid: %d\n", barrierCount, threadid);
     return;
    }

   }
  }
 }
}

 void
fstfwd_fineAdjust ()
{
 int threadid;
 int count = 0;
 int totalItr = 2;
 int prId = 0;
 md_addr_t tempPC[3] = { 0, 0, 0 };

 for (threadid = 0; threadid < numcontexts; threadid++)
 {

  if (thecontexts[threadid]->jobThdId != 0)
  {
   thecontexts[threadid]->regs.regs_PC = thecontexts[threadid]->regs.regs_NPC;
   thecontexts[threadid]->regs.regs_NPC += sizeof (md_inst_t);
  }

  if (thecontexts[threadid]->barrierReached == 1)
   _panic("sim-outorder.c", __FUNCTION__, 11984, "Fast forward error\n");

  if (thecontexts[threadid]->startReached == 1)
   _panic("sim-outorder.c", __FUNCTION__, 11987, "Fast forward error\n");
 }
 if(ilink_run)
 {
  collect_stats = 1;
  return 0;
 }


 {
  count = 0;


  for (threadid = 0;threadid < numcontexts; threadid = (threadid + numcontexts + 1) % numcontexts)
  {
   context *current = thecontexts[threadid];

   if (current->masterid != prId)
    continue;


   if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_PC), (0), (0), (0), (0)) : 0))
    dlite_main (current->regs.regs_PC, current->regs.regs_PC + sizeof (md_inst_t), sim_cycle, &(current->regs), current->mem);

   counter_t icount = 0;
   md_inst_t inst;
   enum md_opcode op;
   md_addr_t target_PC;
   md_addr_t addr;
   int is_write;
   byte_t temp_byte;
   half_t temp_half;
   word_t temp_word;


   qword_t temp_qword = 0;


   enum md_fault_type fault;

   while (1)
   {
    icount++;

    current->regs.regs_R[MD_REG_ZERO] = 0;





    { (inst) = ((( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) ? *((word_t *)(( (((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))] && ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->tag == (((md_addr_t)((current->regs.regs_PC))) >> (12 + 15))) ? ( ((current->mem))->ptab_accesses++, ((current->mem))->ptab[((((md_addr_t)((current->regs.regs_PC))) >> 12) & ((32*1024) - 1))]->page) : ( mem_translate(((current->mem)), ((md_addr_t)((current->regs.regs_PC)))))) + (((current->regs.regs_PC)) & (4096 - 1)))) : 0)); };
    cache_warmup (cache_il1[threadid], Read, (current->fetch_regs_PC), (sizeof(md_inst_t)), threadid);


    addr = 0;
    is_write = 0;


    fault = md_fault_none;


    { op = md_mask2op[(((inst) >> 26) & 0x3f)]; while (md_opmask[op]){ op = md_mask2op[((inst >> md_opshift[op]) & md_opmask[op]) + md_opoffset[op]]; } };


    switch (op)
    {
# 12065 "sim-outorder.c"
# 1 "machine.def" 1
case SPECIAL_LINK: _panic("machine.def", __FUNCTION__, 1, "attempted to execute a linking opcode");

case REGIMM_LINK: _panic("machine.def", __FUNCTION__, 3, "attempted to execute a linking opcode");
# 12 "machine.def"
case JUMP: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 26 "machine.def"
case JAL: { (target_PC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->regs.regs_NPC = (((current->regs.regs_PC) & 036000000000) | ((inst & 0x3ffffff) << 2))); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 41 "machine.def"
case BEQ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 57 "machine.def"
case BNE: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) != ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 73 "machine.def"
case BLEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) <= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 89 "machine.def"
case BGTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) > 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 101 "machine.def"
case ADDI: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((int)(( short)(inst & 0xffff))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 110 "machine.def"
case ADDIU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))))); }; break;
# 122 "machine.def"
case SLTI: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 134 "machine.def"
case SLTIU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((int)(( short)(inst & 0xffff)))) (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (0))); }; break;
# 143 "machine.def"
case ANDI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & (inst & 0xffff)))); }; break;
# 152 "machine.def"
case ORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | (inst & 0xffff)))); }; break;
# 161 "machine.def"
case XORI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ (inst & 0xffff)))); }; break;
# 170 "machine.def"
case LUI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((inst & 0xffff) << 16))); }; break;




case COP0_LINK: _panic("machine.def", __FUNCTION__, 175, "attempted to execute a linking opcode");

case COP1_LINK: _panic("machine.def", __FUNCTION__, 177, "attempted to execute a linking opcode");

case COP2_LINK: _panic("machine.def", __FUNCTION__, 179, "attempted to execute a linking opcode");

case SPECIAL2_LINK: _panic("machine.def", __FUNCTION__, 181, "attempted to execute a linking opcode");
# 193 "machine.def"
case LB: { sbyte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 208 "machine.def"
case LH: { shalf_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)(sword_t)_result))); }; break;
# 249 "machine.def"
case LWL: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))) | ((_lr_temp << (8 * ((4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))-1))) & ~((md_lr_masks[(((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))))))); }; break;
# 265 "machine.def"
case LW: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 289 "machine.def"
case LL: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; if(!current->spec_mode && _result == 0) { common_regs_s[current->masterid][current->actualid].regs_lock = 1; common_regs_s[current->masterid][current->actualid].address = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))); } (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (_result))); }; break;
# 307 "machine.def"
case LBU: { byte_t _result; enum md_fault_type _fault; _result = (addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_byte, sizeof(temp_byte), current->id, inst))), temp_byte); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 322 "machine.def"
case LHU: { half_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_half, sizeof(temp_half), current->id, inst))), temp_half)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result)), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = ((word_t)_result))); }; break;
# 362 "machine.def"
case LWR: { md_addr_t _temp_bs; word_t _lr_temp; enum md_fault_type _fault; _temp_bs = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _lr_temp = ((addr = ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))]))))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & ~(md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | ((_lr_temp >> (8 * ((((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)-1))) & (md_lr_masks[4-(4-((_temp_bs + ((int)(( short)(inst & 0xffff)))) & 0x03))])))))); }; break;
# 377 "machine.def"
case SB: { byte_t _src; enum md_fault_type _fault; _src = (byte_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_byte = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_byte, sizeof(temp_byte))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_byte, sizeof(temp_byte), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 392 "machine.def"
case SH: { half_t _src; enum md_fault_type _fault; _src = (half_t)(word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_half = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_half, sizeof(temp_half))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_half, sizeof(temp_half), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 432 "machine.def"
case SWL: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (8 * (4 - (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)))) & (md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)])) | (_lr_temp & ~(md_lr_masks[4-(((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03)+1)]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])+((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 447 "machine.def"
case SW: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 501 "machine.def"
case SC: { word_t _src; enum md_fault_type _fault; int ii = 0; _src = (word_t)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if(COHERENT_CACHE && allForked && collect_stats) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if(_fault != md_fault_none) { { fault = (_fault); break; }; } } else { if(!current->spec_mode) { if((common_regs_s[current->masterid][current->actualid].regs_lock == 1) && (common_regs_s[current->masterid][current->actualid].address == ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) + (((int)(( short)(inst & 0xffff)))))) { (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { { fault = (_fault); break; }; } for(ii = 0; ii < 64; ii++) { if(common_regs_s[current->masterid][ii].address == (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))) { common_regs_s[current->masterid][ii].regs_lock = 0; common_regs_s[current->masterid][ii].address = 0; } } } else (current->spec_mode ? ((current->spec_regs_R[((inst >> 21) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] |= (1 << (((((inst >> 21) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 21) & 0x1f)]) : (current->regs.regs_R[((inst >> 21) & 0x1f)] = (0))); } else { current->waitForBranchResolve = 1; } } }; break;
# 547 "machine.def"
case SWR: { word_t _lr_temp; enum md_fault_type _fault; _lr_temp = ((addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _lr_temp = (((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (8 * (4 - (4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))))) & ~(md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))])) | (_lr_temp & (md_lr_masks[(4-((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & 0x03))]))); (temp_word = ((_lr_temp)), addr = ((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff)))) & ~0x03))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 568 "machine.def"
case LWC1: { word_t _result; enum md_fault_type _fault; _result = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result))); }; break;
# 591 "machine.def"
case LDC1: { word_t _result_hi, _result_lo; enum md_fault_type _fault; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; _result_hi = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; _result_lo = ((addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))) + 4)), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Read, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Read, addr, &temp_word, sizeof(temp_word), current->id, inst))), temp_word)); if (_fault != md_fault_none) { fault = (_fault); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi)), (((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 16) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 16) & 0x1f))] = (_result_hi))); (current->spec_mode ? ((current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo)), (((current->use_spec_F)[((((((inst >> 16) & 0x1f)) + 1)&~1))/32] |= (1 << (((((((inst >> 16) & 0x1f)) + 1)&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[((((inst >> 16) & 0x1f)) + 1)]) : (current->regs.regs_F.l[((((inst >> 16) & 0x1f)) + 1)] = (_result_lo))); }; break;
# 606 "machine.def"
case SWC1: { word_t _src; enum md_fault_type _fault; _src = (word_t)((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]); (temp_word = ((_src)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_word, sizeof(temp_word))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_word, sizeof(temp_word), current->id, inst)))); if (_fault != md_fault_none) { fault = (_fault); break; }; }; break;
# 639 "machine.def"
case SDC1: { enum md_fault_type _fault; qword_t wxh_q; word_t*wxh_ptr = (word_t*)&wxh_q; if ((((inst >> 16) & 0x1f)) & 01) { fault = (md_fault_alignment); break; }; *wxh_ptr = ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 16) & 0x1f))] : current->regs.regs_F.l[(((inst >> 16) & 0x1f))]) ; wxh_ptr++; *wxh_ptr = ((((current->use_spec_F)[((((((inst >> 16) & 0x1f))+1)&~1))/32] & (1 << (((((((inst >> 16) & 0x1f))+1)&~1)) % 32))) != 0) ? current->spec_regs_F.l[((((inst >> 16) & 0x1f))+1)] : current->regs.regs_F.l[((((inst >> 16) & 0x1f))+1)]); (temp_qword = ((wxh_q)), addr = ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((int)(( short)(inst & 0xffff))))), (current->spec_mode ? (((_fault)) = spec_mem_access(current->mem, Write, addr, &temp_qword, sizeof(temp_qword))) : (((_fault)) = WB_access1(current->mem, Write, addr, &temp_qword, sizeof(temp_qword), current->id, inst)))); }; break;











case SLL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((inst) >> (6)) & (0x1f))))); }; break;




case MOVCI_LINK: _panic("machine.def", __FUNCTION__, 656, "attempted to execute a linking opcode");
# 681 "machine.def"
case SRL: { if (((((inst) >> (6)) & (0x1f))) != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (((((inst) >> (6)) & (0x1f))) - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 713 "machine.def"
case SRA: { int _i; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < (((inst) >> (6)) & (0x1f)); _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> (((inst) >> (6)) & (0x1f))))); } }; break;
# 722 "machine.def"
case SLLV: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) << (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037)))); }; break;
# 751 "machine.def"
case SRLV: { int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (_shamt != 0) { word_t _rd; _rd = (((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) >> 1) & ~0x80000000; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1)))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((_rd >> (_shamt - 1))))); } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } }; break;
# 784 "machine.def"
case SRAV: { int _i; int _shamt = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 037; if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) & 0x80000000) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); for (_i = 0; _i < _shamt; _i++) { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((((((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] & (1 << (((((inst >> 11) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 11) & 0x1f)] : current->regs.regs_R[((inst >> 11) & 0x1f)]) >> 1) | 0x80000000))); } } else { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) >> _shamt))); } }; break;
# 799 "machine.def"
case JR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 816 "machine.def"
case JALR: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 0x3) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = ((current->regs.regs_PC) + 8))); (target_PC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); (current->regs.regs_NPC = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 826 "machine.def"
case MOVZ: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 836 "machine.def"
case MOVN: { if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 845 "machine.def"
case SYSCALL: { ( (current->spec_mode ? _panic("machine.def", __FUNCTION__, 848, "speculative syscall") : (void) 0), sys_syscall(&(current->regs), mem_access, current->mem, inst, 1)); }; break;
# 857 "machine.def"
case BREAK: { { fault = (md_fault_break); break; }; }; break;
# 868 "machine.def"
case MFHI: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); }; break;
# 877 "machine.def"
case MTHI: { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 886 "machine.def"
case MFLO: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); }; break;
# 895 "machine.def"
case MTLO: { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 957 "machine.def"
case MULT: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } }; break;
# 989 "machine.def"
case MULTU: { int _i; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); } } }; break;
# 1003 "machine.def"
case DIV: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; int quotient = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) / ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); int mod = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) % ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); (current->spec_mode ? ((current->spec_regs_C.lo = (quotient)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (quotient))); (current->spec_mode ? ((current->spec_regs_C.hi = (mod)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (mod))); }; break;
# 1015 "machine.def"
case DIVU: { if (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]) == 0) { fault = (md_fault_div0); break; }; (current->spec_mode ? ((current->spec_regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) / ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); (current->spec_mode ? ((current->spec_regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) % ((unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1027 "machine.def"
case ADD: { if ((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]), ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1036 "machine.def"
case ADDU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) + ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1048 "machine.def"
case SUB: { if (((((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) > 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < 0) && (0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) < (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))) || (((((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])) < 0) && ((((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > 0) && (-0x7fffffff + (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) > (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))))) { fault = (md_fault_overflow); break; }; (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1057 "machine.def"
case SUBU: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) - ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1066 "machine.def"
case AND: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) & ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1075 "machine.def"
case OR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1084 "machine.def"
case XOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) ^ ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1093 "machine.def"
case NOR: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (~(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) | ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))))); }; break;
# 1105 "machine.def"
case SLT: { if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1117 "machine.def"
case SLTU: { if ((unsigned)((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < (unsigned)((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (1)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (1))); else (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (0)), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (0))); }; break;
# 1137 "machine.def"
case TEQ: { if(current->spec_mode) break; if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])==((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])) _fatal("machine.def", __FUNCTION__, 1140, "TEQ TRAP!\n"); }; break;








# 1159 "machine.def"
case MOVF: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 0) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;
# 1176 "machine.def"
case MOVT: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc) == 1) (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)])))); }; break;






# 1195 "machine.def"
case BLTZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1211 "machine.def"
case BGEZ: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0){ (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); } else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1228 "machine.def"
case BLTZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) < 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1245 "machine.def"
case BGEZAL: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); if(((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) >= 0) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) <<2))); else delay_slot(current->id); (current->spec_mode ? ((current->spec_regs_R[31] = ((current->regs.regs_PC) + 8)), (((current->use_spec_R)[((31))/32] |= (1 << (((31)) % 32))), (current->use_spec_R)), current->spec_regs_R[31]) : (current->regs.regs_R[31] = ((current->regs.regs_PC) + 8))); if (collect_stats == 0) delay_slot_ff(current->id); }; break;











case MFC0: { _fatal("machine.def", __FUNCTION__, 1260, "MFC0 unimplemented\n"); }; break;
# 1266 "machine.def"
case MTC0: { _fatal("machine.def", __FUNCTION__, 1269, "MTC0 unimplemented\n"); }; break;











case MFC1: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] |= (1 << (((((inst >> 16) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 16) & 0x1f)]) : (current->regs.regs_R[((inst >> 16) & 0x1f)] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1287 "machine.def"
case CFC1: { }; break;
# 1296 "machine.def"
case MTC1: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 11) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 11) & 0x1f))] = (((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 1305 "machine.def"
case CTC1: { }; break;




case COP1_BC_LINK: _panic("machine.def", __FUNCTION__, 1310, "attempted to execute a linking opcode");

case COP1_S_LINK: _panic("machine.def", __FUNCTION__, 1312, "attempted to execute a linking opcode");

case COP1_D_LINK: _panic("machine.def", __FUNCTION__, 1314, "attempted to execute a linking opcode");

case COP1_W_LINK: _panic("machine.def", __FUNCTION__, 1316, "attempted to execute a linking opcode");


# 1330 "machine.def"
case BC1F: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (!((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;
# 1345 "machine.def"
case BC1T: { (target_PC = ((current->regs.regs_PC) + 4 + (((int)(( short)(inst & 0xffff))) << 2))); if (((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)) (current->regs.regs_NPC = ((current->regs.regs_PC) +4 + (((int)(( short)(inst & 0xffff))) << 2))); else delay_slot(current->id); if (collect_stats == 0) delay_slot_ff(current->id); }; break;





# 1359 "machine.def"
case FADD_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1371 "machine.def"
case FSUB_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1383 "machine.def"
case FMUL_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1395 "machine.def"
case FDIV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1407 "machine.def"
case FSQRT_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)sqrt((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1419 "machine.def"
case FABS_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((sfloat_t)fabs((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))))); }; break;
# 1431 "machine.def"
case FMOV_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1443 "machine.def"
case FNEG_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1452 "machine.def"
case TRUNC_S: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])/1))); }; break;




case COP1_MOVCF_S_LINK: _panic("machine.def", __FUNCTION__, 1457, "attempted to execute a linking opcode");
# 1468 "machine.def"
case FMOVZ_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1481 "machine.def"
case FMOVN_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1493 "machine.def"
case CVT_D_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1505 "machine.def"
case CVT_W_S: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1517 "machine.def"
case C_EQ_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1529 "machine.def"
case C_LT_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;
# 1541 "machine.def"
case C_LE_S: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 16) & 0x1f))] : current->regs.regs_F.f[(((inst >> 16) & 0x1f))])))); }; break;











case MOVF_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1563 "machine.def"
case MOVT_S: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;





# 1577 "machine.def"
case FADD_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) + ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1589 "machine.def"
case FSUB_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) - ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1601 "machine.def"
case FMUL_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) * ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1613 "machine.def"
case FDIV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) / ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1625 "machine.def"
case FSQRT_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (sqrt(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1637 "machine.def"
case FABS_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (fabs(((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))))); }; break;
# 1649 "machine.def"
case FMOV_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1661 "machine.def"
case FNEG_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (-((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;




case COP1_MOVCF_D_LINK: _panic("machine.def", __FUNCTION__, 1666, "attempted to execute a linking opcode");
# 1676 "machine.def"
case FMOVZ_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])==0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1689 "machine.def"
case FMOVN_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; if(((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])!=0) (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.f[(((inst >> 11) & 0x1f))] : current->regs.regs_F.f[(((inst >> 11) & 0x1f))])))); }; break;
# 1698 "machine.def"
case TRUNC_D: { (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1)), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])/1))); }; break;
# 1712 "machine.def"
case CVT_S_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1724 "machine.def"
case CVT_W_D: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.l[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.l[(((inst >> 6) & 0x1f))] = ((sword_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1736 "machine.def"
case C_EQ_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) == ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1748 "machine.def"
case C_LT_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) < ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;
# 1760 "machine.def"
case C_LE_D: { if (((((inst >> 11) & 0x1f)) & 01) || ((((inst >> 16) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1]))), (((current->use_spec_C)[(2)/32] |= (1 << ((2) % 32))), (current->use_spec_C)), current->spec_regs_C.fcc) : (current->regs.regs_C.fcc = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]) <= ((((current->use_spec_F)[(((((inst >> 16) & 0x1f))&~1))/32] & (1 << ((((((inst >> 16) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 16) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 16) & 0x1f)) >> 1])))); }; break;











case MOVF_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==0) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;
# 1782 "machine.def"
case MOVT_D: { if(((((current->use_spec_C)[(2)/32] & (1 << ((2) % 32))) != 0) ? current->spec_regs_C.fcc : current->regs.regs_C.fcc)==1) (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = (((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.d[(((inst >> 11) & 0x1f)) >> 1] : current->regs.regs_F.d[(((inst >> 11) & 0x1f)) >> 1])))); }; break;





# 1796 "machine.def"
case CVT_S_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.f[(((inst >> 6) & 0x1f))]) : (current->regs.regs_F.f[(((inst >> 6) & 0x1f))] = ((float)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;
# 1808 "machine.def"
case CVT_D_W: { if (((((inst >> 6) & 0x1f)) & 01) || ((((inst >> 11) & 0x1f)) & 01)) { fault = (md_fault_alignment); break; }; (current->spec_mode ? ((current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))]))), (((current->use_spec_F)[(((((inst >> 6) & 0x1f))&~1))/32] |= (1 << ((((((inst >> 6) & 0x1f))&~1)) % 32))), (current->use_spec_F)), current->spec_regs_F.d[(((inst >> 6) & 0x1f)) >> 1]) : (current->regs.regs_F.d[(((inst >> 6) & 0x1f)) >> 1] = ((dfloat_t)((((current->use_spec_F)[(((((inst >> 11) & 0x1f))&~1))/32] & (1 << ((((((inst >> 11) & 0x1f))&~1)) % 32))) != 0) ? current->spec_regs_F.l[(((inst >> 11) & 0x1f))] : current->regs.regs_F.l[(((inst >> 11) & 0x1f))])))); }; break;





# 1877 "machine.def"
case MADD: { bool_t _sign1, _sign2; int _i; sword_t _op1, _op2; sword_t temp1, temp2; temp1 = ((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi); temp2 = ((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo); _sign1 = _sign2 = 0; (current->spec_mode ? ((current->spec_regs_C.hi = (0)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (0))); (current->spec_mode ? ((current->spec_regs_C.lo = (0)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (0))); _op1 = ((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]); _op2 = ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]); if (_op1 & 020000000000) { _sign1 = 1; _op1 = (~_op1) + 1; } if (_op2 & 020000000000) { _sign2 = 1; _op2 = (~_op2) + 1; } if (_op1 & 020000000000) { (current->spec_mode ? ((current->spec_regs_C.lo = (_op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (_op2))); } for (_i = 0; _i < 31; _i++) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) << 1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + extractl(((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo), 31, 1)))); (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) << 1))); if ((extractl(_op1, 30 - _i, 1)) == 1) { if (((unsigned)037777777777 - (unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)) < (unsigned)_op2) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + _op2))); } } if (_sign1 ^ _sign2) { (current->spec_mode ? ((current->spec_regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo))), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (~((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo)))); (current->spec_mode ? ((current->spec_regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi))), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (~((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi)))); if ((unsigned)((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) == 037777777777) { (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + 1))); } (current->spec_mode ? ((current->spec_regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1)), (((current->use_spec_C)[(1)/32] |= (1 << ((1) % 32))), (current->use_spec_C)), current->spec_regs_C.lo) : (current->regs.regs_C.lo = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + 1))); } (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(0)/32] & (1 << ((0) % 32))) != 0) ? current->spec_regs_C.hi : current->regs.regs_C.hi) + temp1))); (current->spec_mode ? ((current->spec_regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2)), (((current->use_spec_C)[(0)/32] |= (1 << ((0) % 32))), (current->use_spec_C)), current->spec_regs_C.hi) : (current->regs.regs_C.hi = (((((current->use_spec_C)[(1)/32] & (1 << ((1) % 32))) != 0) ? current->spec_regs_C.lo : current->regs.regs_C.lo) + temp2))); }; break;
# 1886 "machine.def"
case MUL: { (current->spec_mode ? ((current->spec_regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)]))), (((current->use_spec_R)[((((inst >> 11) & 0x1f)))/32] |= (1 << (((((inst >> 11) & 0x1f))) % 32))), (current->use_spec_R)), current->spec_regs_R[((inst >> 11) & 0x1f)]) : (current->regs.regs_R[((inst >> 11) & 0x1f)] = (((((current->use_spec_R)[((((inst >> 21) & 0x1f)))/32] & (1 << (((((inst >> 21) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 21) & 0x1f)] : current->regs.regs_R[((inst >> 21) & 0x1f)]) * ((((current->use_spec_R)[((((inst >> 16) & 0x1f)))/32] & (1 << (((((inst >> 16) & 0x1f))) % 32))) != 0) ? current->spec_regs_R[((inst >> 16) & 0x1f)] : current->regs.regs_R[((inst >> 16) & 0x1f)])))); }; break;
# 12066 "sim-outorder.c" 2
     default:
       _panic("sim-outorder.c", __FUNCTION__, 12067, "attempted to execute a bogus opcode 0x%x",current->regs.regs_PC);
    }

    if (fault != md_fault_none)
     _fatal("sim-outorder.c", __FUNCTION__, 12071, "fault (%d) detected @ 0x%08p", fault, current->regs.regs_PC);


    if ((md_op2flags[op]) & 0x00000020)
    {
     if ((md_op2flags[op]) & 0x00000080)
     {
      is_write = 1;
      cache_warmup(cache_dl1[threadid], Write, addr & ~7, 8, threadid);
     }
     else
      cache_warmup(cache_dl1[threadid], Read, addr & ~7, 8, threadid);
    }


    if (((dlite_check || dlite_active) ? __check_break((current->regs.regs_NPC), (is_write ? 0x02 : 0x01), (addr), (sim_num_insn), (sim_num_insn)) : 0))
     dlite_main (current->regs.regs_PC, current->regs.regs_NPC, sim_num_insn, &(current->regs), current->mem);


    current->regs.regs_PC = current->regs.regs_NPC;
    current->regs.regs_NPC += sizeof (md_inst_t);

    if (count == 0 && (current->barrierReached == 1 || current->barrierReached == 2))
     break;

    if (count == 0 && current->startReached)
    {
     current->startReached = 0;

     if(current->jobThdId != 0)
      _panic("sim-outorder.c", __FUNCTION__, 12101, "Can not be reached by other threads");

     count++;
     continue;
    }

    if(count == 5)
     break;

    if(count > 0 && count < 6)
     count++;

    if (count == 6 && current->regs.regs_PC == tempPC[current->masterid])
     break;
   }

   if (count == 0 && (current->barrierReached == 1 || current->barrierReached == 2))
   {
    if(current->barrierReached == 2 && current->jobThdId != (64 -1))
     _panic("sim-outorder.c", __FUNCTION__, 12120, "End of barrier reached with wrong id");

    current->barrierReached = 0;
    continue;
   }

   if (count == 5)
   {
    count++;
    tempPC[current->masterid] = current->regs.regs_PC;
    continue;
   }

   if (count == 6 && current->regs.regs_PC == tempPC[current->masterid])
   {
    if (current->jobThdId == (64 -1))
     break;
    else
     continue;
   }
  }

  printf("Job %d synchronized\n", prId);
  fflush(stdout);
 }
}
